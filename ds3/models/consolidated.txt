package models

import (
"net/http"
"io"
"encoding/xml"
"fmt"
"bytes"
"errors"
"log"
"io/ioutil"
"strings"
"strconv"
)
type AbortMultiPartUploadRequest struct {
    BucketName string
    ObjectName string
    UploadId string
}

func NewAbortMultiPartUploadRequest(bucketName string, objectName string, uploadId string) *AbortMultiPartUploadRequest {
    return &AbortMultiPartUploadRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        UploadId: uploadId,
    }
}

type AbortMultiPartUploadResponse struct {
    
    Headers *http.Header
}



func NewAbortMultiPartUploadResponse(webResponse WebResponse) (*AbortMultiPartUploadResponse, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &AbortMultiPartUploadResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ActiveJob struct {
    Aggregating bool
    BucketId string
    CachedSizeInBytes int64
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    CompletedSizeInBytes int64
    CreatedAt string
    DeadJobCleanupAllowed bool
    ErrorMessage *string
    Id string
    ImplicitJobIdResolution bool
    MinimizeSpanningAcrossMedia bool
    Naked bool
    Name *string
    OriginalSizeInBytes int64
    Priority Priority
    Rechunked *string
    Replicating bool
    RequestType JobRequestType
    Truncated bool
    TruncatedDueToTimeout bool
    UserId string
    VerifyAfterWrite bool
}
type ActiveJobList struct {
    ActiveJobs []ActiveJob
}
func (activeJobList *ActiveJobList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Job":
            var model ActiveJob
            model.parse(&child, aggErr)
            activeJobList.ActiveJobs = append(activeJobList.ActiveJobs, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ActiveJobList.", child.XMLName.Local)
        }
    }
}
func (activeJob *ActiveJob) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Aggregating":
            activeJob.Aggregating = parseBool(child.Content, aggErr)
        case "BucketId":
            activeJob.BucketId = parseString(child.Content)
        case "CachedSizeInBytes":
            activeJob.CachedSizeInBytes = parseInt64(child.Content, aggErr)
        case "ChunkClientProcessingOrderGuarantee":
            parseEnum(child.Content, &activeJob.ChunkClientProcessingOrderGuarantee, aggErr)
        case "CompletedSizeInBytes":
            activeJob.CompletedSizeInBytes = parseInt64(child.Content, aggErr)
        case "CreatedAt":
            activeJob.CreatedAt = parseString(child.Content)
        case "DeadJobCleanupAllowed":
            activeJob.DeadJobCleanupAllowed = parseBool(child.Content, aggErr)
        case "ErrorMessage":
            activeJob.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            activeJob.Id = parseString(child.Content)
        case "ImplicitJobIdResolution":
            activeJob.ImplicitJobIdResolution = parseBool(child.Content, aggErr)
        case "MinimizeSpanningAcrossMedia":
            activeJob.MinimizeSpanningAcrossMedia = parseBool(child.Content, aggErr)
        case "Naked":
            activeJob.Naked = parseBool(child.Content, aggErr)
        case "Name":
            activeJob.Name = parseNullableString(child.Content)
        case "OriginalSizeInBytes":
            activeJob.OriginalSizeInBytes = parseInt64(child.Content, aggErr)
        case "Priority":
            parseEnum(child.Content, &activeJob.Priority, aggErr)
        case "Rechunked":
            activeJob.Rechunked = parseNullableString(child.Content)
        case "Replicating":
            activeJob.Replicating = parseBool(child.Content, aggErr)
        case "RequestType":
            parseEnum(child.Content, &activeJob.RequestType, aggErr)
        case "Truncated":
            activeJob.Truncated = parseBool(child.Content, aggErr)
        case "TruncatedDueToTimeout":
            activeJob.TruncatedDueToTimeout = parseBool(child.Content, aggErr)
        case "UserId":
            activeJob.UserId = parseString(child.Content)
        case "VerifyAfterWrite":
            activeJob.VerifyAfterWrite = parseBool(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ActiveJob.", child.XMLName.Local)
        }
    }
}
type AggregateError struct {
    Errors []error
}

func (aggregateError *AggregateError) Error() string {
    msg := fmt.Sprintf("Multiple errors occured: %d\n", len(aggregateError.Errors))

    for i, err := range aggregateError.Errors {
        msg += fmt.Sprintf("%d) %s\n", i + 1, err.Error())
    }

    return msg
}

// Returns the aggregate error if at least one error exists,
// else returns nil
func (aggregateError *AggregateError) GetErrors() error {
    if len (aggregateError.Errors) == 0 {
        return nil
    }
    return aggregateError
}

func (aggregateError *AggregateError) Append(err error) {
    if err != nil {
        aggregateError.Errors = append(aggregateError.Errors, err)
    }
}
type AllocateJobChunkSpectraS3Request struct {
    JobChunkId string
}

func NewAllocateJobChunkSpectraS3Request(jobChunkId string) *AllocateJobChunkSpectraS3Request {
    return &AllocateJobChunkSpectraS3Request{
        JobChunkId: jobChunkId,
    }
}

type AllocateJobChunkSpectraS3Response struct {
    Objects Objects
    Headers *http.Header
}

func (allocateJobChunkSpectraS3Response *AllocateJobChunkSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &allocateJobChunkSpectraS3Response.Objects)
}

func NewAllocateJobChunkSpectraS3Response(webResponse WebResponse) (*AllocateJobChunkSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body AllocateJobChunkSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type AutoInspectMode Enum

const (
    AUTO_INSPECT_MODE_NEVER AutoInspectMode = 1 + iota
    AUTO_INSPECT_MODE_MINIMAL AutoInspectMode = 1 + iota
    AUTO_INSPECT_MODE_FULL AutoInspectMode = 1 + iota
)

func (autoInspectMode *AutoInspectMode) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *autoInspectMode = UNDEFINED
        case "NEVER": *autoInspectMode = AUTO_INSPECT_MODE_NEVER
        case "MINIMAL": *autoInspectMode = AUTO_INSPECT_MODE_MINIMAL
        case "FULL": *autoInspectMode = AUTO_INSPECT_MODE_FULL
        default:
            *autoInspectMode = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into AutoInspectMode", str))
    }
    return nil
}

func (autoInspectMode AutoInspectMode) String() string {
    switch autoInspectMode {
        case AUTO_INSPECT_MODE_NEVER: return "NEVER"
        case AUTO_INSPECT_MODE_MINIMAL: return "MINIMAL"
        case AUTO_INSPECT_MODE_FULL: return "FULL"
        default:
            log.Printf("Error: invalid AutoInspectMode represented by '%d'", autoInspectMode)
            return ""
    }
}

func (autoInspectMode AutoInspectMode) StringPtr() *string {
    if autoInspectMode == UNDEFINED {
        return nil
    }
    result := autoInspectMode.String()
    return &result
}
type AzureDataReplicationRule struct {
    DataPolicyId string
    Id string
    MaxBlobPartSizeInBytes int64
    ReplicateDeletes bool
    State DataPlacementRuleState
    TargetId string
    Type DataReplicationRuleType
}
type AzureDataReplicationRuleList struct {
    AzureDataReplicationRules []AzureDataReplicationRule
}
func (azureDataReplicationRuleList *AzureDataReplicationRuleList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureDataReplicationRule":
            var model AzureDataReplicationRule
            model.parse(&child, aggErr)
            azureDataReplicationRuleList.AzureDataReplicationRules = append(azureDataReplicationRuleList.AzureDataReplicationRules, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureDataReplicationRuleList.", child.XMLName.Local)
        }
    }
}
func (azureDataReplicationRule *AzureDataReplicationRule) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyId":
            azureDataReplicationRule.DataPolicyId = parseString(child.Content)
        case "Id":
            azureDataReplicationRule.Id = parseString(child.Content)
        case "MaxBlobPartSizeInBytes":
            azureDataReplicationRule.MaxBlobPartSizeInBytes = parseInt64(child.Content, aggErr)
        case "ReplicateDeletes":
            azureDataReplicationRule.ReplicateDeletes = parseBool(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &azureDataReplicationRule.State, aggErr)
        case "TargetId":
            azureDataReplicationRule.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &azureDataReplicationRule.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureDataReplicationRule.", child.XMLName.Local)
        }
    }
}
type AzureTarget struct {
    AccountKey *string
    AccountName *string
    AutoVerifyFrequencyInDays *int
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DefaultReadPreference TargetReadPreferenceType
    Https bool
    Id string
    LastFullyVerified *string
    Name *string
    PermitGoingOutOfSync bool
    Quiesced Quiesced
    State TargetState
}
type AzureTargetBucketName struct {
    BucketId string
    Id string
    Name *string
    TargetId string
}
type AzureTargetBucketNameList struct {
    AzureTargetBucketNames []AzureTargetBucketName
}
func (azureTargetBucketNameList *AzureTargetBucketNameList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTargetBucketName":
            var model AzureTargetBucketName
            model.parse(&child, aggErr)
            azureTargetBucketNameList.AzureTargetBucketNames = append(azureTargetBucketNameList.AzureTargetBucketNames, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetBucketNameList.", child.XMLName.Local)
        }
    }
}
func (azureTargetBucketName *AzureTargetBucketName) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            azureTargetBucketName.BucketId = parseString(child.Content)
        case "Id":
            azureTargetBucketName.Id = parseString(child.Content)
        case "Name":
            azureTargetBucketName.Name = parseNullableString(child.Content)
        case "TargetId":
            azureTargetBucketName.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetBucketName.", child.XMLName.Local)
        }
    }
}
type AzureTargetFailure struct {
    Date string
    ErrorMessage *string
    Id string
    TargetId string
    Type TargetFailureType
}
type AzureTargetFailureList struct {
    AzureTargetFailures []AzureTargetFailure
}
func (azureTargetFailureList *AzureTargetFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTargetFailure":
            var model AzureTargetFailure
            model.parse(&child, aggErr)
            azureTargetFailureList.AzureTargetFailures = append(azureTargetFailureList.AzureTargetFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetFailureList.", child.XMLName.Local)
        }
    }
}
type AzureTargetFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type AzureTargetFailureNotificationRegistrationList struct {
    AzureTargetFailureNotificationRegistrations []AzureTargetFailureNotificationRegistration
}
func (azureTargetFailureNotificationRegistrationList *AzureTargetFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTargetFailureNotificationRegistration":
            var model AzureTargetFailureNotificationRegistration
            model.parse(&child, aggErr)
            azureTargetFailureNotificationRegistrationList.AzureTargetFailureNotificationRegistrations = append(azureTargetFailureNotificationRegistrationList.AzureTargetFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (azureTargetFailureNotificationRegistration *AzureTargetFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            azureTargetFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &azureTargetFailureNotificationRegistration.Format, aggErr)
        case "Id":
            azureTargetFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            azureTargetFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            azureTargetFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            azureTargetFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &azureTargetFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            azureTargetFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &azureTargetFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            azureTargetFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            azureTargetFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (azureTargetFailure *AzureTargetFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            azureTargetFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            azureTargetFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            azureTargetFailure.Id = parseString(child.Content)
        case "TargetId":
            azureTargetFailure.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &azureTargetFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetFailure.", child.XMLName.Local)
        }
    }
}
type AzureTargetList struct {
    AzureTargets []AzureTarget
}
func (azureTargetList *AzureTargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTarget":
            var model AzureTarget
            model.parse(&child, aggErr)
            azureTargetList.AzureTargets = append(azureTargetList.AzureTargets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetList.", child.XMLName.Local)
        }
    }
}
func (azureTarget *AzureTarget) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AccountKey":
            azureTarget.AccountKey = parseNullableString(child.Content)
        case "AccountName":
            azureTarget.AccountName = parseNullableString(child.Content)
        case "AutoVerifyFrequencyInDays":
            azureTarget.AutoVerifyFrequencyInDays = parseNullableInt(child.Content, aggErr)
        case "CloudBucketPrefix":
            azureTarget.CloudBucketPrefix = parseNullableString(child.Content)
        case "CloudBucketSuffix":
            azureTarget.CloudBucketSuffix = parseNullableString(child.Content)
        case "DefaultReadPreference":
            parseEnum(child.Content, &azureTarget.DefaultReadPreference, aggErr)
        case "Https":
            azureTarget.Https = parseBool(child.Content, aggErr)
        case "Id":
            azureTarget.Id = parseString(child.Content)
        case "LastFullyVerified":
            azureTarget.LastFullyVerified = parseNullableString(child.Content)
        case "Name":
            azureTarget.Name = parseNullableString(child.Content)
        case "PermitGoingOutOfSync":
            azureTarget.PermitGoingOutOfSync = parseBool(child.Content, aggErr)
        case "Quiesced":
            parseEnum(child.Content, &azureTarget.Quiesced, aggErr)
        case "State":
            parseEnum(child.Content, &azureTarget.State, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTarget.", child.XMLName.Local)
        }
    }
}

func parseAzureTargetSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []AzureTarget {
    var result []AzureTarget
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult AzureTarget
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing AzureTarget struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type AzureTargetReadPreference struct {
    BucketId string
    Id string
    ReadPreference TargetReadPreferenceType
    TargetId string
}
type AzureTargetReadPreferenceList struct {
    AzureTargetReadPreferences []AzureTargetReadPreference
}
func (azureTargetReadPreferenceList *AzureTargetReadPreferenceList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTargetReadPreference":
            var model AzureTargetReadPreference
            model.parse(&child, aggErr)
            azureTargetReadPreferenceList.AzureTargetReadPreferences = append(azureTargetReadPreferenceList.AzureTargetReadPreferences, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetReadPreferenceList.", child.XMLName.Local)
        }
    }
}
func (azureTargetReadPreference *AzureTargetReadPreference) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            azureTargetReadPreference.BucketId = parseString(child.Content)
        case "Id":
            azureTargetReadPreference.Id = parseString(child.Content)
        case "ReadPreference":
            parseEnum(child.Content, &azureTargetReadPreference.ReadPreference, aggErr)
        case "TargetId":
            azureTargetReadPreference.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing AzureTargetReadPreference.", child.XMLName.Local)
        }
    }
}
type BadStatusCodeError struct {
    ExpectedStatusCode []int
    ActualStatusCode int
    ErrorBody *Error
}

func buildBadStatusCodeError(webResponse WebResponse, expectedStatusCodes []int) *BadStatusCodeError {
    var errorBody Error
    var errorBodyPtr *Error

    // Parse the body and if it worked then use the structure.
    err := parseErrorResponseBody(webResponse.Body(), &errorBody)
    if err == nil {
        errorBodyPtr = &errorBody
    }

    // Return the bad status code entity.
    return &BadStatusCodeError{
        expectedStatusCodes,
        webResponse.StatusCode(),
        errorBodyPtr,
    }
}

func parseErrorResponseBody(reader io.ReadCloser, body interface{}) error {
    // Get the bytes or forward the error.
    bytes, err := ioutil.ReadAll(reader)
    if err != nil {
        return err
    }

    // Deserialize or forward the error.
    if err = xml.Unmarshal(bytes, body); err != nil {
        return err
    }

    return nil
}

func (err BadStatusCodeError) Error() string {
    if err.ErrorBody != nil && err.ErrorBody.Message != nil {
        return fmt.Sprintf(
            "Received a status code of %d when %v was expected. Error message: \"%s\"",
            err.ActualStatusCode,
            err.ExpectedStatusCode,
            *err.ErrorBody.Message,
        )
    } else {
        return fmt.Sprintf(
            "Received a status code of %d when %v was expected. Could not parse the response for additional information.",
            err.ActualStatusCode,
            err.ExpectedStatusCode,
        )
    }
}
type Blob struct {
    ByteOffset int64
    Checksum *string
    ChecksumType *ChecksumType
    Id string
    Length int64
    ObjectId string
}
func (blob *Blob) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "ByteOffset":
            blob.ByteOffset = parseInt64(child.Content, aggErr)
        case "Checksum":
            blob.Checksum = parseNullableString(child.Content)
        case "ChecksumType":
            parseNullableEnum(child.Content, blob.ChecksumType, aggErr)
        case "Id":
            blob.Id = parseString(child.Content)
        case "Length":
            blob.Length = parseInt64(child.Content, aggErr)
        case "ObjectId":
            blob.ObjectId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Blob.", child.XMLName.Local)
        }
    }
}
type BlobStoreTaskInformation struct {
    DateScheduled string
    DateStarted *string
    Description *string
    DriveId *string
    Id int64
    Name *string
    PoolId *string
    Priority Priority
    State BlobStoreTaskState
    TapeId *string
    TargetId *string
    TargetType *string
}
func (blobStoreTaskInformation *BlobStoreTaskInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DateScheduled":
            blobStoreTaskInformation.DateScheduled = parseString(child.Content)
        case "DateStarted":
            blobStoreTaskInformation.DateStarted = parseNullableString(child.Content)
        case "Description":
            blobStoreTaskInformation.Description = parseNullableString(child.Content)
        case "DriveId":
            blobStoreTaskInformation.DriveId = parseNullableString(child.Content)
        case "Id":
            blobStoreTaskInformation.Id = parseInt64(child.Content, aggErr)
        case "Name":
            blobStoreTaskInformation.Name = parseNullableString(child.Content)
        case "PoolId":
            blobStoreTaskInformation.PoolId = parseNullableString(child.Content)
        case "Priority":
            parseEnum(child.Content, &blobStoreTaskInformation.Priority, aggErr)
        case "State":
            parseEnum(child.Content, &blobStoreTaskInformation.State, aggErr)
        case "TapeId":
            blobStoreTaskInformation.TapeId = parseNullableString(child.Content)
        case "TargetId":
            blobStoreTaskInformation.TargetId = parseNullableString(child.Content)
        case "TargetType":
            blobStoreTaskInformation.TargetType = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BlobStoreTaskInformation.", child.XMLName.Local)
        }
    }
}
type BlobStoreTaskState Enum

const (
    BLOB_STORE_TASK_STATE_NOT_READY BlobStoreTaskState = 1 + iota
    BLOB_STORE_TASK_STATE_READY BlobStoreTaskState = 1 + iota
    BLOB_STORE_TASK_STATE_PENDING_EXECUTION BlobStoreTaskState = 1 + iota
    BLOB_STORE_TASK_STATE_IN_PROGRESS BlobStoreTaskState = 1 + iota
    BLOB_STORE_TASK_STATE_COMPLETED BlobStoreTaskState = 1 + iota
)

func (blobStoreTaskState *BlobStoreTaskState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *blobStoreTaskState = UNDEFINED
        case "NOT_READY": *blobStoreTaskState = BLOB_STORE_TASK_STATE_NOT_READY
        case "READY": *blobStoreTaskState = BLOB_STORE_TASK_STATE_READY
        case "PENDING_EXECUTION": *blobStoreTaskState = BLOB_STORE_TASK_STATE_PENDING_EXECUTION
        case "IN_PROGRESS": *blobStoreTaskState = BLOB_STORE_TASK_STATE_IN_PROGRESS
        case "COMPLETED": *blobStoreTaskState = BLOB_STORE_TASK_STATE_COMPLETED
        default:
            *blobStoreTaskState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into BlobStoreTaskState", str))
    }
    return nil
}

func (blobStoreTaskState BlobStoreTaskState) String() string {
    switch blobStoreTaskState {
        case BLOB_STORE_TASK_STATE_NOT_READY: return "NOT_READY"
        case BLOB_STORE_TASK_STATE_READY: return "READY"
        case BLOB_STORE_TASK_STATE_PENDING_EXECUTION: return "PENDING_EXECUTION"
        case BLOB_STORE_TASK_STATE_IN_PROGRESS: return "IN_PROGRESS"
        case BLOB_STORE_TASK_STATE_COMPLETED: return "COMPLETED"
        default:
            log.Printf("Error: invalid BlobStoreTaskState represented by '%d'", blobStoreTaskState)
            return ""
    }
}

func (blobStoreTaskState BlobStoreTaskState) StringPtr() *string {
    if blobStoreTaskState == UNDEFINED {
        return nil
    }
    result := blobStoreTaskState.String()
    return &result
}
type BlobStoreTasksInformation struct {
    Tasks []BlobStoreTaskInformation
}
func (blobStoreTasksInformation *BlobStoreTasksInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Tasks":
            var model BlobStoreTaskInformation
            model.parse(&child, aggErr)
            blobStoreTasksInformation.Tasks = append(blobStoreTasksInformation.Tasks, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BlobStoreTasksInformation.", child.XMLName.Local)
        }
    }
}
type Bucket struct {
    CreationDate string
    DataPolicyId string
    Empty *bool
    Id string
    LastPreferredChunkSizeInBytes *int64
    LogicalUsedCapacity *int64
    Name *string
    UserId string
}
type BucketAcl struct {
    BucketId *string
    GroupId *string
    Id string
    Permission BucketAclPermission
    UserId *string
}
type BucketAclList struct {
    BucketAcls []BucketAcl
}
func (bucketAclList *BucketAclList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketAcl":
            var model BucketAcl
            model.parse(&child, aggErr)
            bucketAclList.BucketAcls = append(bucketAclList.BucketAcls, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BucketAclList.", child.XMLName.Local)
        }
    }
}
func (bucketAcl *BucketAcl) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            bucketAcl.BucketId = parseNullableString(child.Content)
        case "GroupId":
            bucketAcl.GroupId = parseNullableString(child.Content)
        case "Id":
            bucketAcl.Id = parseString(child.Content)
        case "Permission":
            parseEnum(child.Content, &bucketAcl.Permission, aggErr)
        case "UserId":
            bucketAcl.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BucketAcl.", child.XMLName.Local)
        }
    }
}
type BucketAclPermission Enum

const (
    BUCKET_ACL_PERMISSION_LIST BucketAclPermission = 1 + iota
    BUCKET_ACL_PERMISSION_READ BucketAclPermission = 1 + iota
    BUCKET_ACL_PERMISSION_WRITE BucketAclPermission = 1 + iota
    BUCKET_ACL_PERMISSION_DELETE BucketAclPermission = 1 + iota
    BUCKET_ACL_PERMISSION_JOB BucketAclPermission = 1 + iota
    BUCKET_ACL_PERMISSION_OWNER BucketAclPermission = 1 + iota
)

func (bucketAclPermission *BucketAclPermission) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *bucketAclPermission = UNDEFINED
        case "LIST": *bucketAclPermission = BUCKET_ACL_PERMISSION_LIST
        case "READ": *bucketAclPermission = BUCKET_ACL_PERMISSION_READ
        case "WRITE": *bucketAclPermission = BUCKET_ACL_PERMISSION_WRITE
        case "DELETE": *bucketAclPermission = BUCKET_ACL_PERMISSION_DELETE
        case "JOB": *bucketAclPermission = BUCKET_ACL_PERMISSION_JOB
        case "OWNER": *bucketAclPermission = BUCKET_ACL_PERMISSION_OWNER
        default:
            *bucketAclPermission = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into BucketAclPermission", str))
    }
    return nil
}

func (bucketAclPermission BucketAclPermission) String() string {
    switch bucketAclPermission {
        case BUCKET_ACL_PERMISSION_LIST: return "LIST"
        case BUCKET_ACL_PERMISSION_READ: return "READ"
        case BUCKET_ACL_PERMISSION_WRITE: return "WRITE"
        case BUCKET_ACL_PERMISSION_DELETE: return "DELETE"
        case BUCKET_ACL_PERMISSION_JOB: return "JOB"
        case BUCKET_ACL_PERMISSION_OWNER: return "OWNER"
        default:
            log.Printf("Error: invalid BucketAclPermission represented by '%d'", bucketAclPermission)
            return ""
    }
}

func (bucketAclPermission BucketAclPermission) StringPtr() *string {
    if bucketAclPermission == UNDEFINED {
        return nil
    }
    result := bucketAclPermission.String()
    return &result
}
type BucketDetails struct {
    CreationDate *string
    Name *string
}
func (bucketDetails *BucketDetails) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            bucketDetails.CreationDate = parseNullableString(child.Content)
        case "Name":
            bucketDetails.Name = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BucketDetails.", child.XMLName.Local)
        }
    }
}

func parseBucketDetailsSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []BucketDetails {
    var result []BucketDetails
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult BucketDetails
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing BucketDetails struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type BucketList struct {
    Buckets []Bucket
}
func (bucketList *BucketList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Bucket":
            var model Bucket
            model.parse(&child, aggErr)
            bucketList.Buckets = append(bucketList.Buckets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BucketList.", child.XMLName.Local)
        }
    }
}
func (bucket *Bucket) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            bucket.CreationDate = parseString(child.Content)
        case "DataPolicyId":
            bucket.DataPolicyId = parseString(child.Content)
        case "Empty":
            bucket.Empty = parseNullableBool(child.Content, aggErr)
        case "Id":
            bucket.Id = parseString(child.Content)
        case "LastPreferredChunkSizeInBytes":
            bucket.LastPreferredChunkSizeInBytes = parseNullableInt64(child.Content, aggErr)
        case "LogicalUsedCapacity":
            bucket.LogicalUsedCapacity = parseNullableInt64(child.Content, aggErr)
        case "Name":
            bucket.Name = parseNullableString(child.Content)
        case "UserId":
            bucket.UserId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Bucket.", child.XMLName.Local)
        }
    }
}
type BuildInformation struct {
    Branch *string
    Revision *string
    Version *string
}
func (buildInformation *BuildInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Branch":
            buildInformation.Branch = parseNullableString(child.Content)
        case "Revision":
            buildInformation.Revision = parseNullableString(child.Content)
        case "Version":
            buildInformation.Version = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BuildInformation.", child.XMLName.Local)
        }
    }
}
type BulkObject struct {
    Bucket *string
    Id *string
    InCache *bool
    Latest bool
    Length int64
    Name *string
    Offset int64
    PhysicalPlacement *PhysicalPlacement
    Version int64
}
type BulkObjectList struct {
    Objects []BulkObject
}
func (bulkObjectList *BulkObjectList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Object":
            var model BulkObject
            model.parse(&child, aggErr)
            bulkObjectList.Objects = append(bulkObjectList.Objects, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BulkObjectList.", child.XMLName.Local)
        }
    }
}
func (bulkObject *BulkObject) parse(xmlNode *XmlNode, aggErr *AggregateError) {
    // Parse Attributes
    for _, attr := range xmlNode.Attrs {
        switch attr.Name.Local {
        case "Bucket":
            bulkObject.Bucket = parseNullableStringFromString(attr.Value)
        case "Id":
            bulkObject.Id = parseNullableStringFromString(attr.Value)
        case "InCache":
            bulkObject.InCache = parseNullableBoolFromString(attr.Value, aggErr)
        case "Latest":
            bulkObject.Latest = parseBoolFromString(attr.Value, aggErr)
        case "Length":
            bulkObject.Length = parseInt64FromString(attr.Value, aggErr)
        case "Name":
            bulkObject.Name = parseNullableStringFromString(attr.Value)
        case "Offset":
            bulkObject.Offset = parseInt64FromString(attr.Value, aggErr)
        case "Version":
            bulkObject.Version = parseInt64FromString(attr.Value, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown attribute '%s' while parsing BulkObject.", attr.Name.Local)
        }
    }

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "PhysicalPlacement":
            var model PhysicalPlacement
            model.parse(&child, aggErr)
            bulkObject.PhysicalPlacement = &model
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing BulkObject.", child.XMLName.Local)
        }
    }
}
type CacheEntryInformation struct {
    Blob *Blob
    State CacheEntryState
}
func (cacheEntryInformation *CacheEntryInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Blob":
            var model Blob
            model.parse(&child, aggErr)
            cacheEntryInformation.Blob = &model
        case "State":
            parseEnum(child.Content, &cacheEntryInformation.State, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CacheEntryInformation.", child.XMLName.Local)
        }
    }
}
type CacheEntryState Enum

const (
    CACHE_ENTRY_STATE_ALLOCATED CacheEntryState = 1 + iota
    CACHE_ENTRY_STATE_IN_CACHE CacheEntryState = 1 + iota
)

func (cacheEntryState *CacheEntryState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *cacheEntryState = UNDEFINED
        case "ALLOCATED": *cacheEntryState = CACHE_ENTRY_STATE_ALLOCATED
        case "IN_CACHE": *cacheEntryState = CACHE_ENTRY_STATE_IN_CACHE
        default:
            *cacheEntryState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into CacheEntryState", str))
    }
    return nil
}

func (cacheEntryState CacheEntryState) String() string {
    switch cacheEntryState {
        case CACHE_ENTRY_STATE_ALLOCATED: return "ALLOCATED"
        case CACHE_ENTRY_STATE_IN_CACHE: return "IN_CACHE"
        default:
            log.Printf("Error: invalid CacheEntryState represented by '%d'", cacheEntryState)
            return ""
    }
}

func (cacheEntryState CacheEntryState) StringPtr() *string {
    if cacheEntryState == UNDEFINED {
        return nil
    }
    result := cacheEntryState.String()
    return &result
}
type CacheFilesystem struct {
    AutoReclaimInitiateThreshold float64
    AutoReclaimTerminateThreshold float64
    BurstThreshold float64
    Id string
    MaxCapacityInBytes *int64
    MaxPercentUtilizationOfFilesystem *float64
    NodeId string
    Path *string
}
type CacheFilesystemInformation struct {
    AvailableCapacityInBytes int64
    CacheFilesystem CacheFilesystem
    Entries []CacheEntryInformation
    Summary *string
    TotalCapacityInBytes int64
    UnavailableCapacityInBytes int64
    UsedCapacityInBytes int64
}
func (cacheFilesystemInformation *CacheFilesystemInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AvailableCapacityInBytes":
            cacheFilesystemInformation.AvailableCapacityInBytes = parseInt64(child.Content, aggErr)
        case "CacheFilesystem":
            cacheFilesystemInformation.CacheFilesystem.parse(&child, aggErr)
        case "Entries":
            var model CacheEntryInformation
            model.parse(&child, aggErr)
            cacheFilesystemInformation.Entries = append(cacheFilesystemInformation.Entries, model)
        case "Summary":
            cacheFilesystemInformation.Summary = parseNullableString(child.Content)
        case "TotalCapacityInBytes":
            cacheFilesystemInformation.TotalCapacityInBytes = parseInt64(child.Content, aggErr)
        case "UnavailableCapacityInBytes":
            cacheFilesystemInformation.UnavailableCapacityInBytes = parseInt64(child.Content, aggErr)
        case "UsedCapacityInBytes":
            cacheFilesystemInformation.UsedCapacityInBytes = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CacheFilesystemInformation.", child.XMLName.Local)
        }
    }
}
type CacheFilesystemList struct {
    CacheFilesystems []CacheFilesystem
}
func (cacheFilesystemList *CacheFilesystemList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CacheFilesystem":
            var model CacheFilesystem
            model.parse(&child, aggErr)
            cacheFilesystemList.CacheFilesystems = append(cacheFilesystemList.CacheFilesystems, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CacheFilesystemList.", child.XMLName.Local)
        }
    }
}
func (cacheFilesystem *CacheFilesystem) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AutoReclaimInitiateThreshold":
            cacheFilesystem.AutoReclaimInitiateThreshold = parseFloat64(child.Content, aggErr)
        case "AutoReclaimTerminateThreshold":
            cacheFilesystem.AutoReclaimTerminateThreshold = parseFloat64(child.Content, aggErr)
        case "BurstThreshold":
            cacheFilesystem.BurstThreshold = parseFloat64(child.Content, aggErr)
        case "Id":
            cacheFilesystem.Id = parseString(child.Content)
        case "MaxCapacityInBytes":
            cacheFilesystem.MaxCapacityInBytes = parseNullableInt64(child.Content, aggErr)
        case "MaxPercentUtilizationOfFilesystem":
            cacheFilesystem.MaxPercentUtilizationOfFilesystem = parseNullableFloat64(child.Content, aggErr)
        case "NodeId":
            cacheFilesystem.NodeId = parseString(child.Content)
        case "Path":
            cacheFilesystem.Path = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CacheFilesystem.", child.XMLName.Local)
        }
    }
}
type CacheInformation struct {
    Filesystems []CacheFilesystemInformation
}
func (cacheInformation *CacheInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Filesystems":
            var model CacheFilesystemInformation
            model.parse(&child, aggErr)
            cacheInformation.Filesystems = append(cacheInformation.Filesystems, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CacheInformation.", child.XMLName.Local)
        }
    }
}
type CancelActiveJobSpectraS3Request struct {
    ActiveJobId string
}

func NewCancelActiveJobSpectraS3Request(activeJobId string) *CancelActiveJobSpectraS3Request {
    return &CancelActiveJobSpectraS3Request{
        ActiveJobId: activeJobId,
    }
}

type CancelActiveJobSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelActiveJobSpectraS3Response(webResponse WebResponse) (*CancelActiveJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelActiveJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelAllActiveJobsSpectraS3Request struct {
    BucketId *string
    RequestType JobRequestType
}

func NewCancelAllActiveJobsSpectraS3Request() *CancelAllActiveJobsSpectraS3Request {
    return &CancelAllActiveJobsSpectraS3Request{
    }
}

func (cancelAllActiveJobsSpectraS3Request *CancelAllActiveJobsSpectraS3Request) WithBucketId(bucketId string) *CancelAllActiveJobsSpectraS3Request {
    cancelAllActiveJobsSpectraS3Request.BucketId = &bucketId
    return cancelAllActiveJobsSpectraS3Request
}

func (cancelAllActiveJobsSpectraS3Request *CancelAllActiveJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *CancelAllActiveJobsSpectraS3Request {
    cancelAllActiveJobsSpectraS3Request.RequestType = requestType
    return cancelAllActiveJobsSpectraS3Request
}

type CancelAllActiveJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelAllActiveJobsSpectraS3Response(webResponse WebResponse) (*CancelAllActiveJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelAllActiveJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelAllJobsSpectraS3Request struct {
    BucketId *string
    RequestType JobRequestType
}

func NewCancelAllJobsSpectraS3Request() *CancelAllJobsSpectraS3Request {
    return &CancelAllJobsSpectraS3Request{
    }
}

func (cancelAllJobsSpectraS3Request *CancelAllJobsSpectraS3Request) WithBucketId(bucketId string) *CancelAllJobsSpectraS3Request {
    cancelAllJobsSpectraS3Request.BucketId = &bucketId
    return cancelAllJobsSpectraS3Request
}

func (cancelAllJobsSpectraS3Request *CancelAllJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *CancelAllJobsSpectraS3Request {
    cancelAllJobsSpectraS3Request.RequestType = requestType
    return cancelAllJobsSpectraS3Request
}

type CancelAllJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelAllJobsSpectraS3Response(webResponse WebResponse) (*CancelAllJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelAllJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelEjectOnAllTapesSpectraS3Request struct {
}

func NewCancelEjectOnAllTapesSpectraS3Request() *CancelEjectOnAllTapesSpectraS3Request {
    return &CancelEjectOnAllTapesSpectraS3Request{
    }
}

type CancelEjectOnAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (cancelEjectOnAllTapesSpectraS3Response *CancelEjectOnAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, cancelEjectOnAllTapesSpectraS3Response.TapeFailureList)
}

func NewCancelEjectOnAllTapesSpectraS3Response(webResponse WebResponse) (*CancelEjectOnAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelEjectOnAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body CancelEjectOnAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelEjectTapeSpectraS3Request struct {
    TapeId string
}

func NewCancelEjectTapeSpectraS3Request(tapeId string) *CancelEjectTapeSpectraS3Request {
    return &CancelEjectTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type CancelEjectTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (cancelEjectTapeSpectraS3Response *CancelEjectTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelEjectTapeSpectraS3Response.Tape)
}

func NewCancelEjectTapeSpectraS3Response(webResponse WebResponse) (*CancelEjectTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelEjectTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelFormatOnAllTapesSpectraS3Request struct {
}

func NewCancelFormatOnAllTapesSpectraS3Request() *CancelFormatOnAllTapesSpectraS3Request {
    return &CancelFormatOnAllTapesSpectraS3Request{
    }
}

type CancelFormatOnAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (cancelFormatOnAllTapesSpectraS3Response *CancelFormatOnAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, cancelFormatOnAllTapesSpectraS3Response.TapeFailureList)
}

func NewCancelFormatOnAllTapesSpectraS3Response(webResponse WebResponse) (*CancelFormatOnAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelFormatOnAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body CancelFormatOnAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelFormatTapeSpectraS3Request struct {
    TapeId string
}

func NewCancelFormatTapeSpectraS3Request(tapeId string) *CancelFormatTapeSpectraS3Request {
    return &CancelFormatTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type CancelFormatTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (cancelFormatTapeSpectraS3Response *CancelFormatTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelFormatTapeSpectraS3Response.Tape)
}

func NewCancelFormatTapeSpectraS3Response(webResponse WebResponse) (*CancelFormatTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelFormatTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelImportOnAllPoolsSpectraS3Request struct {
}

func NewCancelImportOnAllPoolsSpectraS3Request() *CancelImportOnAllPoolsSpectraS3Request {
    return &CancelImportOnAllPoolsSpectraS3Request{
    }
}

type CancelImportOnAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelImportOnAllPoolsSpectraS3Response(webResponse WebResponse) (*CancelImportOnAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelImportOnAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelImportOnAllTapesSpectraS3Request struct {
}

func NewCancelImportOnAllTapesSpectraS3Request() *CancelImportOnAllTapesSpectraS3Request {
    return &CancelImportOnAllTapesSpectraS3Request{
    }
}

type CancelImportOnAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (cancelImportOnAllTapesSpectraS3Response *CancelImportOnAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, cancelImportOnAllTapesSpectraS3Response.TapeFailureList)
}

func NewCancelImportOnAllTapesSpectraS3Response(webResponse WebResponse) (*CancelImportOnAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelImportOnAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body CancelImportOnAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelImportPoolSpectraS3Request struct {
    Pool string
}

func NewCancelImportPoolSpectraS3Request(pool string) *CancelImportPoolSpectraS3Request {
    return &CancelImportPoolSpectraS3Request{
        Pool: pool,
    }
}

type CancelImportPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (cancelImportPoolSpectraS3Response *CancelImportPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelImportPoolSpectraS3Response.Pool)
}

func NewCancelImportPoolSpectraS3Response(webResponse WebResponse) (*CancelImportPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelImportPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelImportTapeSpectraS3Request struct {
    TapeId string
}

func NewCancelImportTapeSpectraS3Request(tapeId string) *CancelImportTapeSpectraS3Request {
    return &CancelImportTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type CancelImportTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (cancelImportTapeSpectraS3Response *CancelImportTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelImportTapeSpectraS3Response.Tape)
}

func NewCancelImportTapeSpectraS3Response(webResponse WebResponse) (*CancelImportTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelImportTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelJobSpectraS3Request struct {
    JobId string
}

func NewCancelJobSpectraS3Request(jobId string) *CancelJobSpectraS3Request {
    return &CancelJobSpectraS3Request{
        JobId: jobId,
    }
}

type CancelJobSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelJobSpectraS3Response(webResponse WebResponse) (*CancelJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelOnlineOnAllTapesSpectraS3Request struct {
}

func NewCancelOnlineOnAllTapesSpectraS3Request() *CancelOnlineOnAllTapesSpectraS3Request {
    return &CancelOnlineOnAllTapesSpectraS3Request{
    }
}

type CancelOnlineOnAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (cancelOnlineOnAllTapesSpectraS3Response *CancelOnlineOnAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, cancelOnlineOnAllTapesSpectraS3Response.TapeFailureList)
}

func NewCancelOnlineOnAllTapesSpectraS3Response(webResponse WebResponse) (*CancelOnlineOnAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelOnlineOnAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body CancelOnlineOnAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelOnlineTapeSpectraS3Request struct {
    TapeId string
}

func NewCancelOnlineTapeSpectraS3Request(tapeId string) *CancelOnlineTapeSpectraS3Request {
    return &CancelOnlineTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type CancelOnlineTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (cancelOnlineTapeSpectraS3Response *CancelOnlineTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelOnlineTapeSpectraS3Response.Tape)
}

func NewCancelOnlineTapeSpectraS3Response(webResponse WebResponse) (*CancelOnlineTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelOnlineTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelVerifyOnAllPoolsSpectraS3Request struct {
}

func NewCancelVerifyOnAllPoolsSpectraS3Request() *CancelVerifyOnAllPoolsSpectraS3Request {
    return &CancelVerifyOnAllPoolsSpectraS3Request{
    }
}

type CancelVerifyOnAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCancelVerifyOnAllPoolsSpectraS3Response(webResponse WebResponse) (*CancelVerifyOnAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelVerifyOnAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelVerifyOnAllTapesSpectraS3Request struct {
}

func NewCancelVerifyOnAllTapesSpectraS3Request() *CancelVerifyOnAllTapesSpectraS3Request {
    return &CancelVerifyOnAllTapesSpectraS3Request{
    }
}

type CancelVerifyOnAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (cancelVerifyOnAllTapesSpectraS3Response *CancelVerifyOnAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, cancelVerifyOnAllTapesSpectraS3Response.TapeFailureList)
}

func NewCancelVerifyOnAllTapesSpectraS3Response(webResponse WebResponse) (*CancelVerifyOnAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CancelVerifyOnAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body CancelVerifyOnAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelVerifyPoolSpectraS3Request struct {
    Pool string
}

func NewCancelVerifyPoolSpectraS3Request(pool string) *CancelVerifyPoolSpectraS3Request {
    return &CancelVerifyPoolSpectraS3Request{
        Pool: pool,
    }
}

type CancelVerifyPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (cancelVerifyPoolSpectraS3Response *CancelVerifyPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelVerifyPoolSpectraS3Response.Pool)
}

func NewCancelVerifyPoolSpectraS3Response(webResponse WebResponse) (*CancelVerifyPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelVerifyPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CancelVerifyTapeSpectraS3Request struct {
    TapeId string
}

func NewCancelVerifyTapeSpectraS3Request(tapeId string) *CancelVerifyTapeSpectraS3Request {
    return &CancelVerifyTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type CancelVerifyTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (cancelVerifyTapeSpectraS3Response *CancelVerifyTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cancelVerifyTapeSpectraS3Response.Tape)
}

func NewCancelVerifyTapeSpectraS3Response(webResponse WebResponse) (*CancelVerifyTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CancelVerifyTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CanceledJob struct {
    BucketId string
    CachedSizeInBytes int64
    CanceledDueToTimeout bool
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    CompletedSizeInBytes int64
    CreatedAt string
    DateCanceled string
    ErrorMessage *string
    Id string
    Naked bool
    Name *string
    OriginalSizeInBytes int64
    Priority Priority
    Rechunked *string
    RequestType JobRequestType
    Truncated bool
    UserId string
}
type CanceledJobList struct {
    CanceledJobs []CanceledJob
}
func (canceledJobList *CanceledJobList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CanceledJob":
            var model CanceledJob
            model.parse(&child, aggErr)
            canceledJobList.CanceledJobs = append(canceledJobList.CanceledJobs, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CanceledJobList.", child.XMLName.Local)
        }
    }
}
func (canceledJob *CanceledJob) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            canceledJob.BucketId = parseString(child.Content)
        case "CachedSizeInBytes":
            canceledJob.CachedSizeInBytes = parseInt64(child.Content, aggErr)
        case "CanceledDueToTimeout":
            canceledJob.CanceledDueToTimeout = parseBool(child.Content, aggErr)
        case "ChunkClientProcessingOrderGuarantee":
            parseEnum(child.Content, &canceledJob.ChunkClientProcessingOrderGuarantee, aggErr)
        case "CompletedSizeInBytes":
            canceledJob.CompletedSizeInBytes = parseInt64(child.Content, aggErr)
        case "CreatedAt":
            canceledJob.CreatedAt = parseString(child.Content)
        case "DateCanceled":
            canceledJob.DateCanceled = parseString(child.Content)
        case "ErrorMessage":
            canceledJob.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            canceledJob.Id = parseString(child.Content)
        case "Naked":
            canceledJob.Naked = parseBool(child.Content, aggErr)
        case "Name":
            canceledJob.Name = parseNullableString(child.Content)
        case "OriginalSizeInBytes":
            canceledJob.OriginalSizeInBytes = parseInt64(child.Content, aggErr)
        case "Priority":
            parseEnum(child.Content, &canceledJob.Priority, aggErr)
        case "Rechunked":
            canceledJob.Rechunked = parseNullableString(child.Content)
        case "RequestType":
            parseEnum(child.Content, &canceledJob.RequestType, aggErr)
        case "Truncated":
            canceledJob.Truncated = parseBool(child.Content, aggErr)
        case "UserId":
            canceledJob.UserId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CanceledJob.", child.XMLName.Local)
        }
    }
}
type CapacitySummaryContainer struct {
    Pool StorageDomainCapacitySummary
    Tape StorageDomainCapacitySummary
}
func (capacitySummaryContainer *CapacitySummaryContainer) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Pool":
            capacitySummaryContainer.Pool.parse(&child, aggErr)
        case "Tape":
            capacitySummaryContainer.Tape.parse(&child, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CapacitySummaryContainer.", child.XMLName.Local)
        }
    }
}
type Checksum struct {
    ContentHash string
    Type        ChecksumType
}

func NewNoneChecksum() Checksum {
    return Checksum{
        Type: NONE,
        ContentHash: "" }
}
type ChecksumType Enum

const (
    CHECKSUM_TYPE_CRC_32 ChecksumType = 1 + iota
    CHECKSUM_TYPE_CRC_32C ChecksumType = 1 + iota
    CHECKSUM_TYPE_MD5 ChecksumType = 1 + iota
    CHECKSUM_TYPE_SHA_256 ChecksumType = 1 + iota
    CHECKSUM_TYPE_SHA_512 ChecksumType = 1 + iota
    NONE ChecksumType = 1 + iota
)

func (checksumType *ChecksumType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *checksumType = UNDEFINED
        case "CRC_32": *checksumType = CHECKSUM_TYPE_CRC_32
        case "CRC_32C": *checksumType = CHECKSUM_TYPE_CRC_32C
        case "MD5": *checksumType = CHECKSUM_TYPE_MD5
        case "SHA_256": *checksumType = CHECKSUM_TYPE_SHA_256
        case "SHA_512": *checksumType = CHECKSUM_TYPE_SHA_512
        default:
            *checksumType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into ChecksumType", str))
    }
    return nil
}

func (checksumType ChecksumType) String() string {
    switch checksumType {
        case CHECKSUM_TYPE_CRC_32: return "CRC_32"
        case CHECKSUM_TYPE_CRC_32C: return "CRC_32C"
        case CHECKSUM_TYPE_MD5: return "MD5"
        case CHECKSUM_TYPE_SHA_256: return "SHA_256"
        case CHECKSUM_TYPE_SHA_512: return "SHA_512"
        default:
            log.Printf("Error: invalid ChecksumType represented by '%d'", checksumType)
            return ""
    }
}

func (checksumType ChecksumType) StringPtr() *string {
    if checksumType == UNDEFINED {
        return nil
    }
    result := checksumType.String()
    return &result
}
type CleanTapeDriveSpectraS3Request struct {
    TapeDriveId string
}

func NewCleanTapeDriveSpectraS3Request(tapeDriveId string) *CleanTapeDriveSpectraS3Request {
    return &CleanTapeDriveSpectraS3Request{
        TapeDriveId: tapeDriveId,
    }
}

type CleanTapeDriveSpectraS3Response struct {
    TapeDrive TapeDrive
    Headers *http.Header
}

func (cleanTapeDriveSpectraS3Response *CleanTapeDriveSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &cleanTapeDriveSpectraS3Response.TapeDrive)
}

func NewCleanTapeDriveSpectraS3Response(webResponse WebResponse) (*CleanTapeDriveSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CleanTapeDriveSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearAllCanceledJobsSpectraS3Request struct {
}

func NewClearAllCanceledJobsSpectraS3Request() *ClearAllCanceledJobsSpectraS3Request {
    return &ClearAllCanceledJobsSpectraS3Request{
    }
}

type ClearAllCanceledJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearAllCanceledJobsSpectraS3Response(webResponse WebResponse) (*ClearAllCanceledJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearAllCanceledJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearAllCompletedJobsSpectraS3Request struct {
}

func NewClearAllCompletedJobsSpectraS3Request() *ClearAllCompletedJobsSpectraS3Request {
    return &ClearAllCompletedJobsSpectraS3Request{
    }
}

type ClearAllCompletedJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearAllCompletedJobsSpectraS3Response(webResponse WebResponse) (*ClearAllCompletedJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearAllCompletedJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearSuspectBlobAzureTargetsSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewClearSuspectBlobAzureTargetsSpectraS3Request(ids []string) *ClearSuspectBlobAzureTargetsSpectraS3Request {
    return &ClearSuspectBlobAzureTargetsSpectraS3Request{
        Ids: ids,
    }
}

func (clearSuspectBlobAzureTargetsSpectraS3Request *ClearSuspectBlobAzureTargetsSpectraS3Request) WithForce() *ClearSuspectBlobAzureTargetsSpectraS3Request {
    clearSuspectBlobAzureTargetsSpectraS3Request.Force = true
    return clearSuspectBlobAzureTargetsSpectraS3Request
}

type ClearSuspectBlobAzureTargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearSuspectBlobAzureTargetsSpectraS3Response(webResponse WebResponse) (*ClearSuspectBlobAzureTargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearSuspectBlobAzureTargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearSuspectBlobDs3TargetsSpectraS3Request struct {
    Force bool
}

func NewClearSuspectBlobDs3TargetsSpectraS3Request() *ClearSuspectBlobDs3TargetsSpectraS3Request {
    return &ClearSuspectBlobDs3TargetsSpectraS3Request{
    }
}

func (clearSuspectBlobDs3TargetsSpectraS3Request *ClearSuspectBlobDs3TargetsSpectraS3Request) WithForce() *ClearSuspectBlobDs3TargetsSpectraS3Request {
    clearSuspectBlobDs3TargetsSpectraS3Request.Force = true
    return clearSuspectBlobDs3TargetsSpectraS3Request
}

type ClearSuspectBlobDs3TargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearSuspectBlobDs3TargetsSpectraS3Response(webResponse WebResponse) (*ClearSuspectBlobDs3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearSuspectBlobDs3TargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearSuspectBlobPoolsSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewClearSuspectBlobPoolsSpectraS3Request(ids []string) *ClearSuspectBlobPoolsSpectraS3Request {
    return &ClearSuspectBlobPoolsSpectraS3Request{
        Ids: ids,
    }
}

func (clearSuspectBlobPoolsSpectraS3Request *ClearSuspectBlobPoolsSpectraS3Request) WithForce() *ClearSuspectBlobPoolsSpectraS3Request {
    clearSuspectBlobPoolsSpectraS3Request.Force = true
    return clearSuspectBlobPoolsSpectraS3Request
}

type ClearSuspectBlobPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearSuspectBlobPoolsSpectraS3Response(webResponse WebResponse) (*ClearSuspectBlobPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearSuspectBlobPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearSuspectBlobS3TargetsSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewClearSuspectBlobS3TargetsSpectraS3Request(ids []string) *ClearSuspectBlobS3TargetsSpectraS3Request {
    return &ClearSuspectBlobS3TargetsSpectraS3Request{
        Ids: ids,
    }
}

func (clearSuspectBlobS3TargetsSpectraS3Request *ClearSuspectBlobS3TargetsSpectraS3Request) WithForce() *ClearSuspectBlobS3TargetsSpectraS3Request {
    clearSuspectBlobS3TargetsSpectraS3Request.Force = true
    return clearSuspectBlobS3TargetsSpectraS3Request
}

type ClearSuspectBlobS3TargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearSuspectBlobS3TargetsSpectraS3Response(webResponse WebResponse) (*ClearSuspectBlobS3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearSuspectBlobS3TargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ClearSuspectBlobTapesSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewClearSuspectBlobTapesSpectraS3Request(ids []string) *ClearSuspectBlobTapesSpectraS3Request {
    return &ClearSuspectBlobTapesSpectraS3Request{
        Ids: ids,
    }
}

func (clearSuspectBlobTapesSpectraS3Request *ClearSuspectBlobTapesSpectraS3Request) WithForce() *ClearSuspectBlobTapesSpectraS3Request {
    clearSuspectBlobTapesSpectraS3Request.Force = true
    return clearSuspectBlobTapesSpectraS3Request
}

type ClearSuspectBlobTapesSpectraS3Response struct {
    
    Headers *http.Header
}



func NewClearSuspectBlobTapesSpectraS3Response(webResponse WebResponse) (*ClearSuspectBlobTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ClearSuspectBlobTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CloseAggregatingJobSpectraS3Request struct {
    JobId string
}

func NewCloseAggregatingJobSpectraS3Request(jobId string) *CloseAggregatingJobSpectraS3Request {
    return &CloseAggregatingJobSpectraS3Request{
        JobId: jobId,
    }
}

type CloseAggregatingJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (closeAggregatingJobSpectraS3Response *CloseAggregatingJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &closeAggregatingJobSpectraS3Response.MasterObjectList)
}

func NewCloseAggregatingJobSpectraS3Response(webResponse WebResponse) (*CloseAggregatingJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CloseAggregatingJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CompactAllPoolsSpectraS3Request struct {
    Priority Priority
}

func NewCompactAllPoolsSpectraS3Request() *CompactAllPoolsSpectraS3Request {
    return &CompactAllPoolsSpectraS3Request{
    }
}

func (compactAllPoolsSpectraS3Request *CompactAllPoolsSpectraS3Request) WithPriority(priority Priority) *CompactAllPoolsSpectraS3Request {
    compactAllPoolsSpectraS3Request.Priority = priority
    return compactAllPoolsSpectraS3Request
}

type CompactAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewCompactAllPoolsSpectraS3Response(webResponse WebResponse) (*CompactAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &CompactAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CompactPoolSpectraS3Request struct {
    Pool string
    Priority Priority
}

func NewCompactPoolSpectraS3Request(pool string) *CompactPoolSpectraS3Request {
    return &CompactPoolSpectraS3Request{
        Pool: pool,
    }
}

func (compactPoolSpectraS3Request *CompactPoolSpectraS3Request) WithPriority(priority Priority) *CompactPoolSpectraS3Request {
    compactPoolSpectraS3Request.Priority = priority
    return compactPoolSpectraS3Request
}

type CompactPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (compactPoolSpectraS3Response *CompactPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &compactPoolSpectraS3Response.Pool)
}

func NewCompactPoolSpectraS3Response(webResponse WebResponse) (*CompactPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CompactPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CompleteMultiPartUploadRequest struct {
    BucketName string
    ObjectName string
    Parts []Part
    UploadId string
}

func NewCompleteMultiPartUploadRequest(bucketName string, objectName string, parts []Part, uploadId string) *CompleteMultiPartUploadRequest {
    return &CompleteMultiPartUploadRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        UploadId: uploadId,
        Parts: parts,
    }
}

type CompleteMultiPartUploadResponse struct {
    CompleteMultipartUploadResult CompleteMultipartUploadResult
    Headers *http.Header
}

func (completeMultiPartUploadResponse *CompleteMultiPartUploadResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &completeMultiPartUploadResponse.CompleteMultipartUploadResult)
}

func NewCompleteMultiPartUploadResponse(webResponse WebResponse) (*CompleteMultiPartUploadResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body CompleteMultiPartUploadResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CompleteMultipartUploadResult struct {
    Bucket *string
    ETag *string
    Key *string
    Location *string
}
func (completeMultipartUploadResult *CompleteMultipartUploadResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Bucket":
            completeMultipartUploadResult.Bucket = parseNullableString(child.Content)
        case "ETag":
            completeMultipartUploadResult.ETag = parseNullableString(child.Content)
        case "Key":
            completeMultipartUploadResult.Key = parseNullableString(child.Content)
        case "Location":
            completeMultipartUploadResult.Location = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CompleteMultipartUploadResult.", child.XMLName.Local)
        }
    }
}
type CompletedJob struct {
    BucketId string
    CachedSizeInBytes int64
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    CompletedSizeInBytes int64
    CreatedAt string
    DateCompleted string
    ErrorMessage *string
    Id string
    Naked bool
    Name *string
    OriginalSizeInBytes int64
    Priority Priority
    Rechunked *string
    RequestType JobRequestType
    Truncated bool
    UserId string
}
type CompletedJobList struct {
    CompletedJobs []CompletedJob
}
func (completedJobList *CompletedJobList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CompletedJob":
            var model CompletedJob
            model.parse(&child, aggErr)
            completedJobList.CompletedJobs = append(completedJobList.CompletedJobs, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CompletedJobList.", child.XMLName.Local)
        }
    }
}
func (completedJob *CompletedJob) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            completedJob.BucketId = parseString(child.Content)
        case "CachedSizeInBytes":
            completedJob.CachedSizeInBytes = parseInt64(child.Content, aggErr)
        case "ChunkClientProcessingOrderGuarantee":
            parseEnum(child.Content, &completedJob.ChunkClientProcessingOrderGuarantee, aggErr)
        case "CompletedSizeInBytes":
            completedJob.CompletedSizeInBytes = parseInt64(child.Content, aggErr)
        case "CreatedAt":
            completedJob.CreatedAt = parseString(child.Content)
        case "DateCompleted":
            completedJob.DateCompleted = parseString(child.Content)
        case "ErrorMessage":
            completedJob.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            completedJob.Id = parseString(child.Content)
        case "Naked":
            completedJob.Naked = parseBool(child.Content, aggErr)
        case "Name":
            completedJob.Name = parseNullableString(child.Content)
        case "OriginalSizeInBytes":
            completedJob.OriginalSizeInBytes = parseInt64(child.Content, aggErr)
        case "Priority":
            parseEnum(child.Content, &completedJob.Priority, aggErr)
        case "Rechunked":
            completedJob.Rechunked = parseNullableString(child.Content)
        case "RequestType":
            parseEnum(child.Content, &completedJob.RequestType, aggErr)
        case "Truncated":
            completedJob.Truncated = parseBool(child.Content, aggErr)
        case "UserId":
            completedJob.UserId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing CompletedJob.", child.XMLName.Local)
        }
    }
}
type Contents struct {
    ETag *string
    Key *string
    LastModified *string
    Owner User
    Size int64
    StorageClass *string
}
func (contents *Contents) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "ETag":
            contents.ETag = parseNullableString(child.Content)
        case "Key":
            contents.Key = parseNullableString(child.Content)
        case "LastModified":
            contents.LastModified = parseNullableString(child.Content)
        case "Owner":
            contents.Owner.parse(&child, aggErr)
        case "Size":
            contents.Size = parseInt64(child.Content, aggErr)
        case "StorageClass":
            contents.StorageClass = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Contents.", child.XMLName.Local)
        }
    }
}
type ConvertStorageDomainToDs3TargetSpectraS3Request struct {
    ConvertToDs3Target string
    StorageDomain string
}

func NewConvertStorageDomainToDs3TargetSpectraS3Request(convertToDs3Target string, storageDomain string) *ConvertStorageDomainToDs3TargetSpectraS3Request {
    return &ConvertStorageDomainToDs3TargetSpectraS3Request{
        StorageDomain: storageDomain,
        ConvertToDs3Target: convertToDs3Target,
    }
}

type ConvertStorageDomainToDs3TargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewConvertStorageDomainToDs3TargetSpectraS3Response(webResponse WebResponse) (*ConvertStorageDomainToDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ConvertStorageDomainToDs3TargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DataIsolationLevel Enum

const (
    DATA_ISOLATION_LEVEL_STANDARD DataIsolationLevel = 1 + iota
    DATA_ISOLATION_LEVEL_BUCKET_ISOLATED DataIsolationLevel = 1 + iota
)

func (dataIsolationLevel *DataIsolationLevel) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *dataIsolationLevel = UNDEFINED
        case "STANDARD": *dataIsolationLevel = DATA_ISOLATION_LEVEL_STANDARD
        case "BUCKET_ISOLATED": *dataIsolationLevel = DATA_ISOLATION_LEVEL_BUCKET_ISOLATED
        default:
            *dataIsolationLevel = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into DataIsolationLevel", str))
    }
    return nil
}

func (dataIsolationLevel DataIsolationLevel) String() string {
    switch dataIsolationLevel {
        case DATA_ISOLATION_LEVEL_STANDARD: return "STANDARD"
        case DATA_ISOLATION_LEVEL_BUCKET_ISOLATED: return "BUCKET_ISOLATED"
        default:
            log.Printf("Error: invalid DataIsolationLevel represented by '%d'", dataIsolationLevel)
            return ""
    }
}

func (dataIsolationLevel DataIsolationLevel) StringPtr() *string {
    if dataIsolationLevel == UNDEFINED {
        return nil
    }
    result := dataIsolationLevel.String()
    return &result
}
type DataPathBackend struct {
    Activated bool
    AutoActivateTimeoutInMins *int
    AutoInspect AutoInspectMode
    DefaultImportConflictResolutionMode ImportConflictResolutionMode
    DefaultVerifyDataAfterImport *Priority
    DefaultVerifyDataPriorToImport bool
    Id string
    InstanceId string
    LastHeartbeat string
    PartiallyVerifyLastPercentOfTapes *int
    UnavailableMediaPolicy UnavailableMediaUsagePolicy
    UnavailablePoolMaxJobRetryInMins int
    UnavailableTapePartitionMaxJobRetryInMins int
}
func (dataPathBackend *DataPathBackend) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Activated":
            dataPathBackend.Activated = parseBool(child.Content, aggErr)
        case "AutoActivateTimeoutInMins":
            dataPathBackend.AutoActivateTimeoutInMins = parseNullableInt(child.Content, aggErr)
        case "AutoInspect":
            parseEnum(child.Content, &dataPathBackend.AutoInspect, aggErr)
        case "DefaultImportConflictResolutionMode":
            parseEnum(child.Content, &dataPathBackend.DefaultImportConflictResolutionMode, aggErr)
        case "DefaultVerifyDataAfterImport":
            parseNullableEnum(child.Content, dataPathBackend.DefaultVerifyDataAfterImport, aggErr)
        case "DefaultVerifyDataPriorToImport":
            dataPathBackend.DefaultVerifyDataPriorToImport = parseBool(child.Content, aggErr)
        case "Id":
            dataPathBackend.Id = parseString(child.Content)
        case "InstanceId":
            dataPathBackend.InstanceId = parseString(child.Content)
        case "LastHeartbeat":
            dataPathBackend.LastHeartbeat = parseString(child.Content)
        case "PartiallyVerifyLastPercentOfTapes":
            dataPathBackend.PartiallyVerifyLastPercentOfTapes = parseNullableInt(child.Content, aggErr)
        case "UnavailableMediaPolicy":
            parseEnum(child.Content, &dataPathBackend.UnavailableMediaPolicy, aggErr)
        case "UnavailablePoolMaxJobRetryInMins":
            dataPathBackend.UnavailablePoolMaxJobRetryInMins = parseInt(child.Content, aggErr)
        case "UnavailableTapePartitionMaxJobRetryInMins":
            dataPathBackend.UnavailableTapePartitionMaxJobRetryInMins = parseInt(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPathBackend.", child.XMLName.Local)
        }
    }
}
type DataPersistenceRule struct {
    DataPolicyId string
    Id string
    IsolationLevel DataIsolationLevel
    MinimumDaysToRetain *int
    State DataPlacementRuleState
    StorageDomainId string
    Type DataPersistenceRuleType
}
type DataPersistenceRuleList struct {
    DataPersistenceRules []DataPersistenceRule
}
func (dataPersistenceRuleList *DataPersistenceRuleList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPersistenceRule":
            var model DataPersistenceRule
            model.parse(&child, aggErr)
            dataPersistenceRuleList.DataPersistenceRules = append(dataPersistenceRuleList.DataPersistenceRules, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPersistenceRuleList.", child.XMLName.Local)
        }
    }
}
func (dataPersistenceRule *DataPersistenceRule) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyId":
            dataPersistenceRule.DataPolicyId = parseString(child.Content)
        case "Id":
            dataPersistenceRule.Id = parseString(child.Content)
        case "IsolationLevel":
            parseEnum(child.Content, &dataPersistenceRule.IsolationLevel, aggErr)
        case "MinimumDaysToRetain":
            dataPersistenceRule.MinimumDaysToRetain = parseNullableInt(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &dataPersistenceRule.State, aggErr)
        case "StorageDomainId":
            dataPersistenceRule.StorageDomainId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &dataPersistenceRule.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPersistenceRule.", child.XMLName.Local)
        }
    }
}
type DataPersistenceRuleType Enum

const (
    DATA_PERSISTENCE_RULE_TYPE_PERMANENT DataPersistenceRuleType = 1 + iota
    DATA_PERSISTENCE_RULE_TYPE_TEMPORARY DataPersistenceRuleType = 1 + iota
    DATA_PERSISTENCE_RULE_TYPE_RETIRED DataPersistenceRuleType = 1 + iota
)

func (dataPersistenceRuleType *DataPersistenceRuleType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *dataPersistenceRuleType = UNDEFINED
        case "PERMANENT": *dataPersistenceRuleType = DATA_PERSISTENCE_RULE_TYPE_PERMANENT
        case "TEMPORARY": *dataPersistenceRuleType = DATA_PERSISTENCE_RULE_TYPE_TEMPORARY
        case "RETIRED": *dataPersistenceRuleType = DATA_PERSISTENCE_RULE_TYPE_RETIRED
        default:
            *dataPersistenceRuleType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into DataPersistenceRuleType", str))
    }
    return nil
}

func (dataPersistenceRuleType DataPersistenceRuleType) String() string {
    switch dataPersistenceRuleType {
        case DATA_PERSISTENCE_RULE_TYPE_PERMANENT: return "PERMANENT"
        case DATA_PERSISTENCE_RULE_TYPE_TEMPORARY: return "TEMPORARY"
        case DATA_PERSISTENCE_RULE_TYPE_RETIRED: return "RETIRED"
        default:
            log.Printf("Error: invalid DataPersistenceRuleType represented by '%d'", dataPersistenceRuleType)
            return ""
    }
}

func (dataPersistenceRuleType DataPersistenceRuleType) StringPtr() *string {
    if dataPersistenceRuleType == UNDEFINED {
        return nil
    }
    result := dataPersistenceRuleType.String()
    return &result
}
type DataPlacementRuleState Enum

const (
    DATA_PLACEMENT_RULE_STATE_NORMAL DataPlacementRuleState = 1 + iota
    DATA_PLACEMENT_RULE_STATE_INCLUSION_IN_PROGRESS DataPlacementRuleState = 1 + iota
)

func (dataPlacementRuleState *DataPlacementRuleState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *dataPlacementRuleState = UNDEFINED
        case "NORMAL": *dataPlacementRuleState = DATA_PLACEMENT_RULE_STATE_NORMAL
        case "INCLUSION_IN_PROGRESS": *dataPlacementRuleState = DATA_PLACEMENT_RULE_STATE_INCLUSION_IN_PROGRESS
        default:
            *dataPlacementRuleState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into DataPlacementRuleState", str))
    }
    return nil
}

func (dataPlacementRuleState DataPlacementRuleState) String() string {
    switch dataPlacementRuleState {
        case DATA_PLACEMENT_RULE_STATE_NORMAL: return "NORMAL"
        case DATA_PLACEMENT_RULE_STATE_INCLUSION_IN_PROGRESS: return "INCLUSION_IN_PROGRESS"
        default:
            log.Printf("Error: invalid DataPlacementRuleState represented by '%d'", dataPlacementRuleState)
            return ""
    }
}

func (dataPlacementRuleState DataPlacementRuleState) StringPtr() *string {
    if dataPlacementRuleState == UNDEFINED {
        return nil
    }
    result := dataPlacementRuleState.String()
    return &result
}
type DataPolicy struct {
    AlwaysForcePutJobCreation bool
    AlwaysMinimizeSpanningAcrossMedia bool
    AlwaysReplicateDeletes bool
    BlobbingEnabled bool
    ChecksumType ChecksumType
    CreationDate string
    DefaultBlobSize *int64
    DefaultGetJobPriority Priority
    DefaultPutJobPriority Priority
    DefaultVerifyAfterWrite bool
    DefaultVerifyJobPriority Priority
    EndToEndCrcRequired bool
    Id string
    LtfsObjectNamingAllowed bool
    Name *string
    RebuildPriority Priority
    Versioning VersioningLevel
}
type DataPolicyAcl struct {
    DataPolicyId *string
    GroupId *string
    Id string
    UserId *string
}
type DataPolicyAclList struct {
    DataPolicyAcls []DataPolicyAcl
}
func (dataPolicyAclList *DataPolicyAclList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyAcl":
            var model DataPolicyAcl
            model.parse(&child, aggErr)
            dataPolicyAclList.DataPolicyAcls = append(dataPolicyAclList.DataPolicyAcls, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPolicyAclList.", child.XMLName.Local)
        }
    }
}
func (dataPolicyAcl *DataPolicyAcl) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyId":
            dataPolicyAcl.DataPolicyId = parseNullableString(child.Content)
        case "GroupId":
            dataPolicyAcl.GroupId = parseNullableString(child.Content)
        case "Id":
            dataPolicyAcl.Id = parseString(child.Content)
        case "UserId":
            dataPolicyAcl.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPolicyAcl.", child.XMLName.Local)
        }
    }
}
type DataPolicyList struct {
    DataPolicies []DataPolicy
}
func (dataPolicyList *DataPolicyList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicy":
            var model DataPolicy
            model.parse(&child, aggErr)
            dataPolicyList.DataPolicies = append(dataPolicyList.DataPolicies, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPolicyList.", child.XMLName.Local)
        }
    }
}
func (dataPolicy *DataPolicy) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AlwaysForcePutJobCreation":
            dataPolicy.AlwaysForcePutJobCreation = parseBool(child.Content, aggErr)
        case "AlwaysMinimizeSpanningAcrossMedia":
            dataPolicy.AlwaysMinimizeSpanningAcrossMedia = parseBool(child.Content, aggErr)
        case "AlwaysReplicateDeletes":
            dataPolicy.AlwaysReplicateDeletes = parseBool(child.Content, aggErr)
        case "BlobbingEnabled":
            dataPolicy.BlobbingEnabled = parseBool(child.Content, aggErr)
        case "ChecksumType":
            parseEnum(child.Content, &dataPolicy.ChecksumType, aggErr)
        case "CreationDate":
            dataPolicy.CreationDate = parseString(child.Content)
        case "DefaultBlobSize":
            dataPolicy.DefaultBlobSize = parseNullableInt64(child.Content, aggErr)
        case "DefaultGetJobPriority":
            parseEnum(child.Content, &dataPolicy.DefaultGetJobPriority, aggErr)
        case "DefaultPutJobPriority":
            parseEnum(child.Content, &dataPolicy.DefaultPutJobPriority, aggErr)
        case "DefaultVerifyAfterWrite":
            dataPolicy.DefaultVerifyAfterWrite = parseBool(child.Content, aggErr)
        case "DefaultVerifyJobPriority":
            parseEnum(child.Content, &dataPolicy.DefaultVerifyJobPriority, aggErr)
        case "EndToEndCrcRequired":
            dataPolicy.EndToEndCrcRequired = parseBool(child.Content, aggErr)
        case "Id":
            dataPolicy.Id = parseString(child.Content)
        case "LtfsObjectNamingAllowed":
            dataPolicy.LtfsObjectNamingAllowed = parseBool(child.Content, aggErr)
        case "Name":
            dataPolicy.Name = parseNullableString(child.Content)
        case "RebuildPriority":
            parseEnum(child.Content, &dataPolicy.RebuildPriority, aggErr)
        case "Versioning":
            parseEnum(child.Content, &dataPolicy.Versioning, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DataPolicy.", child.XMLName.Local)
        }
    }
}
type DataReplicationRuleType Enum

const (
    DATA_REPLICATION_RULE_TYPE_PERMANENT DataReplicationRuleType = 1 + iota
    DATA_REPLICATION_RULE_TYPE_RETIRED DataReplicationRuleType = 1 + iota
)

func (dataReplicationRuleType *DataReplicationRuleType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *dataReplicationRuleType = UNDEFINED
        case "PERMANENT": *dataReplicationRuleType = DATA_REPLICATION_RULE_TYPE_PERMANENT
        case "RETIRED": *dataReplicationRuleType = DATA_REPLICATION_RULE_TYPE_RETIRED
        default:
            *dataReplicationRuleType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into DataReplicationRuleType", str))
    }
    return nil
}

func (dataReplicationRuleType DataReplicationRuleType) String() string {
    switch dataReplicationRuleType {
        case DATA_REPLICATION_RULE_TYPE_PERMANENT: return "PERMANENT"
        case DATA_REPLICATION_RULE_TYPE_RETIRED: return "RETIRED"
        default:
            log.Printf("Error: invalid DataReplicationRuleType represented by '%d'", dataReplicationRuleType)
            return ""
    }
}

func (dataReplicationRuleType DataReplicationRuleType) StringPtr() *string {
    if dataReplicationRuleType == UNDEFINED {
        return nil
    }
    result := dataReplicationRuleType.String()
    return &result
}
type DatabasePhysicalSpaceState Enum

const (
    DATABASE_PHYSICAL_SPACE_STATE_CRITICAL DatabasePhysicalSpaceState = 1 + iota
    DATABASE_PHYSICAL_SPACE_STATE_LOW DatabasePhysicalSpaceState = 1 + iota
    DATABASE_PHYSICAL_SPACE_STATE_NEAR_LOW DatabasePhysicalSpaceState = 1 + iota
    DATABASE_PHYSICAL_SPACE_STATE_NORMAL DatabasePhysicalSpaceState = 1 + iota
)

func (databasePhysicalSpaceState *DatabasePhysicalSpaceState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *databasePhysicalSpaceState = UNDEFINED
        case "CRITICAL": *databasePhysicalSpaceState = DATABASE_PHYSICAL_SPACE_STATE_CRITICAL
        case "LOW": *databasePhysicalSpaceState = DATABASE_PHYSICAL_SPACE_STATE_LOW
        case "NEAR_LOW": *databasePhysicalSpaceState = DATABASE_PHYSICAL_SPACE_STATE_NEAR_LOW
        case "NORMAL": *databasePhysicalSpaceState = DATABASE_PHYSICAL_SPACE_STATE_NORMAL
        default:
            *databasePhysicalSpaceState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into DatabasePhysicalSpaceState", str))
    }
    return nil
}

func (databasePhysicalSpaceState DatabasePhysicalSpaceState) String() string {
    switch databasePhysicalSpaceState {
        case DATABASE_PHYSICAL_SPACE_STATE_CRITICAL: return "CRITICAL"
        case DATABASE_PHYSICAL_SPACE_STATE_LOW: return "LOW"
        case DATABASE_PHYSICAL_SPACE_STATE_NEAR_LOW: return "NEAR_LOW"
        case DATABASE_PHYSICAL_SPACE_STATE_NORMAL: return "NORMAL"
        default:
            log.Printf("Error: invalid DatabasePhysicalSpaceState represented by '%d'", databasePhysicalSpaceState)
            return ""
    }
}

func (databasePhysicalSpaceState DatabasePhysicalSpaceState) StringPtr() *string {
    if databasePhysicalSpaceState == UNDEFINED {
        return nil
    }
    result := databasePhysicalSpaceState.String()
    return &result
}
type DeallocatePoolSpectraS3Request struct {
    Pool string
}

func NewDeallocatePoolSpectraS3Request(pool string) *DeallocatePoolSpectraS3Request {
    return &DeallocatePoolSpectraS3Request{
        Pool: pool,
    }
}

type DeallocatePoolSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeallocatePoolSpectraS3Response(webResponse WebResponse) (*DeallocatePoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeallocatePoolSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DegradedBlob struct {
    AzureReplicationRuleId *string
    BlobId string
    BucketId string
    Ds3ReplicationRuleId *string
    Id string
    PersistenceRuleId *string
    S3ReplicationRuleId *string
}
type DegradedBlobList struct {
    DegradedBlobs []DegradedBlob
}
func (degradedBlobList *DegradedBlobList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DegradedBlob":
            var model DegradedBlob
            model.parse(&child, aggErr)
            degradedBlobList.DegradedBlobs = append(degradedBlobList.DegradedBlobs, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DegradedBlobList.", child.XMLName.Local)
        }
    }
}
func (degradedBlob *DegradedBlob) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureReplicationRuleId":
            degradedBlob.AzureReplicationRuleId = parseNullableString(child.Content)
        case "BlobId":
            degradedBlob.BlobId = parseString(child.Content)
        case "BucketId":
            degradedBlob.BucketId = parseString(child.Content)
        case "Ds3ReplicationRuleId":
            degradedBlob.Ds3ReplicationRuleId = parseNullableString(child.Content)
        case "Id":
            degradedBlob.Id = parseString(child.Content)
        case "PersistenceRuleId":
            degradedBlob.PersistenceRuleId = parseNullableString(child.Content)
        case "S3ReplicationRuleId":
            degradedBlob.S3ReplicationRuleId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DegradedBlob.", child.XMLName.Local)
        }
    }
}
type DelegateCreateUserSpectraS3Request struct {
    Id *string
    Name string
    SecretKey *string
}

func NewDelegateCreateUserSpectraS3Request(name string) *DelegateCreateUserSpectraS3Request {
    return &DelegateCreateUserSpectraS3Request{
        Name: name,
    }
}

func (delegateCreateUserSpectraS3Request *DelegateCreateUserSpectraS3Request) WithId(id string) *DelegateCreateUserSpectraS3Request {
    delegateCreateUserSpectraS3Request.Id = &id
    return delegateCreateUserSpectraS3Request
}

func (delegateCreateUserSpectraS3Request *DelegateCreateUserSpectraS3Request) WithSecretKey(secretKey string) *DelegateCreateUserSpectraS3Request {
    delegateCreateUserSpectraS3Request.SecretKey = &secretKey
    return delegateCreateUserSpectraS3Request
}

type DelegateCreateUserSpectraS3Response struct {
    SpectraUser SpectraUser
    Headers *http.Header
}

func (delegateCreateUserSpectraS3Response *DelegateCreateUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &delegateCreateUserSpectraS3Response.SpectraUser)
}

func NewDelegateCreateUserSpectraS3Response(webResponse WebResponse) (*DelegateCreateUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body DelegateCreateUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DelegateDeleteUserSpectraS3Request struct {
    UserId string
}

func NewDelegateDeleteUserSpectraS3Request(userId string) *DelegateDeleteUserSpectraS3Request {
    return &DelegateDeleteUserSpectraS3Request{
        UserId: userId,
    }
}

type DelegateDeleteUserSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDelegateDeleteUserSpectraS3Response(webResponse WebResponse) (*DelegateDeleteUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DelegateDeleteUserSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureDataReplicationRuleSpectraS3Request struct {
    AzureDataReplicationRule string
}

func NewDeleteAzureDataReplicationRuleSpectraS3Request(azureDataReplicationRule string) *DeleteAzureDataReplicationRuleSpectraS3Request {
    return &DeleteAzureDataReplicationRuleSpectraS3Request{
        AzureDataReplicationRule: azureDataReplicationRule,
    }
}

type DeleteAzureDataReplicationRuleSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureDataReplicationRuleSpectraS3Response(webResponse WebResponse) (*DeleteAzureDataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureDataReplicationRuleSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureTargetBucketNameSpectraS3Request struct {
    AzureTargetBucketName string
}

func NewDeleteAzureTargetBucketNameSpectraS3Request(azureTargetBucketName string) *DeleteAzureTargetBucketNameSpectraS3Request {
    return &DeleteAzureTargetBucketNameSpectraS3Request{
        AzureTargetBucketName: azureTargetBucketName,
    }
}

type DeleteAzureTargetBucketNameSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureTargetBucketNameSpectraS3Response(webResponse WebResponse) (*DeleteAzureTargetBucketNameSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureTargetBucketNameSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureTargetFailureNotificationRegistrationSpectraS3Request struct {
    AzureTargetFailureNotificationRegistration string
}

func NewDeleteAzureTargetFailureNotificationRegistrationSpectraS3Request(azureTargetFailureNotificationRegistration string) *DeleteAzureTargetFailureNotificationRegistrationSpectraS3Request {
    return &DeleteAzureTargetFailureNotificationRegistrationSpectraS3Request{
        AzureTargetFailureNotificationRegistration: azureTargetFailureNotificationRegistration,
    }
}

type DeleteAzureTargetFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureTargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteAzureTargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureTargetFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureTargetFailureSpectraS3Request struct {
    AzureTargetFailure string
}

func NewDeleteAzureTargetFailureSpectraS3Request(azureTargetFailure string) *DeleteAzureTargetFailureSpectraS3Request {
    return &DeleteAzureTargetFailureSpectraS3Request{
        AzureTargetFailure: azureTargetFailure,
    }
}

type DeleteAzureTargetFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureTargetFailureSpectraS3Response(webResponse WebResponse) (*DeleteAzureTargetFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureTargetFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureTargetReadPreferenceSpectraS3Request struct {
    AzureTargetReadPreference string
}

func NewDeleteAzureTargetReadPreferenceSpectraS3Request(azureTargetReadPreference string) *DeleteAzureTargetReadPreferenceSpectraS3Request {
    return &DeleteAzureTargetReadPreferenceSpectraS3Request{
        AzureTargetReadPreference: azureTargetReadPreference,
    }
}

type DeleteAzureTargetReadPreferenceSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureTargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*DeleteAzureTargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureTargetReadPreferenceSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteAzureTargetSpectraS3Request struct {
    AzureTarget string
}

func NewDeleteAzureTargetSpectraS3Request(azureTarget string) *DeleteAzureTargetSpectraS3Request {
    return &DeleteAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
    }
}

type DeleteAzureTargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteAzureTargetSpectraS3Response(webResponse WebResponse) (*DeleteAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteAzureTargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteBucketAclSpectraS3Request struct {
    BucketAcl string
}

func NewDeleteBucketAclSpectraS3Request(bucketAcl string) *DeleteBucketAclSpectraS3Request {
    return &DeleteBucketAclSpectraS3Request{
        BucketAcl: bucketAcl,
    }
}

type DeleteBucketAclSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteBucketAclSpectraS3Response(webResponse WebResponse) (*DeleteBucketAclSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteBucketAclSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteBucketRequest struct {
    BucketName string
}

func NewDeleteBucketRequest(bucketName string) *DeleteBucketRequest {
    return &DeleteBucketRequest{
        BucketName: bucketName,
    }
}

type DeleteBucketResponse struct {
    
    Headers *http.Header
}



func NewDeleteBucketResponse(webResponse WebResponse) (*DeleteBucketResponse, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteBucketResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteBucketSpectraS3Request struct {
    BucketName string
    Force bool
}

func NewDeleteBucketSpectraS3Request(bucketName string) *DeleteBucketSpectraS3Request {
    return &DeleteBucketSpectraS3Request{
        BucketName: bucketName,
    }
}

func (deleteBucketSpectraS3Request *DeleteBucketSpectraS3Request) WithForce() *DeleteBucketSpectraS3Request {
    deleteBucketSpectraS3Request.Force = true
    return deleteBucketSpectraS3Request
}

type DeleteBucketSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteBucketSpectraS3Response(webResponse WebResponse) (*DeleteBucketSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteBucketSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDataPersistenceRuleSpectraS3Request struct {
    DataPersistenceRuleId string
}

func NewDeleteDataPersistenceRuleSpectraS3Request(dataPersistenceRuleId string) *DeleteDataPersistenceRuleSpectraS3Request {
    return &DeleteDataPersistenceRuleSpectraS3Request{
        DataPersistenceRuleId: dataPersistenceRuleId,
    }
}

type DeleteDataPersistenceRuleSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDataPersistenceRuleSpectraS3Response(webResponse WebResponse) (*DeleteDataPersistenceRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDataPersistenceRuleSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDataPolicyAclSpectraS3Request struct {
    DataPolicyAcl string
}

func NewDeleteDataPolicyAclSpectraS3Request(dataPolicyAcl string) *DeleteDataPolicyAclSpectraS3Request {
    return &DeleteDataPolicyAclSpectraS3Request{
        DataPolicyAcl: dataPolicyAcl,
    }
}

type DeleteDataPolicyAclSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDataPolicyAclSpectraS3Response(webResponse WebResponse) (*DeleteDataPolicyAclSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDataPolicyAclSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDataPolicySpectraS3Request struct {
    DataPolicyId string
}

func NewDeleteDataPolicySpectraS3Request(dataPolicyId string) *DeleteDataPolicySpectraS3Request {
    return &DeleteDataPolicySpectraS3Request{
        DataPolicyId: dataPolicyId,
    }
}

type DeleteDataPolicySpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDataPolicySpectraS3Response(webResponse WebResponse) (*DeleteDataPolicySpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDataPolicySpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDs3DataReplicationRuleSpectraS3Request struct {
    Ds3DataReplicationRule string
}

func NewDeleteDs3DataReplicationRuleSpectraS3Request(ds3DataReplicationRule string) *DeleteDs3DataReplicationRuleSpectraS3Request {
    return &DeleteDs3DataReplicationRuleSpectraS3Request{
        Ds3DataReplicationRule: ds3DataReplicationRule,
    }
}

type DeleteDs3DataReplicationRuleSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDs3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*DeleteDs3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDs3DataReplicationRuleSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDs3TargetFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteDs3TargetFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeleteDs3TargetFailureNotificationRegistrationSpectraS3Request {
    return &DeleteDs3TargetFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteDs3TargetFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDs3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteDs3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDs3TargetFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDs3TargetFailureSpectraS3Request struct {
    Ds3TargetFailure string
}

func NewDeleteDs3TargetFailureSpectraS3Request(ds3TargetFailure string) *DeleteDs3TargetFailureSpectraS3Request {
    return &DeleteDs3TargetFailureSpectraS3Request{
        Ds3TargetFailure: ds3TargetFailure,
    }
}

type DeleteDs3TargetFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDs3TargetFailureSpectraS3Response(webResponse WebResponse) (*DeleteDs3TargetFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDs3TargetFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDs3TargetReadPreferenceSpectraS3Request struct {
    Ds3TargetReadPreference string
}

func NewDeleteDs3TargetReadPreferenceSpectraS3Request(ds3TargetReadPreference string) *DeleteDs3TargetReadPreferenceSpectraS3Request {
    return &DeleteDs3TargetReadPreferenceSpectraS3Request{
        Ds3TargetReadPreference: ds3TargetReadPreference,
    }
}

type DeleteDs3TargetReadPreferenceSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDs3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*DeleteDs3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDs3TargetReadPreferenceSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteDs3TargetSpectraS3Request struct {
    Ds3Target string
}

func NewDeleteDs3TargetSpectraS3Request(ds3Target string) *DeleteDs3TargetSpectraS3Request {
    return &DeleteDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

type DeleteDs3TargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteDs3TargetSpectraS3Response(webResponse WebResponse) (*DeleteDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteDs3TargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteFolderRecursivelySpectraS3Request struct {
    BucketId string
    Folder string
    RollBack bool
}

func NewDeleteFolderRecursivelySpectraS3Request(bucketId string, folder string) *DeleteFolderRecursivelySpectraS3Request {
    return &DeleteFolderRecursivelySpectraS3Request{
        Folder: folder,
        BucketId: bucketId,
    }
}

func (deleteFolderRecursivelySpectraS3Request *DeleteFolderRecursivelySpectraS3Request) WithRollBack() *DeleteFolderRecursivelySpectraS3Request {
    deleteFolderRecursivelySpectraS3Request.RollBack = true
    return deleteFolderRecursivelySpectraS3Request
}

type DeleteFolderRecursivelySpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteFolderRecursivelySpectraS3Response(webResponse WebResponse) (*DeleteFolderRecursivelySpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteFolderRecursivelySpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteGroupMemberSpectraS3Request struct {
    GroupMember string
}

func NewDeleteGroupMemberSpectraS3Request(groupMember string) *DeleteGroupMemberSpectraS3Request {
    return &DeleteGroupMemberSpectraS3Request{
        GroupMember: groupMember,
    }
}

type DeleteGroupMemberSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteGroupMemberSpectraS3Response(webResponse WebResponse) (*DeleteGroupMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteGroupMemberSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteGroupSpectraS3Request struct {
    Group string
}

func NewDeleteGroupSpectraS3Request(group string) *DeleteGroupSpectraS3Request {
    return &DeleteGroupSpectraS3Request{
        Group: group,
    }
}

type DeleteGroupSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteGroupSpectraS3Response(webResponse WebResponse) (*DeleteGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteGroupSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteJobCompletedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteJobCompletedNotificationRegistrationSpectraS3Request(notificationId string) *DeleteJobCompletedNotificationRegistrationSpectraS3Request {
    return &DeleteJobCompletedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteJobCompletedNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteJobCompletedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteJobCompletedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteJobCompletedNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteJobCreatedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteJobCreatedNotificationRegistrationSpectraS3Request(notificationId string) *DeleteJobCreatedNotificationRegistrationSpectraS3Request {
    return &DeleteJobCreatedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteJobCreatedNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteJobCreatedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteJobCreatedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteJobCreatedNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteJobCreationFailedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteJobCreationFailedNotificationRegistrationSpectraS3Request(notificationId string) *DeleteJobCreationFailedNotificationRegistrationSpectraS3Request {
    return &DeleteJobCreationFailedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteJobCreationFailedNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteJobCreationFailedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteJobCreationFailedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteJobCreationFailedNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteObjectCachedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteObjectCachedNotificationRegistrationSpectraS3Request(notificationId string) *DeleteObjectCachedNotificationRegistrationSpectraS3Request {
    return &DeleteObjectCachedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteObjectCachedNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteObjectCachedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteObjectCachedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteObjectCachedNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteObjectError struct {
    Code *string
    Key *string
    Message *string
}
func (deleteObjectError *DeleteObjectError) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Code":
            deleteObjectError.Code = parseNullableString(child.Content)
        case "Key":
            deleteObjectError.Key = parseNullableString(child.Content)
        case "Message":
            deleteObjectError.Message = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DeleteObjectError.", child.XMLName.Local)
        }
    }
}
type DeleteObjectLostNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteObjectLostNotificationRegistrationSpectraS3Request(notificationId string) *DeleteObjectLostNotificationRegistrationSpectraS3Request {
    return &DeleteObjectLostNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteObjectLostNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteObjectLostNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteObjectLostNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteObjectLostNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteObjectPersistedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteObjectPersistedNotificationRegistrationSpectraS3Request(notificationId string) *DeleteObjectPersistedNotificationRegistrationSpectraS3Request {
    return &DeleteObjectPersistedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteObjectPersistedNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteObjectPersistedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteObjectPersistedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteObjectPersistedNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteObjectRequest struct {
    BucketName string
    ObjectName string
    RollBack bool
}

func NewDeleteObjectRequest(bucketName string, objectName string) *DeleteObjectRequest {
    return &DeleteObjectRequest{
        BucketName: bucketName,
        ObjectName: objectName,
    }
}

func (deleteObjectRequest *DeleteObjectRequest) WithRollBack() *DeleteObjectRequest {
    deleteObjectRequest.RollBack = true
    return deleteObjectRequest
}

type DeleteObjectResponse struct {
    
    Headers *http.Header
}



func NewDeleteObjectResponse(webResponse WebResponse) (*DeleteObjectResponse, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteObjectResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteObjectsRequest struct {
    BucketName string
    ObjectNames []string
    RollBack bool
}

func NewDeleteObjectsRequest(bucketName string, objectNames []string) *DeleteObjectsRequest {
    return &DeleteObjectsRequest{
        BucketName: bucketName,
        ObjectNames: objectNames,
    }
}

func (deleteObjectsRequest *DeleteObjectsRequest) WithRollBack() *DeleteObjectsRequest {
    deleteObjectsRequest.RollBack = true
    return deleteObjectsRequest
}

type DeleteObjectsResponse struct {
    DeleteResult DeleteResult
    Headers *http.Header
}

func (deleteObjectsResponse *DeleteObjectsResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &deleteObjectsResponse.DeleteResult)
}

func NewDeleteObjectsResponse(webResponse WebResponse) (*DeleteObjectsResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body DeleteObjectsResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeletePermanentlyLostPoolSpectraS3Request struct {
    Pool string
}

func NewDeletePermanentlyLostPoolSpectraS3Request(pool string) *DeletePermanentlyLostPoolSpectraS3Request {
    return &DeletePermanentlyLostPoolSpectraS3Request{
        Pool: pool,
    }
}

type DeletePermanentlyLostPoolSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeletePermanentlyLostPoolSpectraS3Response(webResponse WebResponse) (*DeletePermanentlyLostPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeletePermanentlyLostPoolSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeletePermanentlyLostTapeSpectraS3Request struct {
    TapeId string
}

func NewDeletePermanentlyLostTapeSpectraS3Request(tapeId string) *DeletePermanentlyLostTapeSpectraS3Request {
    return &DeletePermanentlyLostTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type DeletePermanentlyLostTapeSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeletePermanentlyLostTapeSpectraS3Response(webResponse WebResponse) (*DeletePermanentlyLostTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeletePermanentlyLostTapeSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeletePoolFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeletePoolFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeletePoolFailureNotificationRegistrationSpectraS3Request {
    return &DeletePoolFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeletePoolFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeletePoolFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeletePoolFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeletePoolFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeletePoolFailureSpectraS3Request struct {
    PoolFailure string
}

func NewDeletePoolFailureSpectraS3Request(poolFailure string) *DeletePoolFailureSpectraS3Request {
    return &DeletePoolFailureSpectraS3Request{
        PoolFailure: poolFailure,
    }
}

type DeletePoolFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeletePoolFailureSpectraS3Response(webResponse WebResponse) (*DeletePoolFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeletePoolFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeletePoolPartitionSpectraS3Request struct {
    PoolPartition string
}

func NewDeletePoolPartitionSpectraS3Request(poolPartition string) *DeletePoolPartitionSpectraS3Request {
    return &DeletePoolPartitionSpectraS3Request{
        PoolPartition: poolPartition,
    }
}

type DeletePoolPartitionSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeletePoolPartitionSpectraS3Response(webResponse WebResponse) (*DeletePoolPartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeletePoolPartitionSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteResult struct {
    DeletedObjects []S3ObjectToDelete
    Errors []DeleteObjectError
}
func (deleteResult *DeleteResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Deleted":
            var model S3ObjectToDelete
            model.parse(&child, aggErr)
            deleteResult.DeletedObjects = append(deleteResult.DeletedObjects, model)
        case "Error":
            var model DeleteObjectError
            model.parse(&child, aggErr)
            deleteResult.Errors = append(deleteResult.Errors, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DeleteResult.", child.XMLName.Local)
        }
    }
}
type DeleteS3DataReplicationRuleSpectraS3Request struct {
    S3DataReplicationRule string
}

func NewDeleteS3DataReplicationRuleSpectraS3Request(s3DataReplicationRule string) *DeleteS3DataReplicationRuleSpectraS3Request {
    return &DeleteS3DataReplicationRuleSpectraS3Request{
        S3DataReplicationRule: s3DataReplicationRule,
    }
}

type DeleteS3DataReplicationRuleSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*DeleteS3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3DataReplicationRuleSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteS3TargetBucketNameSpectraS3Request struct {
    S3TargetBucketName string
}

func NewDeleteS3TargetBucketNameSpectraS3Request(s3TargetBucketName string) *DeleteS3TargetBucketNameSpectraS3Request {
    return &DeleteS3TargetBucketNameSpectraS3Request{
        S3TargetBucketName: s3TargetBucketName,
    }
}

type DeleteS3TargetBucketNameSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3TargetBucketNameSpectraS3Response(webResponse WebResponse) (*DeleteS3TargetBucketNameSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3TargetBucketNameSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteS3TargetFailureNotificationRegistrationSpectraS3Request struct {
    S3TargetFailureNotificationRegistration string
}

func NewDeleteS3TargetFailureNotificationRegistrationSpectraS3Request(s3TargetFailureNotificationRegistration string) *DeleteS3TargetFailureNotificationRegistrationSpectraS3Request {
    return &DeleteS3TargetFailureNotificationRegistrationSpectraS3Request{
        S3TargetFailureNotificationRegistration: s3TargetFailureNotificationRegistration,
    }
}

type DeleteS3TargetFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteS3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3TargetFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteS3TargetFailureSpectraS3Request struct {
    S3TargetFailure string
}

func NewDeleteS3TargetFailureSpectraS3Request(s3TargetFailure string) *DeleteS3TargetFailureSpectraS3Request {
    return &DeleteS3TargetFailureSpectraS3Request{
        S3TargetFailure: s3TargetFailure,
    }
}

type DeleteS3TargetFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3TargetFailureSpectraS3Response(webResponse WebResponse) (*DeleteS3TargetFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3TargetFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteS3TargetReadPreferenceSpectraS3Request struct {
    S3TargetReadPreference string
}

func NewDeleteS3TargetReadPreferenceSpectraS3Request(s3TargetReadPreference string) *DeleteS3TargetReadPreferenceSpectraS3Request {
    return &DeleteS3TargetReadPreferenceSpectraS3Request{
        S3TargetReadPreference: s3TargetReadPreference,
    }
}

type DeleteS3TargetReadPreferenceSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*DeleteS3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3TargetReadPreferenceSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteS3TargetSpectraS3Request struct {
    S3Target string
}

func NewDeleteS3TargetSpectraS3Request(s3Target string) *DeleteS3TargetSpectraS3Request {
    return &DeleteS3TargetSpectraS3Request{
        S3Target: s3Target,
    }
}

type DeleteS3TargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteS3TargetSpectraS3Response(webResponse WebResponse) (*DeleteS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteS3TargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteStorageDomainFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteStorageDomainFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeleteStorageDomainFailureNotificationRegistrationSpectraS3Request {
    return &DeleteStorageDomainFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteStorageDomainFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteStorageDomainFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteStorageDomainFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteStorageDomainFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteStorageDomainFailureSpectraS3Request struct {
    StorageDomainFailure string
}

func NewDeleteStorageDomainFailureSpectraS3Request(storageDomainFailure string) *DeleteStorageDomainFailureSpectraS3Request {
    return &DeleteStorageDomainFailureSpectraS3Request{
        StorageDomainFailure: storageDomainFailure,
    }
}

type DeleteStorageDomainFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteStorageDomainFailureSpectraS3Response(webResponse WebResponse) (*DeleteStorageDomainFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteStorageDomainFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteStorageDomainMemberSpectraS3Request struct {
    StorageDomainMember string
}

func NewDeleteStorageDomainMemberSpectraS3Request(storageDomainMember string) *DeleteStorageDomainMemberSpectraS3Request {
    return &DeleteStorageDomainMemberSpectraS3Request{
        StorageDomainMember: storageDomainMember,
    }
}

type DeleteStorageDomainMemberSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteStorageDomainMemberSpectraS3Response(webResponse WebResponse) (*DeleteStorageDomainMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteStorageDomainMemberSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteStorageDomainSpectraS3Request struct {
    StorageDomain string
}

func NewDeleteStorageDomainSpectraS3Request(storageDomain string) *DeleteStorageDomainSpectraS3Request {
    return &DeleteStorageDomainSpectraS3Request{
        StorageDomain: storageDomain,
    }
}

type DeleteStorageDomainSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteStorageDomainSpectraS3Response(webResponse WebResponse) (*DeleteStorageDomainSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteStorageDomainSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteSystemFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteSystemFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeleteSystemFailureNotificationRegistrationSpectraS3Request {
    return &DeleteSystemFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteSystemFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteSystemFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteSystemFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteSystemFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapeDensityDirectiveSpectraS3Request struct {
    TapeDensityDirective string
}

func NewDeleteTapeDensityDirectiveSpectraS3Request(tapeDensityDirective string) *DeleteTapeDensityDirectiveSpectraS3Request {
    return &DeleteTapeDensityDirectiveSpectraS3Request{
        TapeDensityDirective: tapeDensityDirective,
    }
}

type DeleteTapeDensityDirectiveSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapeDensityDirectiveSpectraS3Response(webResponse WebResponse) (*DeleteTapeDensityDirectiveSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapeDensityDirectiveSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapeDriveSpectraS3Request struct {
    TapeDriveId string
}

func NewDeleteTapeDriveSpectraS3Request(tapeDriveId string) *DeleteTapeDriveSpectraS3Request {
    return &DeleteTapeDriveSpectraS3Request{
        TapeDriveId: tapeDriveId,
    }
}

type DeleteTapeDriveSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapeDriveSpectraS3Response(webResponse WebResponse) (*DeleteTapeDriveSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapeDriveSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapeFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteTapeFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeleteTapeFailureNotificationRegistrationSpectraS3Request {
    return &DeleteTapeFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteTapeFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapeFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteTapeFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapeFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapeFailureSpectraS3Request struct {
    TapeFailure string
}

func NewDeleteTapeFailureSpectraS3Request(tapeFailure string) *DeleteTapeFailureSpectraS3Request {
    return &DeleteTapeFailureSpectraS3Request{
        TapeFailure: tapeFailure,
    }
}

type DeleteTapeFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapeFailureSpectraS3Response(webResponse WebResponse) (*DeleteTapeFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapeFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapePartitionFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewDeleteTapePartitionFailureNotificationRegistrationSpectraS3Request(notificationId string) *DeleteTapePartitionFailureNotificationRegistrationSpectraS3Request {
    return &DeleteTapePartitionFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type DeleteTapePartitionFailureNotificationRegistrationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapePartitionFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*DeleteTapePartitionFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapePartitionFailureNotificationRegistrationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapePartitionFailureSpectraS3Request struct {
    TapePartitionFailure string
}

func NewDeleteTapePartitionFailureSpectraS3Request(tapePartitionFailure string) *DeleteTapePartitionFailureSpectraS3Request {
    return &DeleteTapePartitionFailureSpectraS3Request{
        TapePartitionFailure: tapePartitionFailure,
    }
}

type DeleteTapePartitionFailureSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapePartitionFailureSpectraS3Response(webResponse WebResponse) (*DeleteTapePartitionFailureSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapePartitionFailureSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DeleteTapePartitionSpectraS3Request struct {
    TapePartition string
}

func NewDeleteTapePartitionSpectraS3Request(tapePartition string) *DeleteTapePartitionSpectraS3Request {
    return &DeleteTapePartitionSpectraS3Request{
        TapePartition: tapePartition,
    }
}

type DeleteTapePartitionSpectraS3Response struct {
    
    Headers *http.Header
}



func NewDeleteTapePartitionSpectraS3Response(webResponse WebResponse) (*DeleteTapePartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &DeleteTapePartitionSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type DetailedS3Object struct {
    Blobs *BulkObjectList
    BlobsBeingPersisted *int
    BlobsDegraded *int
    BlobsInCache *int
    BlobsTotal *int
    BucketId string
    CreationDate *string
    ETag *string
    Id string
    Latest bool
    Name *string
    Owner *string
    Size int64
    Type S3ObjectType
    Version int64
}
type DetailedS3ObjectList struct {
    DetailedS3Objects []DetailedS3Object
}
func (detailedS3ObjectList *DetailedS3ObjectList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Object":
            var model DetailedS3Object
            model.parse(&child, aggErr)
            detailedS3ObjectList.DetailedS3Objects = append(detailedS3ObjectList.DetailedS3Objects, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DetailedS3ObjectList.", child.XMLName.Local)
        }
    }
}
func (detailedS3Object *DetailedS3Object) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Blobs":
            var model BulkObjectList
            model.parse(&child, aggErr)
            detailedS3Object.Blobs = &model
        case "BlobsBeingPersisted":
            detailedS3Object.BlobsBeingPersisted = parseNullableInt(child.Content, aggErr)
        case "BlobsDegraded":
            detailedS3Object.BlobsDegraded = parseNullableInt(child.Content, aggErr)
        case "BlobsInCache":
            detailedS3Object.BlobsInCache = parseNullableInt(child.Content, aggErr)
        case "BlobsTotal":
            detailedS3Object.BlobsTotal = parseNullableInt(child.Content, aggErr)
        case "BucketId":
            detailedS3Object.BucketId = parseString(child.Content)
        case "CreationDate":
            detailedS3Object.CreationDate = parseNullableString(child.Content)
        case "ETag":
            detailedS3Object.ETag = parseNullableString(child.Content)
        case "Id":
            detailedS3Object.Id = parseString(child.Content)
        case "Latest":
            detailedS3Object.Latest = parseBool(child.Content, aggErr)
        case "Name":
            detailedS3Object.Name = parseNullableString(child.Content)
        case "Owner":
            detailedS3Object.Owner = parseNullableString(child.Content)
        case "Size":
            detailedS3Object.Size = parseInt64(child.Content, aggErr)
        case "Type":
            parseEnum(child.Content, &detailedS3Object.Type, aggErr)
        case "Version":
            detailedS3Object.Version = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DetailedS3Object.", child.XMLName.Local)
        }
    }
}
type DetailedTapeFailure struct {
    Date string
    ErrorMessage *string
    Id string
    TapeDriveId string
    TapeId string
    Type TapeFailureType
}
type DetailedTapeFailureList struct {
    DetailedTapeFailures []DetailedTapeFailure
}
func (detailedTapeFailureList *DetailedTapeFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapeFailure":
            var model DetailedTapeFailure
            model.parse(&child, aggErr)
            detailedTapeFailureList.DetailedTapeFailures = append(detailedTapeFailureList.DetailedTapeFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DetailedTapeFailureList.", child.XMLName.Local)
        }
    }
}
func (detailedTapeFailure *DetailedTapeFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            detailedTapeFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            detailedTapeFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            detailedTapeFailure.Id = parseString(child.Content)
        case "TapeDriveId":
            detailedTapeFailure.TapeDriveId = parseString(child.Content)
        case "TapeId":
            detailedTapeFailure.TapeId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &detailedTapeFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DetailedTapeFailure.", child.XMLName.Local)
        }
    }
}
type DetailedTapePartition struct {
    DriveType *TapeDriveType
    DriveTypes []TapeDriveType
    ErrorMessage *string
    Id string
    ImportExportConfiguration ImportExportConfiguration
    LibraryId string
    Name *string
    Quiesced Quiesced
    SerialId *string
    SerialNumber *string
    State TapePartitionState
    TapeTypes []string
}
func (detailedTapePartition *DetailedTapePartition) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DriveType":
            parseNullableEnum(child.Content, detailedTapePartition.DriveType, aggErr)
        case "DriveTypes":
            var model TapeDriveType
            parseEnum(child.Content, &model, aggErr)
            detailedTapePartition.DriveTypes = append(detailedTapePartition.DriveTypes, model)
        case "ErrorMessage":
            detailedTapePartition.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            detailedTapePartition.Id = parseString(child.Content)
        case "ImportExportConfiguration":
            parseEnum(child.Content, &detailedTapePartition.ImportExportConfiguration, aggErr)
        case "LibraryId":
            detailedTapePartition.LibraryId = parseString(child.Content)
        case "Name":
            detailedTapePartition.Name = parseNullableString(child.Content)
        case "Quiesced":
            parseEnum(child.Content, &detailedTapePartition.Quiesced, aggErr)
        case "SerialId":
            detailedTapePartition.SerialId = parseNullableString(child.Content)
        case "SerialNumber":
            detailedTapePartition.SerialNumber = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &detailedTapePartition.State, aggErr)
        case "TapeTypes":
            var str = parseString(child.Content)
            detailedTapePartition.TapeTypes = append(detailedTapePartition.TapeTypes, str)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing DetailedTapePartition.", child.XMLName.Local)
        }
    }
}
type Ds3DataReplicationRule struct {
    DataPolicyId string
    Id string
    ReplicateDeletes bool
    State DataPlacementRuleState
    TargetDataPolicy *string
    TargetId string
    Type DataReplicationRuleType
}
type Ds3DataReplicationRuleList struct {
    Ds3DataReplicationRules []Ds3DataReplicationRule
}
func (ds3DataReplicationRuleList *Ds3DataReplicationRuleList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Ds3DataReplicationRule":
            var model Ds3DataReplicationRule
            model.parse(&child, aggErr)
            ds3DataReplicationRuleList.Ds3DataReplicationRules = append(ds3DataReplicationRuleList.Ds3DataReplicationRules, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3DataReplicationRuleList.", child.XMLName.Local)
        }
    }
}
func (ds3DataReplicationRule *Ds3DataReplicationRule) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyId":
            ds3DataReplicationRule.DataPolicyId = parseString(child.Content)
        case "Id":
            ds3DataReplicationRule.Id = parseString(child.Content)
        case "ReplicateDeletes":
            ds3DataReplicationRule.ReplicateDeletes = parseBool(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &ds3DataReplicationRule.State, aggErr)
        case "TargetDataPolicy":
            ds3DataReplicationRule.TargetDataPolicy = parseNullableString(child.Content)
        case "TargetId":
            ds3DataReplicationRule.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &ds3DataReplicationRule.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3DataReplicationRule.", child.XMLName.Local)
        }
    }
}
type WebResponse interface {
    StatusCode() int
    Body() io.ReadCloser
    Header() *http.Header
}

type WrappedHttpResponse struct {
    rawResponse *http.Response
}

func NewWrappedHttpResponse(rawResponse *http.Response) *WrappedHttpResponse {
    return &WrappedHttpResponse{rawResponse: rawResponse}
}

func (wrappedHttpResponse *WrappedHttpResponse) StatusCode() int {
    return wrappedHttpResponse.rawResponse.StatusCode
}

func (wrappedHttpResponse *WrappedHttpResponse) Body() io.ReadCloser {
    return wrappedHttpResponse.rawResponse.Body
}

func (wrappedHttpResponse *WrappedHttpResponse) Header() *http.Header {
    // The HTTP spec says headers keys are case insensitive, so we'll just
    // to lower them before processing the response so we can always get the
    // right thing.
    result := make(http.Header)
    header := wrappedHttpResponse.rawResponse.Header
    for k, v := range header {
        result[strings.ToLower(k)] = v
    }
    return &result
}

type Ds3Target struct {
    AccessControlReplication Ds3TargetAccessControlReplication
    AdminAuthId *string
    AdminSecretKey *string
    DataPathEndPoint *string
    DataPathHttps bool
    DataPathPort *int
    DataPathProxy *string
    DataPathVerifyCertificate bool
    DefaultReadPreference TargetReadPreferenceType
    Id string
    Name *string
    PermitGoingOutOfSync bool
    Quiesced Quiesced
    ReplicatedUserDefaultDataPolicy *string
    State TargetState
}
type Ds3TargetAccessControlReplication Enum

const (
    DS3_TARGET_ACCESS_CONTROL_REPLICATION_NONE Ds3TargetAccessControlReplication = 1 + iota
    DS3_TARGET_ACCESS_CONTROL_REPLICATION_USERS Ds3TargetAccessControlReplication = 1 + iota
)

func (ds3TargetAccessControlReplication *Ds3TargetAccessControlReplication) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *ds3TargetAccessControlReplication = UNDEFINED
        case "NONE": *ds3TargetAccessControlReplication = DS3_TARGET_ACCESS_CONTROL_REPLICATION_NONE
        case "USERS": *ds3TargetAccessControlReplication = DS3_TARGET_ACCESS_CONTROL_REPLICATION_USERS
        default:
            *ds3TargetAccessControlReplication = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into Ds3TargetAccessControlReplication", str))
    }
    return nil
}

func (ds3TargetAccessControlReplication Ds3TargetAccessControlReplication) String() string {
    switch ds3TargetAccessControlReplication {
        case DS3_TARGET_ACCESS_CONTROL_REPLICATION_NONE: return "NONE"
        case DS3_TARGET_ACCESS_CONTROL_REPLICATION_USERS: return "USERS"
        default:
            log.Printf("Error: invalid Ds3TargetAccessControlReplication represented by '%d'", ds3TargetAccessControlReplication)
            return ""
    }
}

func (ds3TargetAccessControlReplication Ds3TargetAccessControlReplication) StringPtr() *string {
    if ds3TargetAccessControlReplication == UNDEFINED {
        return nil
    }
    result := ds3TargetAccessControlReplication.String()
    return &result
}
type Ds3TargetFailure struct {
    Date string
    ErrorMessage *string
    Id string
    TargetId string
    Type TargetFailureType
}
type Ds3TargetFailureList struct {
    Ds3TargetFailures []Ds3TargetFailure
}
func (ds3TargetFailureList *Ds3TargetFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Ds3TargetFailure":
            var model Ds3TargetFailure
            model.parse(&child, aggErr)
            ds3TargetFailureList.Ds3TargetFailures = append(ds3TargetFailureList.Ds3TargetFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetFailureList.", child.XMLName.Local)
        }
    }
}
type Ds3TargetFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type Ds3TargetFailureNotificationRegistrationList struct {
    Ds3TargetFailureNotificationRegistrations []Ds3TargetFailureNotificationRegistration
}
func (ds3TargetFailureNotificationRegistrationList *Ds3TargetFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Ds3TargetFailureNotificationRegistration":
            var model Ds3TargetFailureNotificationRegistration
            model.parse(&child, aggErr)
            ds3TargetFailureNotificationRegistrationList.Ds3TargetFailureNotificationRegistrations = append(ds3TargetFailureNotificationRegistrationList.Ds3TargetFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (ds3TargetFailureNotificationRegistration *Ds3TargetFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            ds3TargetFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &ds3TargetFailureNotificationRegistration.Format, aggErr)
        case "Id":
            ds3TargetFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            ds3TargetFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            ds3TargetFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            ds3TargetFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &ds3TargetFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            ds3TargetFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &ds3TargetFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            ds3TargetFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            ds3TargetFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (ds3TargetFailure *Ds3TargetFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            ds3TargetFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            ds3TargetFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            ds3TargetFailure.Id = parseString(child.Content)
        case "TargetId":
            ds3TargetFailure.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &ds3TargetFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetFailure.", child.XMLName.Local)
        }
    }
}
type Ds3TargetList struct {
    Ds3Targets []Ds3Target
}
func (ds3TargetList *Ds3TargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Ds3Target":
            var model Ds3Target
            model.parse(&child, aggErr)
            ds3TargetList.Ds3Targets = append(ds3TargetList.Ds3Targets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetList.", child.XMLName.Local)
        }
    }
}
func (ds3Target *Ds3Target) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AccessControlReplication":
            parseEnum(child.Content, &ds3Target.AccessControlReplication, aggErr)
        case "AdminAuthId":
            ds3Target.AdminAuthId = parseNullableString(child.Content)
        case "AdminSecretKey":
            ds3Target.AdminSecretKey = parseNullableString(child.Content)
        case "DataPathEndPoint":
            ds3Target.DataPathEndPoint = parseNullableString(child.Content)
        case "DataPathHttps":
            ds3Target.DataPathHttps = parseBool(child.Content, aggErr)
        case "DataPathPort":
            ds3Target.DataPathPort = parseNullableInt(child.Content, aggErr)
        case "DataPathProxy":
            ds3Target.DataPathProxy = parseNullableString(child.Content)
        case "DataPathVerifyCertificate":
            ds3Target.DataPathVerifyCertificate = parseBool(child.Content, aggErr)
        case "DefaultReadPreference":
            parseEnum(child.Content, &ds3Target.DefaultReadPreference, aggErr)
        case "Id":
            ds3Target.Id = parseString(child.Content)
        case "Name":
            ds3Target.Name = parseNullableString(child.Content)
        case "PermitGoingOutOfSync":
            ds3Target.PermitGoingOutOfSync = parseBool(child.Content, aggErr)
        case "Quiesced":
            parseEnum(child.Content, &ds3Target.Quiesced, aggErr)
        case "ReplicatedUserDefaultDataPolicy":
            ds3Target.ReplicatedUserDefaultDataPolicy = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &ds3Target.State, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3Target.", child.XMLName.Local)
        }
    }
}

func parseDs3TargetSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []Ds3Target {
    var result []Ds3Target
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult Ds3Target
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing Ds3Target struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type Ds3TargetReadPreference struct {
    BucketId string
    Id string
    ReadPreference TargetReadPreferenceType
    TargetId string
}
type Ds3TargetReadPreferenceList struct {
    Ds3TargetReadPreferences []Ds3TargetReadPreference
}
func (ds3TargetReadPreferenceList *Ds3TargetReadPreferenceList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Ds3TargetReadPreference":
            var model Ds3TargetReadPreference
            model.parse(&child, aggErr)
            ds3TargetReadPreferenceList.Ds3TargetReadPreferences = append(ds3TargetReadPreferenceList.Ds3TargetReadPreferences, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetReadPreferenceList.", child.XMLName.Local)
        }
    }
}
func (ds3TargetReadPreference *Ds3TargetReadPreference) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            ds3TargetReadPreference.BucketId = parseString(child.Content)
        case "Id":
            ds3TargetReadPreference.Id = parseString(child.Content)
        case "ReadPreference":
            parseEnum(child.Content, &ds3TargetReadPreference.ReadPreference, aggErr)
        case "TargetId":
            ds3TargetReadPreference.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Ds3TargetReadPreference.", child.XMLName.Local)
        }
    }
}
type EjectAllTapesSpectraS3Request struct {
    EjectLabel *string
    EjectLocation *string
}

func NewEjectAllTapesSpectraS3Request() *EjectAllTapesSpectraS3Request {
    return &EjectAllTapesSpectraS3Request{
    }
}

func (ejectAllTapesSpectraS3Request *EjectAllTapesSpectraS3Request) WithEjectLabel(ejectLabel string) *EjectAllTapesSpectraS3Request {
    ejectAllTapesSpectraS3Request.EjectLabel = &ejectLabel
    return ejectAllTapesSpectraS3Request
}

func (ejectAllTapesSpectraS3Request *EjectAllTapesSpectraS3Request) WithEjectLocation(ejectLocation string) *EjectAllTapesSpectraS3Request {
    ejectAllTapesSpectraS3Request.EjectLocation = &ejectLocation
    return ejectAllTapesSpectraS3Request
}

type EjectAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (ejectAllTapesSpectraS3Response *EjectAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, ejectAllTapesSpectraS3Response.TapeFailureList)
}

func NewEjectAllTapesSpectraS3Response(webResponse WebResponse) (*EjectAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &EjectAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body EjectAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type EjectStorageDomainBlobsSpectraS3Request struct {
    BucketId string
    EjectLabel *string
    EjectLocation *string
    ObjectNames []string
    StorageDomainId string
}

func NewEjectStorageDomainBlobsSpectraS3Request(bucketId string, objectNames []string, storageDomainId string) *EjectStorageDomainBlobsSpectraS3Request {
    return &EjectStorageDomainBlobsSpectraS3Request{
        BucketId: bucketId,
        StorageDomainId: storageDomainId,
        ObjectNames: objectNames,
    }
}

func (ejectStorageDomainBlobsSpectraS3Request *EjectStorageDomainBlobsSpectraS3Request) WithEjectLabel(ejectLabel string) *EjectStorageDomainBlobsSpectraS3Request {
    ejectStorageDomainBlobsSpectraS3Request.EjectLabel = &ejectLabel
    return ejectStorageDomainBlobsSpectraS3Request
}

func (ejectStorageDomainBlobsSpectraS3Request *EjectStorageDomainBlobsSpectraS3Request) WithEjectLocation(ejectLocation string) *EjectStorageDomainBlobsSpectraS3Request {
    ejectStorageDomainBlobsSpectraS3Request.EjectLocation = &ejectLocation
    return ejectStorageDomainBlobsSpectraS3Request
}

type EjectStorageDomainBlobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewEjectStorageDomainBlobsSpectraS3Response(webResponse WebResponse) (*EjectStorageDomainBlobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &EjectStorageDomainBlobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type EjectStorageDomainSpectraS3Request struct {
    BucketId *string
    EjectLabel *string
    EjectLocation *string
    StorageDomainId string
}

func NewEjectStorageDomainSpectraS3Request(storageDomainId string) *EjectStorageDomainSpectraS3Request {
    return &EjectStorageDomainSpectraS3Request{
        StorageDomainId: storageDomainId,
    }
}

func (ejectStorageDomainSpectraS3Request *EjectStorageDomainSpectraS3Request) WithBucketId(bucketId string) *EjectStorageDomainSpectraS3Request {
    ejectStorageDomainSpectraS3Request.BucketId = &bucketId
    return ejectStorageDomainSpectraS3Request
}

func (ejectStorageDomainSpectraS3Request *EjectStorageDomainSpectraS3Request) WithEjectLabel(ejectLabel string) *EjectStorageDomainSpectraS3Request {
    ejectStorageDomainSpectraS3Request.EjectLabel = &ejectLabel
    return ejectStorageDomainSpectraS3Request
}

func (ejectStorageDomainSpectraS3Request *EjectStorageDomainSpectraS3Request) WithEjectLocation(ejectLocation string) *EjectStorageDomainSpectraS3Request {
    ejectStorageDomainSpectraS3Request.EjectLocation = &ejectLocation
    return ejectStorageDomainSpectraS3Request
}

type EjectStorageDomainSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (ejectStorageDomainSpectraS3Response *EjectStorageDomainSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, ejectStorageDomainSpectraS3Response.TapeFailureList)
}

func NewEjectStorageDomainSpectraS3Response(webResponse WebResponse) (*EjectStorageDomainSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &EjectStorageDomainSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body EjectStorageDomainSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type EjectTapeSpectraS3Request struct {
    EjectLabel *string
    EjectLocation *string
    TapeId string
}

func NewEjectTapeSpectraS3Request(tapeId string) *EjectTapeSpectraS3Request {
    return &EjectTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (ejectTapeSpectraS3Request *EjectTapeSpectraS3Request) WithEjectLabel(ejectLabel string) *EjectTapeSpectraS3Request {
    ejectTapeSpectraS3Request.EjectLabel = &ejectLabel
    return ejectTapeSpectraS3Request
}

func (ejectTapeSpectraS3Request *EjectTapeSpectraS3Request) WithEjectLocation(ejectLocation string) *EjectTapeSpectraS3Request {
    ejectTapeSpectraS3Request.EjectLocation = &ejectLocation
    return ejectTapeSpectraS3Request
}

type EjectTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (ejectTapeSpectraS3Response *EjectTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &ejectTapeSpectraS3Response.Tape)
}

func NewEjectTapeSpectraS3Response(webResponse WebResponse) (*EjectTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body EjectTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type Enum int

func (enum Enum) String() string {
    return "something..."
}

const (
    UNDEFINED = 0
)
type Error struct {
    Code *string
    HttpErrorCode int
    Message *string
    Resource *string
    ResourceId int64
}
func (error *Error) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Code":
            error.Code = parseNullableString(child.Content)
        case "HttpErrorCode":
            error.HttpErrorCode = parseInt(child.Content, aggErr)
        case "Message":
            error.Message = parseNullableString(child.Content)
        case "Resource":
            error.Resource = parseNullableString(child.Content)
        case "ResourceId":
            error.ResourceId = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Error.", child.XMLName.Local)
        }
    }
}
type FeatureKey struct {
    CurrentValue *int64
    ErrorMessage *string
    ExpirationDate *string
    Id string
    Key FeatureKeyType
    LimitValue *int64
}
type FeatureKeyList struct {
    FeatureKeys []FeatureKey
}
func (featureKeyList *FeatureKeyList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "FeatureKey":
            var model FeatureKey
            model.parse(&child, aggErr)
            featureKeyList.FeatureKeys = append(featureKeyList.FeatureKeys, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing FeatureKeyList.", child.XMLName.Local)
        }
    }
}
func (featureKey *FeatureKey) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CurrentValue":
            featureKey.CurrentValue = parseNullableInt64(child.Content, aggErr)
        case "ErrorMessage":
            featureKey.ErrorMessage = parseNullableString(child.Content)
        case "ExpirationDate":
            featureKey.ExpirationDate = parseNullableString(child.Content)
        case "Id":
            featureKey.Id = parseString(child.Content)
        case "Key":
            parseEnum(child.Content, &featureKey.Key, aggErr)
        case "LimitValue":
            featureKey.LimitValue = parseNullableInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing FeatureKey.", child.XMLName.Local)
        }
    }
}
type FeatureKeyType Enum

const (
    FEATURE_KEY_TYPE_AWS_S3_CLOUD_OUT FeatureKeyType = 1 + iota
    FEATURE_KEY_TYPE_MICROSOFT_AZURE_CLOUD_OUT FeatureKeyType = 1 + iota
)

func (featureKeyType *FeatureKeyType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *featureKeyType = UNDEFINED
        case "AWS_S3_CLOUD_OUT": *featureKeyType = FEATURE_KEY_TYPE_AWS_S3_CLOUD_OUT
        case "MICROSOFT_AZURE_CLOUD_OUT": *featureKeyType = FEATURE_KEY_TYPE_MICROSOFT_AZURE_CLOUD_OUT
        default:
            *featureKeyType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into FeatureKeyType", str))
    }
    return nil
}

func (featureKeyType FeatureKeyType) String() string {
    switch featureKeyType {
        case FEATURE_KEY_TYPE_AWS_S3_CLOUD_OUT: return "AWS_S3_CLOUD_OUT"
        case FEATURE_KEY_TYPE_MICROSOFT_AZURE_CLOUD_OUT: return "MICROSOFT_AZURE_CLOUD_OUT"
        default:
            log.Printf("Error: invalid FeatureKeyType represented by '%d'", featureKeyType)
            return ""
    }
}

func (featureKeyType FeatureKeyType) StringPtr() *string {
    if featureKeyType == UNDEFINED {
        return nil
    }
    result := featureKeyType.String()
    return &result
}
type ForceFeatureKeyValidationSpectraS3Request struct {
}

func NewForceFeatureKeyValidationSpectraS3Request() *ForceFeatureKeyValidationSpectraS3Request {
    return &ForceFeatureKeyValidationSpectraS3Request{
    }
}

type ForceFeatureKeyValidationSpectraS3Response struct {
    
    Headers *http.Header
}



func NewForceFeatureKeyValidationSpectraS3Response(webResponse WebResponse) (*ForceFeatureKeyValidationSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ForceFeatureKeyValidationSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ForceFullCacheReclaimSpectraS3Request struct {
}

func NewForceFullCacheReclaimSpectraS3Request() *ForceFullCacheReclaimSpectraS3Request {
    return &ForceFullCacheReclaimSpectraS3Request{
    }
}

type ForceFullCacheReclaimSpectraS3Response struct {
    
    Headers *http.Header
}



func NewForceFullCacheReclaimSpectraS3Response(webResponse WebResponse) (*ForceFullCacheReclaimSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ForceFullCacheReclaimSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ForcePoolEnvironmentRefreshSpectraS3Request struct {
}

func NewForcePoolEnvironmentRefreshSpectraS3Request() *ForcePoolEnvironmentRefreshSpectraS3Request {
    return &ForcePoolEnvironmentRefreshSpectraS3Request{
    }
}

type ForcePoolEnvironmentRefreshSpectraS3Response struct {
    
    Headers *http.Header
}



func NewForcePoolEnvironmentRefreshSpectraS3Response(webResponse WebResponse) (*ForcePoolEnvironmentRefreshSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ForcePoolEnvironmentRefreshSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ForceTapeEnvironmentRefreshSpectraS3Request struct {
}

func NewForceTapeEnvironmentRefreshSpectraS3Request() *ForceTapeEnvironmentRefreshSpectraS3Request {
    return &ForceTapeEnvironmentRefreshSpectraS3Request{
    }
}

type ForceTapeEnvironmentRefreshSpectraS3Response struct {
    
    Headers *http.Header
}



func NewForceTapeEnvironmentRefreshSpectraS3Response(webResponse WebResponse) (*ForceTapeEnvironmentRefreshSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ForceTapeEnvironmentRefreshSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ForceTargetEnvironmentRefreshSpectraS3Request struct {
}

func NewForceTargetEnvironmentRefreshSpectraS3Request() *ForceTargetEnvironmentRefreshSpectraS3Request {
    return &ForceTargetEnvironmentRefreshSpectraS3Request{
    }
}

type ForceTargetEnvironmentRefreshSpectraS3Response struct {
    
    Headers *http.Header
}



func NewForceTargetEnvironmentRefreshSpectraS3Response(webResponse WebResponse) (*ForceTargetEnvironmentRefreshSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ForceTargetEnvironmentRefreshSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type FormatAllForeignPoolsSpectraS3Request struct {
}

func NewFormatAllForeignPoolsSpectraS3Request() *FormatAllForeignPoolsSpectraS3Request {
    return &FormatAllForeignPoolsSpectraS3Request{
    }
}

type FormatAllForeignPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewFormatAllForeignPoolsSpectraS3Response(webResponse WebResponse) (*FormatAllForeignPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &FormatAllForeignPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type FormatAllTapesSpectraS3Request struct {
    Force bool
}

func NewFormatAllTapesSpectraS3Request() *FormatAllTapesSpectraS3Request {
    return &FormatAllTapesSpectraS3Request{
    }
}

func (formatAllTapesSpectraS3Request *FormatAllTapesSpectraS3Request) WithForce() *FormatAllTapesSpectraS3Request {
    formatAllTapesSpectraS3Request.Force = true
    return formatAllTapesSpectraS3Request
}

type FormatAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (formatAllTapesSpectraS3Response *FormatAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, formatAllTapesSpectraS3Response.TapeFailureList)
}

func NewFormatAllTapesSpectraS3Response(webResponse WebResponse) (*FormatAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &FormatAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body FormatAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type FormatForeignPoolSpectraS3Request struct {
    Pool string
}

func NewFormatForeignPoolSpectraS3Request(pool string) *FormatForeignPoolSpectraS3Request {
    return &FormatForeignPoolSpectraS3Request{
        Pool: pool,
    }
}

type FormatForeignPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (formatForeignPoolSpectraS3Response *FormatForeignPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &formatForeignPoolSpectraS3Response.Pool)
}

func NewFormatForeignPoolSpectraS3Response(webResponse WebResponse) (*FormatForeignPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body FormatForeignPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type FormatTapeSpectraS3Request struct {
    Force bool
    TapeId string
}

func NewFormatTapeSpectraS3Request(tapeId string) *FormatTapeSpectraS3Request {
    return &FormatTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (formatTapeSpectraS3Request *FormatTapeSpectraS3Request) WithForce() *FormatTapeSpectraS3Request {
    formatTapeSpectraS3Request.Force = true
    return formatTapeSpectraS3Request
}

type FormatTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (formatTapeSpectraS3Response *FormatTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &formatTapeSpectraS3Response.Tape)
}

func NewFormatTapeSpectraS3Response(webResponse WebResponse) (*FormatTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body FormatTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetActiveJobSpectraS3Request struct {
    ActiveJobId string
}

func NewGetActiveJobSpectraS3Request(activeJobId string) *GetActiveJobSpectraS3Request {
    return &GetActiveJobSpectraS3Request{
        ActiveJobId: activeJobId,
    }
}

type GetActiveJobSpectraS3Response struct {
    ActiveJob ActiveJob
    Headers *http.Header
}

func (getActiveJobSpectraS3Response *GetActiveJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getActiveJobSpectraS3Response.ActiveJob)
}

func NewGetActiveJobSpectraS3Response(webResponse WebResponse) (*GetActiveJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetActiveJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetActiveJobsSpectraS3Request struct {
    Aggregating *bool
    BucketId *string
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Priority Priority
    Rechunked *string
    RequestType JobRequestType
    Truncated *bool
    UserId *string
}

func NewGetActiveJobsSpectraS3Request() *GetActiveJobsSpectraS3Request {
    return &GetActiveJobsSpectraS3Request{
    }
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithAggregating(aggregating bool) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.Aggregating = &aggregating
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithBucketId(bucketId string) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.BucketId = &bucketId
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithChunkClientProcessingOrderGuarantee(chunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.ChunkClientProcessingOrderGuarantee = chunkClientProcessingOrderGuarantee
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithLastPage() *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.LastPage = true
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithName(name string) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.Name = &name
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithPageLength(pageLength int) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.PageLength = &pageLength
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithPageOffset(pageOffset int) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.PageOffset = &pageOffset
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithPriority(priority Priority) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.Priority = priority
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithRechunked(rechunked string) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.Rechunked = &rechunked
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.RequestType = requestType
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithTruncated(truncated bool) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.Truncated = &truncated
    return getActiveJobsSpectraS3Request
}

func (getActiveJobsSpectraS3Request *GetActiveJobsSpectraS3Request) WithUserId(userId string) *GetActiveJobsSpectraS3Request {
    getActiveJobsSpectraS3Request.UserId = &userId
    return getActiveJobsSpectraS3Request
}

type GetActiveJobsSpectraS3Response struct {
    ActiveJobList ActiveJobList
    Headers *http.Header
}

func (getActiveJobsSpectraS3Response *GetActiveJobsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getActiveJobsSpectraS3Response.ActiveJobList)
}

func NewGetActiveJobsSpectraS3Response(webResponse WebResponse) (*GetActiveJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetActiveJobsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureDataReplicationRuleSpectraS3Request struct {
    AzureDataReplicationRule string
}

func NewGetAzureDataReplicationRuleSpectraS3Request(azureDataReplicationRule string) *GetAzureDataReplicationRuleSpectraS3Request {
    return &GetAzureDataReplicationRuleSpectraS3Request{
        AzureDataReplicationRule: azureDataReplicationRule,
    }
}

type GetAzureDataReplicationRuleSpectraS3Response struct {
    AzureDataReplicationRule AzureDataReplicationRule
    Headers *http.Header
}

func (getAzureDataReplicationRuleSpectraS3Response *GetAzureDataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureDataReplicationRuleSpectraS3Response.AzureDataReplicationRule)
}

func NewGetAzureDataReplicationRuleSpectraS3Response(webResponse WebResponse) (*GetAzureDataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureDataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureDataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReplicateDeletes *bool
    State DataPlacementRuleState
    TargetId *string
}

func NewGetAzureDataReplicationRulesSpectraS3Request() *GetAzureDataReplicationRulesSpectraS3Request {
    return &GetAzureDataReplicationRulesSpectraS3Request{
    }
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithLastPage() *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.LastPage = true
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.State = state
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getAzureDataReplicationRulesSpectraS3Request
}

func (getAzureDataReplicationRulesSpectraS3Request *GetAzureDataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetAzureDataReplicationRulesSpectraS3Request {
    getAzureDataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getAzureDataReplicationRulesSpectraS3Request
}

type GetAzureDataReplicationRulesSpectraS3Response struct {
    AzureDataReplicationRuleList AzureDataReplicationRuleList
    Headers *http.Header
}

func (getAzureDataReplicationRulesSpectraS3Response *GetAzureDataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureDataReplicationRulesSpectraS3Response.AzureDataReplicationRuleList)
}

func NewGetAzureDataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetAzureDataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureDataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetBucketNamesSpectraS3Request struct {
    BucketId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetId *string
}

func NewGetAzureTargetBucketNamesSpectraS3Request() *GetAzureTargetBucketNamesSpectraS3Request {
    return &GetAzureTargetBucketNamesSpectraS3Request{
    }
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithBucketId(bucketId string) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.BucketId = &bucketId
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithLastPage() *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.LastPage = true
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithName(name string) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.Name = &name
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithPageLength(pageLength int) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.PageLength = &pageLength
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.PageOffset = &pageOffset
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureTargetBucketNamesSpectraS3Request
}

func (getAzureTargetBucketNamesSpectraS3Request *GetAzureTargetBucketNamesSpectraS3Request) WithTargetId(targetId string) *GetAzureTargetBucketNamesSpectraS3Request {
    getAzureTargetBucketNamesSpectraS3Request.TargetId = &targetId
    return getAzureTargetBucketNamesSpectraS3Request
}

type GetAzureTargetBucketNamesSpectraS3Response struct {
    AzureTargetBucketNameList AzureTargetBucketNameList
    Headers *http.Header
}

func (getAzureTargetBucketNamesSpectraS3Response *GetAzureTargetBucketNamesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetBucketNamesSpectraS3Response.AzureTargetBucketNameList)
}

func NewGetAzureTargetBucketNamesSpectraS3Response(webResponse WebResponse) (*GetAzureTargetBucketNamesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetBucketNamesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetFailureNotificationRegistrationSpectraS3Request struct {
    AzureTargetFailureNotificationRegistration string
}

func NewGetAzureTargetFailureNotificationRegistrationSpectraS3Request(azureTargetFailureNotificationRegistration string) *GetAzureTargetFailureNotificationRegistrationSpectraS3Request {
    return &GetAzureTargetFailureNotificationRegistrationSpectraS3Request{
        AzureTargetFailureNotificationRegistration: azureTargetFailureNotificationRegistration,
    }
}

type GetAzureTargetFailureNotificationRegistrationSpectraS3Response struct {
    AzureTargetFailureNotificationRegistration AzureTargetFailureNotificationRegistration
    Headers *http.Header
}

func (getAzureTargetFailureNotificationRegistrationSpectraS3Response *GetAzureTargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetFailureNotificationRegistrationSpectraS3Response.AzureTargetFailureNotificationRegistration)
}

func NewGetAzureTargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetAzureTargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetAzureTargetFailureNotificationRegistrationsSpectraS3Request() *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    return &GetAzureTargetFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Request *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    getAzureTargetFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getAzureTargetFailureNotificationRegistrationsSpectraS3Request
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Request *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    getAzureTargetFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getAzureTargetFailureNotificationRegistrationsSpectraS3Request
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Request *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    getAzureTargetFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getAzureTargetFailureNotificationRegistrationsSpectraS3Request
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Request *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    getAzureTargetFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureTargetFailureNotificationRegistrationsSpectraS3Request
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Request *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetAzureTargetFailureNotificationRegistrationsSpectraS3Request {
    getAzureTargetFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getAzureTargetFailureNotificationRegistrationsSpectraS3Request
}

type GetAzureTargetFailureNotificationRegistrationsSpectraS3Response struct {
    AzureTargetFailureNotificationRegistrationList AzureTargetFailureNotificationRegistrationList
    Headers *http.Header
}

func (getAzureTargetFailureNotificationRegistrationsSpectraS3Response *GetAzureTargetFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetFailureNotificationRegistrationsSpectraS3Response.AzureTargetFailureNotificationRegistrationList)
}

func NewGetAzureTargetFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetAzureTargetFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetFailureType TargetFailureType
    TargetId *string
}

func NewGetAzureTargetFailuresSpectraS3Request() *GetAzureTargetFailuresSpectraS3Request {
    return &GetAzureTargetFailuresSpectraS3Request{
    }
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithLastPage() *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.LastPage = true
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithPageLength(pageLength int) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.PageLength = &pageLength
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.PageOffset = &pageOffset
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithTargetId(targetId string) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.TargetId = &targetId
    return getAzureTargetFailuresSpectraS3Request
}

func (getAzureTargetFailuresSpectraS3Request *GetAzureTargetFailuresSpectraS3Request) WithTargetFailureType(targetFailureType TargetFailureType) *GetAzureTargetFailuresSpectraS3Request {
    getAzureTargetFailuresSpectraS3Request.TargetFailureType = targetFailureType
    return getAzureTargetFailuresSpectraS3Request
}

type GetAzureTargetFailuresSpectraS3Response struct {
    AzureTargetFailureList AzureTargetFailureList
    Headers *http.Header
}

func (getAzureTargetFailuresSpectraS3Response *GetAzureTargetFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetFailuresSpectraS3Response.AzureTargetFailureList)
}

func NewGetAzureTargetFailuresSpectraS3Response(webResponse WebResponse) (*GetAzureTargetFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetReadPreferenceSpectraS3Request struct {
    AzureTargetReadPreference string
}

func NewGetAzureTargetReadPreferenceSpectraS3Request(azureTargetReadPreference string) *GetAzureTargetReadPreferenceSpectraS3Request {
    return &GetAzureTargetReadPreferenceSpectraS3Request{
        AzureTargetReadPreference: azureTargetReadPreference,
    }
}

type GetAzureTargetReadPreferenceSpectraS3Response struct {
    AzureTargetReadPreference AzureTargetReadPreference
    Headers *http.Header
}

func (getAzureTargetReadPreferenceSpectraS3Response *GetAzureTargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetReadPreferenceSpectraS3Response.AzureTargetReadPreference)
}

func NewGetAzureTargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*GetAzureTargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetReadPreferencesSpectraS3Request struct {
    BucketId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReadPreference TargetReadPreferenceType
    TargetId *string
}

func NewGetAzureTargetReadPreferencesSpectraS3Request() *GetAzureTargetReadPreferencesSpectraS3Request {
    return &GetAzureTargetReadPreferencesSpectraS3Request{
    }
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithBucketId(bucketId string) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.BucketId = &bucketId
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithLastPage() *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.LastPage = true
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithPageLength(pageLength int) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.PageLength = &pageLength
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.PageOffset = &pageOffset
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithReadPreference(readPreference TargetReadPreferenceType) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.ReadPreference = readPreference
    return getAzureTargetReadPreferencesSpectraS3Request
}

func (getAzureTargetReadPreferencesSpectraS3Request *GetAzureTargetReadPreferencesSpectraS3Request) WithTargetId(targetId string) *GetAzureTargetReadPreferencesSpectraS3Request {
    getAzureTargetReadPreferencesSpectraS3Request.TargetId = &targetId
    return getAzureTargetReadPreferencesSpectraS3Request
}

type GetAzureTargetReadPreferencesSpectraS3Response struct {
    AzureTargetReadPreferenceList AzureTargetReadPreferenceList
    Headers *http.Header
}

func (getAzureTargetReadPreferencesSpectraS3Response *GetAzureTargetReadPreferencesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetReadPreferencesSpectraS3Response.AzureTargetReadPreferenceList)
}

func NewGetAzureTargetReadPreferencesSpectraS3Response(webResponse WebResponse) (*GetAzureTargetReadPreferencesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetReadPreferencesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetSpectraS3Request struct {
    AzureTarget string
}

func NewGetAzureTargetSpectraS3Request(azureTarget string) *GetAzureTargetSpectraS3Request {
    return &GetAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
    }
}

type GetAzureTargetSpectraS3Response struct {
    AzureTarget AzureTarget
    Headers *http.Header
}

func (getAzureTargetSpectraS3Response *GetAzureTargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetSpectraS3Response.AzureTarget)
}

func NewGetAzureTargetSpectraS3Response(webResponse WebResponse) (*GetAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetAzureTargetsSpectraS3Request struct {
    AccountName *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PermitGoingOutOfSync *bool
    Quiesced Quiesced
    State TargetState
}

func NewGetAzureTargetsSpectraS3Request() *GetAzureTargetsSpectraS3Request {
    return &GetAzureTargetsSpectraS3Request{
    }
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithAccountName(accountName string) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.AccountName = &accountName
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithHttps(https bool) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.Https = &https
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithLastPage() *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.LastPage = true
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithName(name string) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.Name = &name
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithPageLength(pageLength int) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.PageLength = &pageLength
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.PageOffset = &pageOffset
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithQuiesced(quiesced Quiesced) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.Quiesced = quiesced
    return getAzureTargetsSpectraS3Request
}

func (getAzureTargetsSpectraS3Request *GetAzureTargetsSpectraS3Request) WithState(state TargetState) *GetAzureTargetsSpectraS3Request {
    getAzureTargetsSpectraS3Request.State = state
    return getAzureTargetsSpectraS3Request
}

type GetAzureTargetsSpectraS3Response struct {
    AzureTargetList AzureTargetList
    Headers *http.Header
}

func (getAzureTargetsSpectraS3Response *GetAzureTargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getAzureTargetsSpectraS3Response.AzureTargetList)
}

func NewGetAzureTargetsSpectraS3Response(webResponse WebResponse) (*GetAzureTargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetAzureTargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobPersistenceSpectraS3Request struct {
    RequestPayload string
}

func NewGetBlobPersistenceSpectraS3Request(requestPayload string) *GetBlobPersistenceSpectraS3Request {
    return &GetBlobPersistenceSpectraS3Request{
        RequestPayload: requestPayload,
    }
}

type GetBlobPersistenceSpectraS3Response struct {
    Content string
    Headers *http.Header
}



func NewGetBlobPersistenceSpectraS3Response(webResponse WebResponse) (*GetBlobPersistenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        content, err := getResponseBodyAsString(webResponse)
        if err != nil {
            return nil, err
        }
        return &GetBlobPersistenceSpectraS3Response{Content: content, Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobsOnAzureTargetSpectraS3Request struct {
    AzureTarget string
}

func NewGetBlobsOnAzureTargetSpectraS3Request(azureTarget string) *GetBlobsOnAzureTargetSpectraS3Request {
    return &GetBlobsOnAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
    }
}

type GetBlobsOnAzureTargetSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getBlobsOnAzureTargetSpectraS3Response *GetBlobsOnAzureTargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBlobsOnAzureTargetSpectraS3Response.BulkObjectList)
}

func NewGetBlobsOnAzureTargetSpectraS3Response(webResponse WebResponse) (*GetBlobsOnAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBlobsOnAzureTargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobsOnDs3TargetSpectraS3Request struct {
    Ds3Target string
}

func NewGetBlobsOnDs3TargetSpectraS3Request(ds3Target string) *GetBlobsOnDs3TargetSpectraS3Request {
    return &GetBlobsOnDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

type GetBlobsOnDs3TargetSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getBlobsOnDs3TargetSpectraS3Response *GetBlobsOnDs3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBlobsOnDs3TargetSpectraS3Response.BulkObjectList)
}

func NewGetBlobsOnDs3TargetSpectraS3Response(webResponse WebResponse) (*GetBlobsOnDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBlobsOnDs3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobsOnPoolSpectraS3Request struct {
    Pool string
}

func NewGetBlobsOnPoolSpectraS3Request(pool string) *GetBlobsOnPoolSpectraS3Request {
    return &GetBlobsOnPoolSpectraS3Request{
        Pool: pool,
    }
}

type GetBlobsOnPoolSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getBlobsOnPoolSpectraS3Response *GetBlobsOnPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBlobsOnPoolSpectraS3Response.BulkObjectList)
}

func NewGetBlobsOnPoolSpectraS3Response(webResponse WebResponse) (*GetBlobsOnPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBlobsOnPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobsOnS3TargetSpectraS3Request struct {
    S3Target string
}

func NewGetBlobsOnS3TargetSpectraS3Request(s3Target string) *GetBlobsOnS3TargetSpectraS3Request {
    return &GetBlobsOnS3TargetSpectraS3Request{
        S3Target: s3Target,
    }
}

type GetBlobsOnS3TargetSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getBlobsOnS3TargetSpectraS3Response *GetBlobsOnS3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBlobsOnS3TargetSpectraS3Response.BulkObjectList)
}

func NewGetBlobsOnS3TargetSpectraS3Response(webResponse WebResponse) (*GetBlobsOnS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBlobsOnS3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBlobsOnTapeSpectraS3Request struct {
    TapeId string
}

func NewGetBlobsOnTapeSpectraS3Request(tapeId string) *GetBlobsOnTapeSpectraS3Request {
    return &GetBlobsOnTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type GetBlobsOnTapeSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getBlobsOnTapeSpectraS3Response *GetBlobsOnTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBlobsOnTapeSpectraS3Response.BulkObjectList)
}

func NewGetBlobsOnTapeSpectraS3Response(webResponse WebResponse) (*GetBlobsOnTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBlobsOnTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketAclSpectraS3Request struct {
    BucketAcl string
}

func NewGetBucketAclSpectraS3Request(bucketAcl string) *GetBucketAclSpectraS3Request {
    return &GetBucketAclSpectraS3Request{
        BucketAcl: bucketAcl,
    }
}

type GetBucketAclSpectraS3Response struct {
    BucketAcl BucketAcl
    Headers *http.Header
}

func (getBucketAclSpectraS3Response *GetBucketAclSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketAclSpectraS3Response.BucketAcl)
}

func NewGetBucketAclSpectraS3Response(webResponse WebResponse) (*GetBucketAclSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketAclSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketAclsSpectraS3Request struct {
    BucketId *string
    GroupId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Permission BucketAclPermission
    UserId *string
}

func NewGetBucketAclsSpectraS3Request() *GetBucketAclsSpectraS3Request {
    return &GetBucketAclsSpectraS3Request{
    }
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithBucketId(bucketId string) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.BucketId = &bucketId
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithGroupId(groupId string) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.GroupId = &groupId
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithLastPage() *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.LastPage = true
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithPageLength(pageLength int) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.PageLength = &pageLength
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithPageOffset(pageOffset int) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.PageOffset = &pageOffset
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithPermission(permission BucketAclPermission) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.Permission = permission
    return getBucketAclsSpectraS3Request
}

func (getBucketAclsSpectraS3Request *GetBucketAclsSpectraS3Request) WithUserId(userId string) *GetBucketAclsSpectraS3Request {
    getBucketAclsSpectraS3Request.UserId = &userId
    return getBucketAclsSpectraS3Request
}

type GetBucketAclsSpectraS3Response struct {
    BucketAclList BucketAclList
    Headers *http.Header
}

func (getBucketAclsSpectraS3Response *GetBucketAclsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketAclsSpectraS3Response.BucketAclList)
}

func NewGetBucketAclsSpectraS3Response(webResponse WebResponse) (*GetBucketAclsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketAclsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketCapacitySummarySpectraS3Request struct {
    BucketId string
    PoolHealth PoolHealth
    PoolState PoolState
    PoolType PoolType
    StorageDomainId string
    TapeState TapeState
    TapeType *string
}

func NewGetBucketCapacitySummarySpectraS3Request(bucketId string, storageDomainId string) *GetBucketCapacitySummarySpectraS3Request {
    return &GetBucketCapacitySummarySpectraS3Request{
        BucketId: bucketId,
        StorageDomainId: storageDomainId,
    }
}

func (getBucketCapacitySummarySpectraS3Request *GetBucketCapacitySummarySpectraS3Request) WithPoolHealth(poolHealth PoolHealth) *GetBucketCapacitySummarySpectraS3Request {
    getBucketCapacitySummarySpectraS3Request.PoolHealth = poolHealth
    return getBucketCapacitySummarySpectraS3Request
}

func (getBucketCapacitySummarySpectraS3Request *GetBucketCapacitySummarySpectraS3Request) WithPoolState(poolState PoolState) *GetBucketCapacitySummarySpectraS3Request {
    getBucketCapacitySummarySpectraS3Request.PoolState = poolState
    return getBucketCapacitySummarySpectraS3Request
}

func (getBucketCapacitySummarySpectraS3Request *GetBucketCapacitySummarySpectraS3Request) WithPoolType(poolType PoolType) *GetBucketCapacitySummarySpectraS3Request {
    getBucketCapacitySummarySpectraS3Request.PoolType = poolType
    return getBucketCapacitySummarySpectraS3Request
}

func (getBucketCapacitySummarySpectraS3Request *GetBucketCapacitySummarySpectraS3Request) WithTapeState(tapeState TapeState) *GetBucketCapacitySummarySpectraS3Request {
    getBucketCapacitySummarySpectraS3Request.TapeState = tapeState
    return getBucketCapacitySummarySpectraS3Request
}

func (getBucketCapacitySummarySpectraS3Request *GetBucketCapacitySummarySpectraS3Request) WithTapeType(tapeType string) *GetBucketCapacitySummarySpectraS3Request {
    getBucketCapacitySummarySpectraS3Request.TapeType = &tapeType
    return getBucketCapacitySummarySpectraS3Request
}

type GetBucketCapacitySummarySpectraS3Response struct {
    CapacitySummaryContainer CapacitySummaryContainer
    Headers *http.Header
}

func (getBucketCapacitySummarySpectraS3Response *GetBucketCapacitySummarySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketCapacitySummarySpectraS3Response.CapacitySummaryContainer)
}

func NewGetBucketCapacitySummarySpectraS3Response(webResponse WebResponse) (*GetBucketCapacitySummarySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketCapacitySummarySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketRequest struct {
    BucketName string
    Delimiter *string
    Marker *string
    MaxKeys *int
    Prefix *string
}

func NewGetBucketRequest(bucketName string) *GetBucketRequest {
    return &GetBucketRequest{
        BucketName: bucketName,
    }
}

func (getBucketRequest *GetBucketRequest) WithDelimiter(delimiter string) *GetBucketRequest {
    getBucketRequest.Delimiter = &delimiter
    return getBucketRequest
}

func (getBucketRequest *GetBucketRequest) WithMarker(marker string) *GetBucketRequest {
    getBucketRequest.Marker = &marker
    return getBucketRequest
}

func (getBucketRequest *GetBucketRequest) WithMaxKeys(maxKeys int) *GetBucketRequest {
    getBucketRequest.MaxKeys = &maxKeys
    return getBucketRequest
}

func (getBucketRequest *GetBucketRequest) WithPrefix(prefix string) *GetBucketRequest {
    getBucketRequest.Prefix = &prefix
    return getBucketRequest
}

type GetBucketResponse struct {
    ListBucketResult ListBucketResult
    Headers *http.Header
}

func (getBucketResponse *GetBucketResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketResponse.ListBucketResult)
}

func NewGetBucketResponse(webResponse WebResponse) (*GetBucketResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketSpectraS3Request struct {
    BucketName string
}

func NewGetBucketSpectraS3Request(bucketName string) *GetBucketSpectraS3Request {
    return &GetBucketSpectraS3Request{
        BucketName: bucketName,
    }
}

type GetBucketSpectraS3Response struct {
    Bucket Bucket
    Headers *http.Header
}

func (getBucketSpectraS3Response *GetBucketSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketSpectraS3Response.Bucket)
}

func NewGetBucketSpectraS3Response(webResponse WebResponse) (*GetBucketSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBucketsSpectraS3Request struct {
    DataPolicyId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetBucketsSpectraS3Request() *GetBucketsSpectraS3Request {
    return &GetBucketsSpectraS3Request{
    }
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.DataPolicyId = &dataPolicyId
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithLastPage() *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.LastPage = true
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithName(name string) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.Name = &name
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithPageLength(pageLength int) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.PageLength = &pageLength
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithPageOffset(pageOffset int) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.PageOffset = &pageOffset
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getBucketsSpectraS3Request
}

func (getBucketsSpectraS3Request *GetBucketsSpectraS3Request) WithUserId(userId string) *GetBucketsSpectraS3Request {
    getBucketsSpectraS3Request.UserId = &userId
    return getBucketsSpectraS3Request
}

type GetBucketsSpectraS3Response struct {
    BucketList BucketList
    Headers *http.Header
}

func (getBucketsSpectraS3Response *GetBucketsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBucketsSpectraS3Response.BucketList)
}

func NewGetBucketsSpectraS3Response(webResponse WebResponse) (*GetBucketsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBucketsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetBulkJobSpectraS3Request struct {
    BucketName string
    Aggregating *bool
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    ImplicitJobIdResolution *bool
    Name *string
    Objects []Ds3GetObject
    Priority Priority
}

func NewGetBulkJobSpectraS3Request(bucketName string, objectNames []string) *GetBulkJobSpectraS3Request {

    return &GetBulkJobSpectraS3Request{
        BucketName: bucketName,
        Objects: buildDs3GetObjectSliceFromNames(objectNames),
    }
}

func NewGetBulkJobSpectraS3RequestWithPartialObjects(bucketName string, objects []Ds3GetObject) *GetBulkJobSpectraS3Request {

    return &GetBulkJobSpectraS3Request{
        BucketName: bucketName,
        Objects: objects,
    }
}

func (getBulkJobSpectraS3Request *GetBulkJobSpectraS3Request) WithAggregating(aggregating bool) *GetBulkJobSpectraS3Request {
    getBulkJobSpectraS3Request.Aggregating = &aggregating
    return getBulkJobSpectraS3Request
}

func (getBulkJobSpectraS3Request *GetBulkJobSpectraS3Request) WithChunkClientProcessingOrderGuarantee(chunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) *GetBulkJobSpectraS3Request {
    getBulkJobSpectraS3Request.ChunkClientProcessingOrderGuarantee = chunkClientProcessingOrderGuarantee
    return getBulkJobSpectraS3Request
}

func (getBulkJobSpectraS3Request *GetBulkJobSpectraS3Request) WithImplicitJobIdResolution(implicitJobIdResolution bool) *GetBulkJobSpectraS3Request {
    getBulkJobSpectraS3Request.ImplicitJobIdResolution = &implicitJobIdResolution
    return getBulkJobSpectraS3Request
}

func (getBulkJobSpectraS3Request *GetBulkJobSpectraS3Request) WithName(name string) *GetBulkJobSpectraS3Request {
    getBulkJobSpectraS3Request.Name = &name
    return getBulkJobSpectraS3Request
}

func (getBulkJobSpectraS3Request *GetBulkJobSpectraS3Request) WithPriority(priority Priority) *GetBulkJobSpectraS3Request {
    getBulkJobSpectraS3Request.Priority = priority
    return getBulkJobSpectraS3Request
}

type GetBulkJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (getBulkJobSpectraS3Response *GetBulkJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getBulkJobSpectraS3Response.MasterObjectList)
}

func NewGetBulkJobSpectraS3Response(webResponse WebResponse) (*GetBulkJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetBulkJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCacheFilesystemSpectraS3Request struct {
    CacheFilesystem string
}

func NewGetCacheFilesystemSpectraS3Request(cacheFilesystem string) *GetCacheFilesystemSpectraS3Request {
    return &GetCacheFilesystemSpectraS3Request{
        CacheFilesystem: cacheFilesystem,
    }
}

type GetCacheFilesystemSpectraS3Response struct {
    CacheFilesystem CacheFilesystem
    Headers *http.Header
}

func (getCacheFilesystemSpectraS3Response *GetCacheFilesystemSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCacheFilesystemSpectraS3Response.CacheFilesystem)
}

func NewGetCacheFilesystemSpectraS3Response(webResponse WebResponse) (*GetCacheFilesystemSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCacheFilesystemSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCacheFilesystemsSpectraS3Request struct {
    LastPage bool
    NodeId *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetCacheFilesystemsSpectraS3Request() *GetCacheFilesystemsSpectraS3Request {
    return &GetCacheFilesystemsSpectraS3Request{
    }
}

func (getCacheFilesystemsSpectraS3Request *GetCacheFilesystemsSpectraS3Request) WithLastPage() *GetCacheFilesystemsSpectraS3Request {
    getCacheFilesystemsSpectraS3Request.LastPage = true
    return getCacheFilesystemsSpectraS3Request
}

func (getCacheFilesystemsSpectraS3Request *GetCacheFilesystemsSpectraS3Request) WithNodeId(nodeId string) *GetCacheFilesystemsSpectraS3Request {
    getCacheFilesystemsSpectraS3Request.NodeId = &nodeId
    return getCacheFilesystemsSpectraS3Request
}

func (getCacheFilesystemsSpectraS3Request *GetCacheFilesystemsSpectraS3Request) WithPageLength(pageLength int) *GetCacheFilesystemsSpectraS3Request {
    getCacheFilesystemsSpectraS3Request.PageLength = &pageLength
    return getCacheFilesystemsSpectraS3Request
}

func (getCacheFilesystemsSpectraS3Request *GetCacheFilesystemsSpectraS3Request) WithPageOffset(pageOffset int) *GetCacheFilesystemsSpectraS3Request {
    getCacheFilesystemsSpectraS3Request.PageOffset = &pageOffset
    return getCacheFilesystemsSpectraS3Request
}

func (getCacheFilesystemsSpectraS3Request *GetCacheFilesystemsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetCacheFilesystemsSpectraS3Request {
    getCacheFilesystemsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getCacheFilesystemsSpectraS3Request
}

type GetCacheFilesystemsSpectraS3Response struct {
    CacheFilesystemList CacheFilesystemList
    Headers *http.Header
}

func (getCacheFilesystemsSpectraS3Response *GetCacheFilesystemsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCacheFilesystemsSpectraS3Response.CacheFilesystemList)
}

func NewGetCacheFilesystemsSpectraS3Response(webResponse WebResponse) (*GetCacheFilesystemsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCacheFilesystemsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCacheStateSpectraS3Request struct {
}

func NewGetCacheStateSpectraS3Request() *GetCacheStateSpectraS3Request {
    return &GetCacheStateSpectraS3Request{
    }
}

type GetCacheStateSpectraS3Response struct {
    CacheInformation CacheInformation
    Headers *http.Header
}

func (getCacheStateSpectraS3Response *GetCacheStateSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCacheStateSpectraS3Response.CacheInformation)
}

func NewGetCacheStateSpectraS3Response(webResponse WebResponse) (*GetCacheStateSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCacheStateSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCanceledJobSpectraS3Request struct {
    CanceledJob string
}

func NewGetCanceledJobSpectraS3Request(canceledJob string) *GetCanceledJobSpectraS3Request {
    return &GetCanceledJobSpectraS3Request{
        CanceledJob: canceledJob,
    }
}

type GetCanceledJobSpectraS3Response struct {
    CanceledJob CanceledJob
    Headers *http.Header
}

func (getCanceledJobSpectraS3Response *GetCanceledJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCanceledJobSpectraS3Response.CanceledJob)
}

func NewGetCanceledJobSpectraS3Response(webResponse WebResponse) (*GetCanceledJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCanceledJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCanceledJobsSpectraS3Request struct {
    BucketId *string
    CanceledDueToTimeout *bool
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Priority Priority
    Rechunked *string
    RequestType JobRequestType
    Truncated *bool
    UserId *string
}

func NewGetCanceledJobsSpectraS3Request() *GetCanceledJobsSpectraS3Request {
    return &GetCanceledJobsSpectraS3Request{
    }
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithBucketId(bucketId string) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.BucketId = &bucketId
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithCanceledDueToTimeout(canceledDueToTimeout bool) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.CanceledDueToTimeout = &canceledDueToTimeout
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithChunkClientProcessingOrderGuarantee(chunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.ChunkClientProcessingOrderGuarantee = chunkClientProcessingOrderGuarantee
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithLastPage() *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.LastPage = true
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithName(name string) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.Name = &name
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithPageLength(pageLength int) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.PageLength = &pageLength
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithPageOffset(pageOffset int) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.PageOffset = &pageOffset
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithPriority(priority Priority) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.Priority = priority
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithRechunked(rechunked string) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.Rechunked = &rechunked
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.RequestType = requestType
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithTruncated(truncated bool) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.Truncated = &truncated
    return getCanceledJobsSpectraS3Request
}

func (getCanceledJobsSpectraS3Request *GetCanceledJobsSpectraS3Request) WithUserId(userId string) *GetCanceledJobsSpectraS3Request {
    getCanceledJobsSpectraS3Request.UserId = &userId
    return getCanceledJobsSpectraS3Request
}

type GetCanceledJobsSpectraS3Response struct {
    CanceledJobList CanceledJobList
    Headers *http.Header
}

func (getCanceledJobsSpectraS3Response *GetCanceledJobsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCanceledJobsSpectraS3Response.CanceledJobList)
}

func NewGetCanceledJobsSpectraS3Response(webResponse WebResponse) (*GetCanceledJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCanceledJobsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCompletedJobSpectraS3Request struct {
    CompletedJob string
}

func NewGetCompletedJobSpectraS3Request(completedJob string) *GetCompletedJobSpectraS3Request {
    return &GetCompletedJobSpectraS3Request{
        CompletedJob: completedJob,
    }
}

type GetCompletedJobSpectraS3Response struct {
    CompletedJob CompletedJob
    Headers *http.Header
}

func (getCompletedJobSpectraS3Response *GetCompletedJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCompletedJobSpectraS3Response.CompletedJob)
}

func NewGetCompletedJobSpectraS3Response(webResponse WebResponse) (*GetCompletedJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCompletedJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetCompletedJobsSpectraS3Request struct {
    BucketId *string
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Priority Priority
    Rechunked *string
    RequestType JobRequestType
    Truncated *bool
    UserId *string
}

func NewGetCompletedJobsSpectraS3Request() *GetCompletedJobsSpectraS3Request {
    return &GetCompletedJobsSpectraS3Request{
    }
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithBucketId(bucketId string) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.BucketId = &bucketId
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithChunkClientProcessingOrderGuarantee(chunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.ChunkClientProcessingOrderGuarantee = chunkClientProcessingOrderGuarantee
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithLastPage() *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.LastPage = true
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithName(name string) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.Name = &name
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithPageLength(pageLength int) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.PageLength = &pageLength
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithPageOffset(pageOffset int) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.PageOffset = &pageOffset
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithPriority(priority Priority) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.Priority = priority
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithRechunked(rechunked string) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.Rechunked = &rechunked
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.RequestType = requestType
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithTruncated(truncated bool) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.Truncated = &truncated
    return getCompletedJobsSpectraS3Request
}

func (getCompletedJobsSpectraS3Request *GetCompletedJobsSpectraS3Request) WithUserId(userId string) *GetCompletedJobsSpectraS3Request {
    getCompletedJobsSpectraS3Request.UserId = &userId
    return getCompletedJobsSpectraS3Request
}

type GetCompletedJobsSpectraS3Response struct {
    CompletedJobList CompletedJobList
    Headers *http.Header
}

func (getCompletedJobsSpectraS3Response *GetCompletedJobsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getCompletedJobsSpectraS3Response.CompletedJobList)
}

func NewGetCompletedJobsSpectraS3Response(webResponse WebResponse) (*GetCompletedJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetCompletedJobsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPathBackendSpectraS3Request struct {
}

func NewGetDataPathBackendSpectraS3Request() *GetDataPathBackendSpectraS3Request {
    return &GetDataPathBackendSpectraS3Request{
    }
}

type GetDataPathBackendSpectraS3Response struct {
    DataPathBackend DataPathBackend
    Headers *http.Header
}

func (getDataPathBackendSpectraS3Response *GetDataPathBackendSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPathBackendSpectraS3Response.DataPathBackend)
}

func NewGetDataPathBackendSpectraS3Response(webResponse WebResponse) (*GetDataPathBackendSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPathBackendSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPersistenceRuleSpectraS3Request struct {
    DataPersistenceRuleId string
}

func NewGetDataPersistenceRuleSpectraS3Request(dataPersistenceRuleId string) *GetDataPersistenceRuleSpectraS3Request {
    return &GetDataPersistenceRuleSpectraS3Request{
        DataPersistenceRuleId: dataPersistenceRuleId,
    }
}

type GetDataPersistenceRuleSpectraS3Response struct {
    DataPersistenceRule DataPersistenceRule
    Headers *http.Header
}

func (getDataPersistenceRuleSpectraS3Response *GetDataPersistenceRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPersistenceRuleSpectraS3Response.DataPersistenceRule)
}

func NewGetDataPersistenceRuleSpectraS3Response(webResponse WebResponse) (*GetDataPersistenceRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPersistenceRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPersistenceRulesSpectraS3Request struct {
    DataPersistenceRuleType DataPersistenceRuleType
    DataPolicyId *string
    IsolationLevel DataIsolationLevel
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    State DataPlacementRuleState
    StorageDomainId *string
}

func NewGetDataPersistenceRulesSpectraS3Request() *GetDataPersistenceRulesSpectraS3Request {
    return &GetDataPersistenceRulesSpectraS3Request{
    }
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithIsolationLevel(isolationLevel DataIsolationLevel) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.IsolationLevel = isolationLevel
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithLastPage() *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.LastPage = true
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithPageLength(pageLength int) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.PageLength = &pageLength
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.PageOffset = &pageOffset
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.State = state
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.StorageDomainId = &storageDomainId
    return getDataPersistenceRulesSpectraS3Request
}

func (getDataPersistenceRulesSpectraS3Request *GetDataPersistenceRulesSpectraS3Request) WithDataPersistenceRuleType(dataPersistenceRuleType DataPersistenceRuleType) *GetDataPersistenceRulesSpectraS3Request {
    getDataPersistenceRulesSpectraS3Request.DataPersistenceRuleType = dataPersistenceRuleType
    return getDataPersistenceRulesSpectraS3Request
}

type GetDataPersistenceRulesSpectraS3Response struct {
    DataPersistenceRuleList DataPersistenceRuleList
    Headers *http.Header
}

func (getDataPersistenceRulesSpectraS3Response *GetDataPersistenceRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPersistenceRulesSpectraS3Response.DataPersistenceRuleList)
}

func NewGetDataPersistenceRulesSpectraS3Response(webResponse WebResponse) (*GetDataPersistenceRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPersistenceRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPlannerBlobStoreTasksSpectraS3Request struct {
    FullDetails bool
}

func NewGetDataPlannerBlobStoreTasksSpectraS3Request() *GetDataPlannerBlobStoreTasksSpectraS3Request {
    return &GetDataPlannerBlobStoreTasksSpectraS3Request{
    }
}

func (getDataPlannerBlobStoreTasksSpectraS3Request *GetDataPlannerBlobStoreTasksSpectraS3Request) WithFullDetails() *GetDataPlannerBlobStoreTasksSpectraS3Request {
    getDataPlannerBlobStoreTasksSpectraS3Request.FullDetails = true
    return getDataPlannerBlobStoreTasksSpectraS3Request
}

type GetDataPlannerBlobStoreTasksSpectraS3Response struct {
    BlobStoreTasksInformation BlobStoreTasksInformation
    Headers *http.Header
}

func (getDataPlannerBlobStoreTasksSpectraS3Response *GetDataPlannerBlobStoreTasksSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPlannerBlobStoreTasksSpectraS3Response.BlobStoreTasksInformation)
}

func NewGetDataPlannerBlobStoreTasksSpectraS3Response(webResponse WebResponse) (*GetDataPlannerBlobStoreTasksSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPlannerBlobStoreTasksSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPoliciesSpectraS3Request struct {
    AlwaysForcePutJobCreation *bool
    AlwaysMinimizeSpanningAcrossMedia *bool
    ChecksumType ChecksumType
    EndToEndCrcRequired *bool
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetDataPoliciesSpectraS3Request() *GetDataPoliciesSpectraS3Request {
    return &GetDataPoliciesSpectraS3Request{
    }
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithAlwaysForcePutJobCreation(alwaysForcePutJobCreation bool) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.AlwaysForcePutJobCreation = &alwaysForcePutJobCreation
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithAlwaysMinimizeSpanningAcrossMedia(alwaysMinimizeSpanningAcrossMedia bool) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.AlwaysMinimizeSpanningAcrossMedia = &alwaysMinimizeSpanningAcrossMedia
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithChecksumType(checksumType ChecksumType) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.ChecksumType = checksumType
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithEndToEndCrcRequired(endToEndCrcRequired bool) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.EndToEndCrcRequired = &endToEndCrcRequired
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithLastPage() *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.LastPage = true
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithName(name string) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.Name = &name
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithPageLength(pageLength int) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.PageLength = &pageLength
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithPageOffset(pageOffset int) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.PageOffset = &pageOffset
    return getDataPoliciesSpectraS3Request
}

func (getDataPoliciesSpectraS3Request *GetDataPoliciesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDataPoliciesSpectraS3Request {
    getDataPoliciesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDataPoliciesSpectraS3Request
}

type GetDataPoliciesSpectraS3Response struct {
    DataPolicyList DataPolicyList
    Headers *http.Header
}

func (getDataPoliciesSpectraS3Response *GetDataPoliciesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPoliciesSpectraS3Response.DataPolicyList)
}

func NewGetDataPoliciesSpectraS3Response(webResponse WebResponse) (*GetDataPoliciesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPoliciesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPolicyAclSpectraS3Request struct {
    DataPolicyAcl string
}

func NewGetDataPolicyAclSpectraS3Request(dataPolicyAcl string) *GetDataPolicyAclSpectraS3Request {
    return &GetDataPolicyAclSpectraS3Request{
        DataPolicyAcl: dataPolicyAcl,
    }
}

type GetDataPolicyAclSpectraS3Response struct {
    DataPolicyAcl DataPolicyAcl
    Headers *http.Header
}

func (getDataPolicyAclSpectraS3Response *GetDataPolicyAclSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPolicyAclSpectraS3Response.DataPolicyAcl)
}

func NewGetDataPolicyAclSpectraS3Response(webResponse WebResponse) (*GetDataPolicyAclSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPolicyAclSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPolicyAclsSpectraS3Request struct {
    DataPolicyId *string
    GroupId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetDataPolicyAclsSpectraS3Request() *GetDataPolicyAclsSpectraS3Request {
    return &GetDataPolicyAclsSpectraS3Request{
    }
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithGroupId(groupId string) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.GroupId = &groupId
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithLastPage() *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.LastPage = true
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithPageLength(pageLength int) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.PageLength = &pageLength
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithPageOffset(pageOffset int) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.PageOffset = &pageOffset
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDataPolicyAclsSpectraS3Request
}

func (getDataPolicyAclsSpectraS3Request *GetDataPolicyAclsSpectraS3Request) WithUserId(userId string) *GetDataPolicyAclsSpectraS3Request {
    getDataPolicyAclsSpectraS3Request.UserId = &userId
    return getDataPolicyAclsSpectraS3Request
}

type GetDataPolicyAclsSpectraS3Response struct {
    DataPolicyAclList DataPolicyAclList
    Headers *http.Header
}

func (getDataPolicyAclsSpectraS3Response *GetDataPolicyAclsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPolicyAclsSpectraS3Response.DataPolicyAclList)
}

func NewGetDataPolicyAclsSpectraS3Response(webResponse WebResponse) (*GetDataPolicyAclsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPolicyAclsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDataPolicySpectraS3Request struct {
    DataPolicyId string
}

func NewGetDataPolicySpectraS3Request(dataPolicyId string) *GetDataPolicySpectraS3Request {
    return &GetDataPolicySpectraS3Request{
        DataPolicyId: dataPolicyId,
    }
}

type GetDataPolicySpectraS3Response struct {
    DataPolicy DataPolicy
    Headers *http.Header
}

func (getDataPolicySpectraS3Response *GetDataPolicySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDataPolicySpectraS3Response.DataPolicy)
}

func NewGetDataPolicySpectraS3Response(webResponse WebResponse) (*GetDataPolicySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDataPolicySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedAzureDataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    State DataPlacementRuleState
    TargetId *string
}

func NewGetDegradedAzureDataReplicationRulesSpectraS3Request() *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    return &GetDegradedAzureDataReplicationRulesSpectraS3Request{
    }
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithLastPage() *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.LastPage = true
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.State = state
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

func (getDegradedAzureDataReplicationRulesSpectraS3Request *GetDegradedAzureDataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetDegradedAzureDataReplicationRulesSpectraS3Request {
    getDegradedAzureDataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getDegradedAzureDataReplicationRulesSpectraS3Request
}

type GetDegradedAzureDataReplicationRulesSpectraS3Response struct {
    AzureDataReplicationRuleList AzureDataReplicationRuleList
    Headers *http.Header
}

func (getDegradedAzureDataReplicationRulesSpectraS3Response *GetDegradedAzureDataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedAzureDataReplicationRulesSpectraS3Response.AzureDataReplicationRuleList)
}

func NewGetDegradedAzureDataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetDegradedAzureDataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedAzureDataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedBlobsSpectraS3Request struct {
    BlobId *string
    BucketId *string
    Ds3ReplicationRuleId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PersistenceRuleId *string
}

func NewGetDegradedBlobsSpectraS3Request() *GetDegradedBlobsSpectraS3Request {
    return &GetDegradedBlobsSpectraS3Request{
    }
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithBlobId(blobId string) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.BlobId = &blobId
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithBucketId(bucketId string) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.BucketId = &bucketId
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithDs3ReplicationRuleId(ds3ReplicationRuleId string) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.Ds3ReplicationRuleId = &ds3ReplicationRuleId
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithLastPage() *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.LastPage = true
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithPageLength(pageLength int) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.PageLength = &pageLength
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.PageOffset = &pageOffset
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedBlobsSpectraS3Request
}

func (getDegradedBlobsSpectraS3Request *GetDegradedBlobsSpectraS3Request) WithPersistenceRuleId(persistenceRuleId string) *GetDegradedBlobsSpectraS3Request {
    getDegradedBlobsSpectraS3Request.PersistenceRuleId = &persistenceRuleId
    return getDegradedBlobsSpectraS3Request
}

type GetDegradedBlobsSpectraS3Response struct {
    DegradedBlobList DegradedBlobList
    Headers *http.Header
}

func (getDegradedBlobsSpectraS3Response *GetDegradedBlobsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedBlobsSpectraS3Response.DegradedBlobList)
}

func NewGetDegradedBlobsSpectraS3Response(webResponse WebResponse) (*GetDegradedBlobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedBlobsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedBucketsSpectraS3Request struct {
    DataPolicyId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetDegradedBucketsSpectraS3Request() *GetDegradedBucketsSpectraS3Request {
    return &GetDegradedBucketsSpectraS3Request{
    }
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithLastPage() *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.LastPage = true
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithName(name string) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.Name = &name
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithPageLength(pageLength int) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.PageLength = &pageLength
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.PageOffset = &pageOffset
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedBucketsSpectraS3Request
}

func (getDegradedBucketsSpectraS3Request *GetDegradedBucketsSpectraS3Request) WithUserId(userId string) *GetDegradedBucketsSpectraS3Request {
    getDegradedBucketsSpectraS3Request.UserId = &userId
    return getDegradedBucketsSpectraS3Request
}

type GetDegradedBucketsSpectraS3Response struct {
    BucketList BucketList
    Headers *http.Header
}

func (getDegradedBucketsSpectraS3Response *GetDegradedBucketsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedBucketsSpectraS3Response.BucketList)
}

func NewGetDegradedBucketsSpectraS3Response(webResponse WebResponse) (*GetDegradedBucketsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedBucketsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedDataPersistenceRulesSpectraS3Request struct {
    DataPersistenceRuleType DataPersistenceRuleType
    DataPolicyId *string
    IsolationLevel DataIsolationLevel
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    State DataPlacementRuleState
    StorageDomainId *string
}

func NewGetDegradedDataPersistenceRulesSpectraS3Request() *GetDegradedDataPersistenceRulesSpectraS3Request {
    return &GetDegradedDataPersistenceRulesSpectraS3Request{
    }
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithIsolationLevel(isolationLevel DataIsolationLevel) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.IsolationLevel = isolationLevel
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithLastPage() *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.LastPage = true
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithPageLength(pageLength int) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.PageLength = &pageLength
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.PageOffset = &pageOffset
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.State = state
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.StorageDomainId = &storageDomainId
    return getDegradedDataPersistenceRulesSpectraS3Request
}

func (getDegradedDataPersistenceRulesSpectraS3Request *GetDegradedDataPersistenceRulesSpectraS3Request) WithDataPersistenceRuleType(dataPersistenceRuleType DataPersistenceRuleType) *GetDegradedDataPersistenceRulesSpectraS3Request {
    getDegradedDataPersistenceRulesSpectraS3Request.DataPersistenceRuleType = dataPersistenceRuleType
    return getDegradedDataPersistenceRulesSpectraS3Request
}

type GetDegradedDataPersistenceRulesSpectraS3Response struct {
    DataPersistenceRuleList DataPersistenceRuleList
    Headers *http.Header
}

func (getDegradedDataPersistenceRulesSpectraS3Response *GetDegradedDataPersistenceRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedDataPersistenceRulesSpectraS3Response.DataPersistenceRuleList)
}

func NewGetDegradedDataPersistenceRulesSpectraS3Response(webResponse WebResponse) (*GetDegradedDataPersistenceRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedDataPersistenceRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedDs3DataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    State DataPlacementRuleState
    TargetId *string
}

func NewGetDegradedDs3DataReplicationRulesSpectraS3Request() *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    return &GetDegradedDs3DataReplicationRulesSpectraS3Request{
    }
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithLastPage() *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.LastPage = true
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.State = state
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

func (getDegradedDs3DataReplicationRulesSpectraS3Request *GetDegradedDs3DataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetDegradedDs3DataReplicationRulesSpectraS3Request {
    getDegradedDs3DataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getDegradedDs3DataReplicationRulesSpectraS3Request
}

type GetDegradedDs3DataReplicationRulesSpectraS3Response struct {
    Ds3DataReplicationRuleList Ds3DataReplicationRuleList
    Headers *http.Header
}

func (getDegradedDs3DataReplicationRulesSpectraS3Response *GetDegradedDs3DataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedDs3DataReplicationRulesSpectraS3Response.Ds3DataReplicationRuleList)
}

func NewGetDegradedDs3DataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetDegradedDs3DataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedDs3DataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDegradedS3DataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    State DataPlacementRuleState
    TargetId *string
}

func NewGetDegradedS3DataReplicationRulesSpectraS3Request() *GetDegradedS3DataReplicationRulesSpectraS3Request {
    return &GetDegradedS3DataReplicationRulesSpectraS3Request{
    }
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithLastPage() *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.LastPage = true
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.State = state
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

func (getDegradedS3DataReplicationRulesSpectraS3Request *GetDegradedS3DataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetDegradedS3DataReplicationRulesSpectraS3Request {
    getDegradedS3DataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getDegradedS3DataReplicationRulesSpectraS3Request
}

type GetDegradedS3DataReplicationRulesSpectraS3Response struct {
    S3DataReplicationRuleList S3DataReplicationRuleList
    Headers *http.Header
}

func (getDegradedS3DataReplicationRulesSpectraS3Response *GetDegradedS3DataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDegradedS3DataReplicationRulesSpectraS3Response.S3DataReplicationRuleList)
}

func NewGetDegradedS3DataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetDegradedS3DataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDegradedS3DataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3DataReplicationRuleSpectraS3Request struct {
    Ds3DataReplicationRule string
}

func NewGetDs3DataReplicationRuleSpectraS3Request(ds3DataReplicationRule string) *GetDs3DataReplicationRuleSpectraS3Request {
    return &GetDs3DataReplicationRuleSpectraS3Request{
        Ds3DataReplicationRule: ds3DataReplicationRule,
    }
}

type GetDs3DataReplicationRuleSpectraS3Response struct {
    Ds3DataReplicationRule Ds3DataReplicationRule
    Headers *http.Header
}

func (getDs3DataReplicationRuleSpectraS3Response *GetDs3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3DataReplicationRuleSpectraS3Response.Ds3DataReplicationRule)
}

func NewGetDs3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*GetDs3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3DataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReplicateDeletes *bool
    State DataPlacementRuleState
    TargetId *string
}

func NewGetDs3DataReplicationRulesSpectraS3Request() *GetDs3DataReplicationRulesSpectraS3Request {
    return &GetDs3DataReplicationRulesSpectraS3Request{
    }
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithLastPage() *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.LastPage = true
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.State = state
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getDs3DataReplicationRulesSpectraS3Request
}

func (getDs3DataReplicationRulesSpectraS3Request *GetDs3DataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetDs3DataReplicationRulesSpectraS3Request {
    getDs3DataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getDs3DataReplicationRulesSpectraS3Request
}

type GetDs3DataReplicationRulesSpectraS3Response struct {
    Ds3DataReplicationRuleList Ds3DataReplicationRuleList
    Headers *http.Header
}

func (getDs3DataReplicationRulesSpectraS3Response *GetDs3DataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3DataReplicationRulesSpectraS3Response.Ds3DataReplicationRuleList)
}

func NewGetDs3DataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetDs3DataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3DataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetDataPoliciesSpectraS3Request struct {
    Ds3TargetDataPolicies string
}

func NewGetDs3TargetDataPoliciesSpectraS3Request(ds3TargetDataPolicies string) *GetDs3TargetDataPoliciesSpectraS3Request {
    return &GetDs3TargetDataPoliciesSpectraS3Request{
        Ds3TargetDataPolicies: ds3TargetDataPolicies,
    }
}

type GetDs3TargetDataPoliciesSpectraS3Response struct {
    DataPolicyList DataPolicyList
    Headers *http.Header
}

func (getDs3TargetDataPoliciesSpectraS3Response *GetDs3TargetDataPoliciesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetDataPoliciesSpectraS3Response.DataPolicyList)
}

func NewGetDs3TargetDataPoliciesSpectraS3Response(webResponse WebResponse) (*GetDs3TargetDataPoliciesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetDataPoliciesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetDs3TargetFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetDs3TargetFailureNotificationRegistrationSpectraS3Request {
    return &GetDs3TargetFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetDs3TargetFailureNotificationRegistrationSpectraS3Response struct {
    Ds3TargetFailureNotificationRegistration Ds3TargetFailureNotificationRegistration
    Headers *http.Header
}

func (getDs3TargetFailureNotificationRegistrationSpectraS3Response *GetDs3TargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetFailureNotificationRegistrationSpectraS3Response.Ds3TargetFailureNotificationRegistration)
}

func NewGetDs3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetDs3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetDs3TargetFailureNotificationRegistrationsSpectraS3Request() *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    return &GetDs3TargetFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Request *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    getDs3TargetFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getDs3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Request *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    getDs3TargetFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getDs3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Request *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    getDs3TargetFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getDs3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Request *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    getDs3TargetFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDs3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Request *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetDs3TargetFailureNotificationRegistrationsSpectraS3Request {
    getDs3TargetFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getDs3TargetFailureNotificationRegistrationsSpectraS3Request
}

type GetDs3TargetFailureNotificationRegistrationsSpectraS3Response struct {
    Ds3TargetFailureNotificationRegistrationList Ds3TargetFailureNotificationRegistrationList
    Headers *http.Header
}

func (getDs3TargetFailureNotificationRegistrationsSpectraS3Response *GetDs3TargetFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetFailureNotificationRegistrationsSpectraS3Response.Ds3TargetFailureNotificationRegistrationList)
}

func NewGetDs3TargetFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetDs3TargetFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetFailureType TargetFailureType
    TargetId *string
}

func NewGetDs3TargetFailuresSpectraS3Request() *GetDs3TargetFailuresSpectraS3Request {
    return &GetDs3TargetFailuresSpectraS3Request{
    }
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithLastPage() *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.LastPage = true
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithPageLength(pageLength int) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.PageLength = &pageLength
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.PageOffset = &pageOffset
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithTargetId(targetId string) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.TargetId = &targetId
    return getDs3TargetFailuresSpectraS3Request
}

func (getDs3TargetFailuresSpectraS3Request *GetDs3TargetFailuresSpectraS3Request) WithTargetFailureType(targetFailureType TargetFailureType) *GetDs3TargetFailuresSpectraS3Request {
    getDs3TargetFailuresSpectraS3Request.TargetFailureType = targetFailureType
    return getDs3TargetFailuresSpectraS3Request
}

type GetDs3TargetFailuresSpectraS3Response struct {
    Ds3TargetFailureList Ds3TargetFailureList
    Headers *http.Header
}

func (getDs3TargetFailuresSpectraS3Response *GetDs3TargetFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetFailuresSpectraS3Response.Ds3TargetFailureList)
}

func NewGetDs3TargetFailuresSpectraS3Response(webResponse WebResponse) (*GetDs3TargetFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetReadPreferenceSpectraS3Request struct {
    Ds3TargetReadPreference string
}

func NewGetDs3TargetReadPreferenceSpectraS3Request(ds3TargetReadPreference string) *GetDs3TargetReadPreferenceSpectraS3Request {
    return &GetDs3TargetReadPreferenceSpectraS3Request{
        Ds3TargetReadPreference: ds3TargetReadPreference,
    }
}

type GetDs3TargetReadPreferenceSpectraS3Response struct {
    Ds3TargetReadPreference Ds3TargetReadPreference
    Headers *http.Header
}

func (getDs3TargetReadPreferenceSpectraS3Response *GetDs3TargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetReadPreferenceSpectraS3Response.Ds3TargetReadPreference)
}

func NewGetDs3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*GetDs3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetReadPreferencesSpectraS3Request struct {
    BucketId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReadPreference TargetReadPreferenceType
    TargetId *string
}

func NewGetDs3TargetReadPreferencesSpectraS3Request() *GetDs3TargetReadPreferencesSpectraS3Request {
    return &GetDs3TargetReadPreferencesSpectraS3Request{
    }
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithBucketId(bucketId string) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.BucketId = &bucketId
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithLastPage() *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.LastPage = true
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithPageLength(pageLength int) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.PageLength = &pageLength
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithPageOffset(pageOffset int) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.PageOffset = &pageOffset
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithReadPreference(readPreference TargetReadPreferenceType) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.ReadPreference = readPreference
    return getDs3TargetReadPreferencesSpectraS3Request
}

func (getDs3TargetReadPreferencesSpectraS3Request *GetDs3TargetReadPreferencesSpectraS3Request) WithTargetId(targetId string) *GetDs3TargetReadPreferencesSpectraS3Request {
    getDs3TargetReadPreferencesSpectraS3Request.TargetId = &targetId
    return getDs3TargetReadPreferencesSpectraS3Request
}

type GetDs3TargetReadPreferencesSpectraS3Response struct {
    Ds3TargetReadPreferenceList Ds3TargetReadPreferenceList
    Headers *http.Header
}

func (getDs3TargetReadPreferencesSpectraS3Response *GetDs3TargetReadPreferencesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetReadPreferencesSpectraS3Response.Ds3TargetReadPreferenceList)
}

func NewGetDs3TargetReadPreferencesSpectraS3Response(webResponse WebResponse) (*GetDs3TargetReadPreferencesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetReadPreferencesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetSpectraS3Request struct {
    Ds3Target string
}

func NewGetDs3TargetSpectraS3Request(ds3Target string) *GetDs3TargetSpectraS3Request {
    return &GetDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

type GetDs3TargetSpectraS3Response struct {
    Ds3Target Ds3Target
    Headers *http.Header
}

func (getDs3TargetSpectraS3Response *GetDs3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetSpectraS3Response.Ds3Target)
}

func NewGetDs3TargetSpectraS3Response(webResponse WebResponse) (*GetDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetDs3TargetsSpectraS3Request struct {
    AdminAuthId *string
    DataPathEndPoint *string
    DataPathHttps *bool
    DataPathPort *int
    DataPathProxy *string
    DataPathVerifyCertificate *bool
    DefaultReadPreference TargetReadPreferenceType
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PermitGoingOutOfSync *bool
    Quiesced Quiesced
    State TargetState
}

func NewGetDs3TargetsSpectraS3Request() *GetDs3TargetsSpectraS3Request {
    return &GetDs3TargetsSpectraS3Request{
    }
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithAdminAuthId(adminAuthId string) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.AdminAuthId = &adminAuthId
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDataPathHttps(dataPathHttps bool) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DataPathHttps = &dataPathHttps
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDataPathPort(dataPathPort int) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DataPathPort = &dataPathPort
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDataPathProxy(dataPathProxy string) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DataPathProxy = &dataPathProxy
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDataPathVerifyCertificate(dataPathVerifyCertificate bool) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DataPathVerifyCertificate = &dataPathVerifyCertificate
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithLastPage() *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.LastPage = true
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithName(name string) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.Name = &name
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithPageLength(pageLength int) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.PageLength = &pageLength
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.PageOffset = &pageOffset
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithQuiesced(quiesced Quiesced) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.Quiesced = quiesced
    return getDs3TargetsSpectraS3Request
}

func (getDs3TargetsSpectraS3Request *GetDs3TargetsSpectraS3Request) WithState(state TargetState) *GetDs3TargetsSpectraS3Request {
    getDs3TargetsSpectraS3Request.State = state
    return getDs3TargetsSpectraS3Request
}

type GetDs3TargetsSpectraS3Response struct {
    Ds3TargetList Ds3TargetList
    Headers *http.Header
}

func (getDs3TargetsSpectraS3Response *GetDs3TargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getDs3TargetsSpectraS3Response.Ds3TargetList)
}

func NewGetDs3TargetsSpectraS3Response(webResponse WebResponse) (*GetDs3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetDs3TargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetFeatureKeysSpectraS3Request struct {
    ErrorMessage *string
    ExpirationDate *string
    Key FeatureKeyType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetFeatureKeysSpectraS3Request() *GetFeatureKeysSpectraS3Request {
    return &GetFeatureKeysSpectraS3Request{
    }
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithErrorMessage(errorMessage string) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.ErrorMessage = &errorMessage
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithExpirationDate(expirationDate string) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.ExpirationDate = &expirationDate
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithKey(key FeatureKeyType) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.Key = key
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithLastPage() *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.LastPage = true
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithPageLength(pageLength int) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.PageLength = &pageLength
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithPageOffset(pageOffset int) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.PageOffset = &pageOffset
    return getFeatureKeysSpectraS3Request
}

func (getFeatureKeysSpectraS3Request *GetFeatureKeysSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetFeatureKeysSpectraS3Request {
    getFeatureKeysSpectraS3Request.PageStartMarker = &pageStartMarker
    return getFeatureKeysSpectraS3Request
}

type GetFeatureKeysSpectraS3Response struct {
    FeatureKeyList FeatureKeyList
    Headers *http.Header
}

func (getFeatureKeysSpectraS3Response *GetFeatureKeysSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getFeatureKeysSpectraS3Response.FeatureKeyList)
}

func NewGetFeatureKeysSpectraS3Response(webResponse WebResponse) (*GetFeatureKeysSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetFeatureKeysSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetGroupMemberSpectraS3Request struct {
    GroupMember string
}

func NewGetGroupMemberSpectraS3Request(groupMember string) *GetGroupMemberSpectraS3Request {
    return &GetGroupMemberSpectraS3Request{
        GroupMember: groupMember,
    }
}

type GetGroupMemberSpectraS3Response struct {
    GroupMember GroupMember
    Headers *http.Header
}

func (getGroupMemberSpectraS3Response *GetGroupMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getGroupMemberSpectraS3Response.GroupMember)
}

func NewGetGroupMemberSpectraS3Response(webResponse WebResponse) (*GetGroupMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetGroupMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetGroupMembersSpectraS3Request struct {
    GroupId *string
    LastPage bool
    MemberGroupId *string
    MemberUserId *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetGroupMembersSpectraS3Request() *GetGroupMembersSpectraS3Request {
    return &GetGroupMembersSpectraS3Request{
    }
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithGroupId(groupId string) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.GroupId = &groupId
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithLastPage() *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.LastPage = true
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithMemberGroupId(memberGroupId string) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.MemberGroupId = &memberGroupId
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithMemberUserId(memberUserId string) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.MemberUserId = &memberUserId
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithPageLength(pageLength int) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.PageLength = &pageLength
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithPageOffset(pageOffset int) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.PageOffset = &pageOffset
    return getGroupMembersSpectraS3Request
}

func (getGroupMembersSpectraS3Request *GetGroupMembersSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetGroupMembersSpectraS3Request {
    getGroupMembersSpectraS3Request.PageStartMarker = &pageStartMarker
    return getGroupMembersSpectraS3Request
}

type GetGroupMembersSpectraS3Response struct {
    GroupMemberList GroupMemberList
    Headers *http.Header
}

func (getGroupMembersSpectraS3Response *GetGroupMembersSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getGroupMembersSpectraS3Response.GroupMemberList)
}

func NewGetGroupMembersSpectraS3Response(webResponse WebResponse) (*GetGroupMembersSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetGroupMembersSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetGroupSpectraS3Request struct {
    Group string
}

func NewGetGroupSpectraS3Request(group string) *GetGroupSpectraS3Request {
    return &GetGroupSpectraS3Request{
        Group: group,
    }
}

type GetGroupSpectraS3Response struct {
    Group Group
    Headers *http.Header
}

func (getGroupSpectraS3Response *GetGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getGroupSpectraS3Response.Group)
}

func NewGetGroupSpectraS3Response(webResponse WebResponse) (*GetGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetGroupsSpectraS3Request struct {
    BuiltIn *bool
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetGroupsSpectraS3Request() *GetGroupsSpectraS3Request {
    return &GetGroupsSpectraS3Request{
    }
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithBuiltIn(builtIn bool) *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.BuiltIn = &builtIn
    return getGroupsSpectraS3Request
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithLastPage() *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.LastPage = true
    return getGroupsSpectraS3Request
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithName(name string) *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.Name = &name
    return getGroupsSpectraS3Request
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithPageLength(pageLength int) *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.PageLength = &pageLength
    return getGroupsSpectraS3Request
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithPageOffset(pageOffset int) *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.PageOffset = &pageOffset
    return getGroupsSpectraS3Request
}

func (getGroupsSpectraS3Request *GetGroupsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetGroupsSpectraS3Request {
    getGroupsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getGroupsSpectraS3Request
}

type GetGroupsSpectraS3Response struct {
    GroupList GroupList
    Headers *http.Header
}

func (getGroupsSpectraS3Response *GetGroupsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getGroupsSpectraS3Response.GroupList)
}

func NewGetGroupsSpectraS3Response(webResponse WebResponse) (*GetGroupsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetGroupsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobChunkDaoSpectraS3Request struct {
    JobChunkDao string
}

func NewGetJobChunkDaoSpectraS3Request(jobChunkDao string) *GetJobChunkDaoSpectraS3Request {
    return &GetJobChunkDaoSpectraS3Request{
        JobChunkDao: jobChunkDao,
    }
}

type GetJobChunkDaoSpectraS3Response struct {
    JobChunk JobChunk
    Headers *http.Header
}

func (getJobChunkDaoSpectraS3Response *GetJobChunkDaoSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobChunkDaoSpectraS3Response.JobChunk)
}

func NewGetJobChunkDaoSpectraS3Response(webResponse WebResponse) (*GetJobChunkDaoSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobChunkDaoSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobChunkSpectraS3Request struct {
    JobChunkId string
}

func NewGetJobChunkSpectraS3Request(jobChunkId string) *GetJobChunkSpectraS3Request {
    return &GetJobChunkSpectraS3Request{
        JobChunkId: jobChunkId,
    }
}

type GetJobChunkSpectraS3Response struct {
    Objects Objects
    Headers *http.Header
}

func (getJobChunkSpectraS3Response *GetJobChunkSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobChunkSpectraS3Response.Objects)
}

func NewGetJobChunkSpectraS3Response(webResponse WebResponse) (*GetJobChunkSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobChunkSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobChunksReadyForClientProcessingSpectraS3Request struct {
    Job string
    JobChunk *string
    PreferredNumberOfChunks *int
}

func NewGetJobChunksReadyForClientProcessingSpectraS3Request(job string) *GetJobChunksReadyForClientProcessingSpectraS3Request {
    return &GetJobChunksReadyForClientProcessingSpectraS3Request{
        Job: job,
    }
}

func (getJobChunksReadyForClientProcessingSpectraS3Request *GetJobChunksReadyForClientProcessingSpectraS3Request) WithJobChunk(jobChunk string) *GetJobChunksReadyForClientProcessingSpectraS3Request {
    getJobChunksReadyForClientProcessingSpectraS3Request.JobChunk = &jobChunk
    return getJobChunksReadyForClientProcessingSpectraS3Request
}

func (getJobChunksReadyForClientProcessingSpectraS3Request *GetJobChunksReadyForClientProcessingSpectraS3Request) WithPreferredNumberOfChunks(preferredNumberOfChunks int) *GetJobChunksReadyForClientProcessingSpectraS3Request {
    getJobChunksReadyForClientProcessingSpectraS3Request.PreferredNumberOfChunks = &preferredNumberOfChunks
    return getJobChunksReadyForClientProcessingSpectraS3Request
}

type GetJobChunksReadyForClientProcessingSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (getJobChunksReadyForClientProcessingSpectraS3Response *GetJobChunksReadyForClientProcessingSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobChunksReadyForClientProcessingSpectraS3Response.MasterObjectList)
}

func NewGetJobChunksReadyForClientProcessingSpectraS3Response(webResponse WebResponse) (*GetJobChunksReadyForClientProcessingSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobChunksReadyForClientProcessingSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCompletedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetJobCompletedNotificationRegistrationSpectraS3Request(notificationId string) *GetJobCompletedNotificationRegistrationSpectraS3Request {
    return &GetJobCompletedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetJobCompletedNotificationRegistrationSpectraS3Response struct {
    JobCompletedNotificationRegistration JobCompletedNotificationRegistration
    Headers *http.Header
}

func (getJobCompletedNotificationRegistrationSpectraS3Response *GetJobCompletedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCompletedNotificationRegistrationSpectraS3Response.JobCompletedNotificationRegistration)
}

func NewGetJobCompletedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetJobCompletedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCompletedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCompletedNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetJobCompletedNotificationRegistrationsSpectraS3Request() *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    return &GetJobCompletedNotificationRegistrationsSpectraS3Request{
    }
}

func (getJobCompletedNotificationRegistrationsSpectraS3Request *GetJobCompletedNotificationRegistrationsSpectraS3Request) WithLastPage() *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    getJobCompletedNotificationRegistrationsSpectraS3Request.LastPage = true
    return getJobCompletedNotificationRegistrationsSpectraS3Request
}

func (getJobCompletedNotificationRegistrationsSpectraS3Request *GetJobCompletedNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    getJobCompletedNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getJobCompletedNotificationRegistrationsSpectraS3Request
}

func (getJobCompletedNotificationRegistrationsSpectraS3Request *GetJobCompletedNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    getJobCompletedNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getJobCompletedNotificationRegistrationsSpectraS3Request
}

func (getJobCompletedNotificationRegistrationsSpectraS3Request *GetJobCompletedNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    getJobCompletedNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getJobCompletedNotificationRegistrationsSpectraS3Request
}

func (getJobCompletedNotificationRegistrationsSpectraS3Request *GetJobCompletedNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetJobCompletedNotificationRegistrationsSpectraS3Request {
    getJobCompletedNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getJobCompletedNotificationRegistrationsSpectraS3Request
}

type GetJobCompletedNotificationRegistrationsSpectraS3Response struct {
    JobCompletedNotificationRegistrationList JobCompletedNotificationRegistrationList
    Headers *http.Header
}

func (getJobCompletedNotificationRegistrationsSpectraS3Response *GetJobCompletedNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCompletedNotificationRegistrationsSpectraS3Response.JobCompletedNotificationRegistrationList)
}

func NewGetJobCompletedNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetJobCompletedNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCompletedNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCreatedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetJobCreatedNotificationRegistrationSpectraS3Request(notificationId string) *GetJobCreatedNotificationRegistrationSpectraS3Request {
    return &GetJobCreatedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetJobCreatedNotificationRegistrationSpectraS3Response struct {
    JobCreatedNotificationRegistration JobCreatedNotificationRegistration
    Headers *http.Header
}

func (getJobCreatedNotificationRegistrationSpectraS3Response *GetJobCreatedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCreatedNotificationRegistrationSpectraS3Response.JobCreatedNotificationRegistration)
}

func NewGetJobCreatedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetJobCreatedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCreatedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCreatedNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetJobCreatedNotificationRegistrationsSpectraS3Request() *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    return &GetJobCreatedNotificationRegistrationsSpectraS3Request{
    }
}

func (getJobCreatedNotificationRegistrationsSpectraS3Request *GetJobCreatedNotificationRegistrationsSpectraS3Request) WithLastPage() *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    getJobCreatedNotificationRegistrationsSpectraS3Request.LastPage = true
    return getJobCreatedNotificationRegistrationsSpectraS3Request
}

func (getJobCreatedNotificationRegistrationsSpectraS3Request *GetJobCreatedNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    getJobCreatedNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getJobCreatedNotificationRegistrationsSpectraS3Request
}

func (getJobCreatedNotificationRegistrationsSpectraS3Request *GetJobCreatedNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    getJobCreatedNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getJobCreatedNotificationRegistrationsSpectraS3Request
}

func (getJobCreatedNotificationRegistrationsSpectraS3Request *GetJobCreatedNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    getJobCreatedNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getJobCreatedNotificationRegistrationsSpectraS3Request
}

func (getJobCreatedNotificationRegistrationsSpectraS3Request *GetJobCreatedNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetJobCreatedNotificationRegistrationsSpectraS3Request {
    getJobCreatedNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getJobCreatedNotificationRegistrationsSpectraS3Request
}

type GetJobCreatedNotificationRegistrationsSpectraS3Response struct {
    JobCreatedNotificationRegistrationList JobCreatedNotificationRegistrationList
    Headers *http.Header
}

func (getJobCreatedNotificationRegistrationsSpectraS3Response *GetJobCreatedNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCreatedNotificationRegistrationsSpectraS3Response.JobCreatedNotificationRegistrationList)
}

func NewGetJobCreatedNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetJobCreatedNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCreatedNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCreationFailedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetJobCreationFailedNotificationRegistrationSpectraS3Request(notificationId string) *GetJobCreationFailedNotificationRegistrationSpectraS3Request {
    return &GetJobCreationFailedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetJobCreationFailedNotificationRegistrationSpectraS3Response struct {
    JobCreationFailedNotificationRegistration JobCreationFailedNotificationRegistration
    Headers *http.Header
}

func (getJobCreationFailedNotificationRegistrationSpectraS3Response *GetJobCreationFailedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCreationFailedNotificationRegistrationSpectraS3Response.JobCreationFailedNotificationRegistration)
}

func NewGetJobCreationFailedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetJobCreationFailedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCreationFailedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobCreationFailedNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetJobCreationFailedNotificationRegistrationsSpectraS3Request() *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    return &GetJobCreationFailedNotificationRegistrationsSpectraS3Request{
    }
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Request *GetJobCreationFailedNotificationRegistrationsSpectraS3Request) WithLastPage() *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    getJobCreationFailedNotificationRegistrationsSpectraS3Request.LastPage = true
    return getJobCreationFailedNotificationRegistrationsSpectraS3Request
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Request *GetJobCreationFailedNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    getJobCreationFailedNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getJobCreationFailedNotificationRegistrationsSpectraS3Request
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Request *GetJobCreationFailedNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    getJobCreationFailedNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getJobCreationFailedNotificationRegistrationsSpectraS3Request
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Request *GetJobCreationFailedNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    getJobCreationFailedNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getJobCreationFailedNotificationRegistrationsSpectraS3Request
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Request *GetJobCreationFailedNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetJobCreationFailedNotificationRegistrationsSpectraS3Request {
    getJobCreationFailedNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getJobCreationFailedNotificationRegistrationsSpectraS3Request
}

type GetJobCreationFailedNotificationRegistrationsSpectraS3Response struct {
    JobCreationFailedNotificationRegistrationList JobCreationFailedNotificationRegistrationList
    Headers *http.Header
}

func (getJobCreationFailedNotificationRegistrationsSpectraS3Response *GetJobCreationFailedNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobCreationFailedNotificationRegistrationsSpectraS3Response.JobCreationFailedNotificationRegistrationList)
}

func NewGetJobCreationFailedNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetJobCreationFailedNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobCreationFailedNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobSpectraS3Request struct {
    JobId string
}

func NewGetJobSpectraS3Request(jobId string) *GetJobSpectraS3Request {
    return &GetJobSpectraS3Request{
        JobId: jobId,
    }
}

type GetJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (getJobSpectraS3Response *GetJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobSpectraS3Response.MasterObjectList)
}

func NewGetJobSpectraS3Response(webResponse WebResponse) (*GetJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobToReplicateSpectraS3Request struct {
    JobId string
}

func NewGetJobToReplicateSpectraS3Request(jobId string) *GetJobToReplicateSpectraS3Request {
    return &GetJobToReplicateSpectraS3Request{
        JobId: jobId,
    }
}

type GetJobToReplicateSpectraS3Response struct {
    Content string
    Headers *http.Header
}



func NewGetJobToReplicateSpectraS3Response(webResponse WebResponse) (*GetJobToReplicateSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        content, err := getResponseBodyAsString(webResponse)
        if err != nil {
            return nil, err
        }
        return &GetJobToReplicateSpectraS3Response{Content: content, Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetJobsSpectraS3Request struct {
    BucketId *string
    FullDetails bool
}

func NewGetJobsSpectraS3Request() *GetJobsSpectraS3Request {
    return &GetJobsSpectraS3Request{
    }
}

func (getJobsSpectraS3Request *GetJobsSpectraS3Request) WithBucketId(bucketId string) *GetJobsSpectraS3Request {
    getJobsSpectraS3Request.BucketId = &bucketId
    return getJobsSpectraS3Request
}

func (getJobsSpectraS3Request *GetJobsSpectraS3Request) WithFullDetails() *GetJobsSpectraS3Request {
    getJobsSpectraS3Request.FullDetails = true
    return getJobsSpectraS3Request
}

type GetJobsSpectraS3Response struct {
    JobList JobList
    Headers *http.Header
}

func (getJobsSpectraS3Response *GetJobsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getJobsSpectraS3Response.JobList)
}

func NewGetJobsSpectraS3Response(webResponse WebResponse) (*GetJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetJobsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetNodeSpectraS3Request struct {
    Node string
}

func NewGetNodeSpectraS3Request(node string) *GetNodeSpectraS3Request {
    return &GetNodeSpectraS3Request{
        Node: node,
    }
}

type GetNodeSpectraS3Response struct {
    Node Node
    Headers *http.Header
}

func (getNodeSpectraS3Response *GetNodeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getNodeSpectraS3Response.Node)
}

func NewGetNodeSpectraS3Response(webResponse WebResponse) (*GetNodeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetNodeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetNodesSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetNodesSpectraS3Request() *GetNodesSpectraS3Request {
    return &GetNodesSpectraS3Request{
    }
}

func (getNodesSpectraS3Request *GetNodesSpectraS3Request) WithLastPage() *GetNodesSpectraS3Request {
    getNodesSpectraS3Request.LastPage = true
    return getNodesSpectraS3Request
}

func (getNodesSpectraS3Request *GetNodesSpectraS3Request) WithPageLength(pageLength int) *GetNodesSpectraS3Request {
    getNodesSpectraS3Request.PageLength = &pageLength
    return getNodesSpectraS3Request
}

func (getNodesSpectraS3Request *GetNodesSpectraS3Request) WithPageOffset(pageOffset int) *GetNodesSpectraS3Request {
    getNodesSpectraS3Request.PageOffset = &pageOffset
    return getNodesSpectraS3Request
}

func (getNodesSpectraS3Request *GetNodesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetNodesSpectraS3Request {
    getNodesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getNodesSpectraS3Request
}

type GetNodesSpectraS3Response struct {
    NodeList NodeList
    Headers *http.Header
}

func (getNodesSpectraS3Response *GetNodesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getNodesSpectraS3Response.NodeList)
}

func NewGetNodesSpectraS3Response(webResponse WebResponse) (*GetNodesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetNodesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectCachedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetObjectCachedNotificationRegistrationSpectraS3Request(notificationId string) *GetObjectCachedNotificationRegistrationSpectraS3Request {
    return &GetObjectCachedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetObjectCachedNotificationRegistrationSpectraS3Response struct {
    S3ObjectCachedNotificationRegistration S3ObjectCachedNotificationRegistration
    Headers *http.Header
}

func (getObjectCachedNotificationRegistrationSpectraS3Response *GetObjectCachedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectCachedNotificationRegistrationSpectraS3Response.S3ObjectCachedNotificationRegistration)
}

func NewGetObjectCachedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetObjectCachedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectCachedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectCachedNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetObjectCachedNotificationRegistrationsSpectraS3Request() *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    return &GetObjectCachedNotificationRegistrationsSpectraS3Request{
    }
}

func (getObjectCachedNotificationRegistrationsSpectraS3Request *GetObjectCachedNotificationRegistrationsSpectraS3Request) WithLastPage() *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    getObjectCachedNotificationRegistrationsSpectraS3Request.LastPage = true
    return getObjectCachedNotificationRegistrationsSpectraS3Request
}

func (getObjectCachedNotificationRegistrationsSpectraS3Request *GetObjectCachedNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    getObjectCachedNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getObjectCachedNotificationRegistrationsSpectraS3Request
}

func (getObjectCachedNotificationRegistrationsSpectraS3Request *GetObjectCachedNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    getObjectCachedNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getObjectCachedNotificationRegistrationsSpectraS3Request
}

func (getObjectCachedNotificationRegistrationsSpectraS3Request *GetObjectCachedNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    getObjectCachedNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getObjectCachedNotificationRegistrationsSpectraS3Request
}

func (getObjectCachedNotificationRegistrationsSpectraS3Request *GetObjectCachedNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetObjectCachedNotificationRegistrationsSpectraS3Request {
    getObjectCachedNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getObjectCachedNotificationRegistrationsSpectraS3Request
}

type GetObjectCachedNotificationRegistrationsSpectraS3Response struct {
    S3ObjectCachedNotificationRegistrationList S3ObjectCachedNotificationRegistrationList
    Headers *http.Header
}

func (getObjectCachedNotificationRegistrationsSpectraS3Response *GetObjectCachedNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectCachedNotificationRegistrationsSpectraS3Response.S3ObjectCachedNotificationRegistrationList)
}

func NewGetObjectCachedNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetObjectCachedNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectCachedNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectDetailsSpectraS3Request struct {
    ObjectName string
    BucketId string
}

func NewGetObjectDetailsSpectraS3Request(objectName string, bucketId string) *GetObjectDetailsSpectraS3Request {
    return &GetObjectDetailsSpectraS3Request{
        ObjectName: objectName,
        BucketId: bucketId,
    }
}

type GetObjectDetailsSpectraS3Response struct {
    S3Object S3Object
    Headers *http.Header
}

func (getObjectDetailsSpectraS3Response *GetObjectDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectDetailsSpectraS3Response.S3Object)
}

func NewGetObjectDetailsSpectraS3Response(webResponse WebResponse) (*GetObjectDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectLostNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetObjectLostNotificationRegistrationSpectraS3Request(notificationId string) *GetObjectLostNotificationRegistrationSpectraS3Request {
    return &GetObjectLostNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetObjectLostNotificationRegistrationSpectraS3Response struct {
    S3ObjectLostNotificationRegistration S3ObjectLostNotificationRegistration
    Headers *http.Header
}

func (getObjectLostNotificationRegistrationSpectraS3Response *GetObjectLostNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectLostNotificationRegistrationSpectraS3Response.S3ObjectLostNotificationRegistration)
}

func NewGetObjectLostNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetObjectLostNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectLostNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectLostNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetObjectLostNotificationRegistrationsSpectraS3Request() *GetObjectLostNotificationRegistrationsSpectraS3Request {
    return &GetObjectLostNotificationRegistrationsSpectraS3Request{
    }
}

func (getObjectLostNotificationRegistrationsSpectraS3Request *GetObjectLostNotificationRegistrationsSpectraS3Request) WithLastPage() *GetObjectLostNotificationRegistrationsSpectraS3Request {
    getObjectLostNotificationRegistrationsSpectraS3Request.LastPage = true
    return getObjectLostNotificationRegistrationsSpectraS3Request
}

func (getObjectLostNotificationRegistrationsSpectraS3Request *GetObjectLostNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetObjectLostNotificationRegistrationsSpectraS3Request {
    getObjectLostNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getObjectLostNotificationRegistrationsSpectraS3Request
}

func (getObjectLostNotificationRegistrationsSpectraS3Request *GetObjectLostNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetObjectLostNotificationRegistrationsSpectraS3Request {
    getObjectLostNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getObjectLostNotificationRegistrationsSpectraS3Request
}

func (getObjectLostNotificationRegistrationsSpectraS3Request *GetObjectLostNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetObjectLostNotificationRegistrationsSpectraS3Request {
    getObjectLostNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getObjectLostNotificationRegistrationsSpectraS3Request
}

func (getObjectLostNotificationRegistrationsSpectraS3Request *GetObjectLostNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetObjectLostNotificationRegistrationsSpectraS3Request {
    getObjectLostNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getObjectLostNotificationRegistrationsSpectraS3Request
}

type GetObjectLostNotificationRegistrationsSpectraS3Response struct {
    S3ObjectLostNotificationRegistrationList S3ObjectLostNotificationRegistrationList
    Headers *http.Header
}

func (getObjectLostNotificationRegistrationsSpectraS3Response *GetObjectLostNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectLostNotificationRegistrationsSpectraS3Response.S3ObjectLostNotificationRegistrationList)
}

func NewGetObjectLostNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetObjectLostNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectLostNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectPersistedNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetObjectPersistedNotificationRegistrationSpectraS3Request(notificationId string) *GetObjectPersistedNotificationRegistrationSpectraS3Request {
    return &GetObjectPersistedNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetObjectPersistedNotificationRegistrationSpectraS3Response struct {
    S3ObjectPersistedNotificationRegistration S3ObjectPersistedNotificationRegistration
    Headers *http.Header
}

func (getObjectPersistedNotificationRegistrationSpectraS3Response *GetObjectPersistedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectPersistedNotificationRegistrationSpectraS3Response.S3ObjectPersistedNotificationRegistration)
}

func NewGetObjectPersistedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetObjectPersistedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectPersistedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectPersistedNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetObjectPersistedNotificationRegistrationsSpectraS3Request() *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    return &GetObjectPersistedNotificationRegistrationsSpectraS3Request{
    }
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Request *GetObjectPersistedNotificationRegistrationsSpectraS3Request) WithLastPage() *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    getObjectPersistedNotificationRegistrationsSpectraS3Request.LastPage = true
    return getObjectPersistedNotificationRegistrationsSpectraS3Request
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Request *GetObjectPersistedNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    getObjectPersistedNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getObjectPersistedNotificationRegistrationsSpectraS3Request
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Request *GetObjectPersistedNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    getObjectPersistedNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getObjectPersistedNotificationRegistrationsSpectraS3Request
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Request *GetObjectPersistedNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    getObjectPersistedNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getObjectPersistedNotificationRegistrationsSpectraS3Request
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Request *GetObjectPersistedNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetObjectPersistedNotificationRegistrationsSpectraS3Request {
    getObjectPersistedNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getObjectPersistedNotificationRegistrationsSpectraS3Request
}

type GetObjectPersistedNotificationRegistrationsSpectraS3Response struct {
    S3ObjectPersistedNotificationRegistrationList S3ObjectPersistedNotificationRegistrationList
    Headers *http.Header
}

func (getObjectPersistedNotificationRegistrationsSpectraS3Response *GetObjectPersistedNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectPersistedNotificationRegistrationsSpectraS3Response.S3ObjectPersistedNotificationRegistrationList)
}

func NewGetObjectPersistedNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetObjectPersistedNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectPersistedNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type Range struct {
    Start int64
    End int64
}

type GetObjectRequest struct {
    BucketName string
    ObjectName string
    Checksum Checksum
    Job *string
    Metadata map[string]string
    Offset *int64
}

func NewGetObjectRequest(bucketName string, objectName string) *GetObjectRequest {
    return &GetObjectRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        Checksum: NewNoneChecksum(),
        Metadata: make(map[string]string),
    }
}

func (getObjectRequest *GetObjectRequest) WithJob(job string) *GetObjectRequest {
    getObjectRequest.Job = &job
    return getObjectRequest
}

func (getObjectRequest *GetObjectRequest) WithOffset(offset int64) *GetObjectRequest {
    getObjectRequest.Offset = &offset
    return getObjectRequest
}


func (getObjectRequest *GetObjectRequest) WithChecksum(contentHash string, checksumType ChecksumType) *GetObjectRequest {
    getObjectRequest.Checksum.ContentHash = contentHash
    getObjectRequest.Checksum.Type = checksumType
    return getObjectRequest
}

func (getObjectRequest *GetObjectRequest) WithRanges(ranges ...Range) *GetObjectRequest {
    var rangeElements []string
    for _, cur := range ranges {
        rangeElements = append(rangeElements, fmt.Sprintf("%d-%d", cur.Start, cur.End))
    }
    getObjectRequest.Metadata["Range"] = fmt.Sprintf("bytes=%s", strings.Join(rangeElements[:], ","))
    return getObjectRequest
}
type GetObjectResponse struct {
    Content io.ReadCloser
    Headers *http.Header
}



func NewGetObjectResponse(webResponse WebResponse) (*GetObjectResponse, error) {
    expectedStatusCodes := []int { 200, 206 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &GetObjectResponse{ Content: webResponse.Body(), Headers: webResponse.Header() }, nil
    case 206:
        return &GetObjectResponse{ Content: webResponse.Body(), Headers: webResponse.Header() }, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectsDetailsSpectraS3Request struct {
    BucketId *string
    LastPage bool
    Latest *bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    S3ObjectType S3ObjectType
    Version *int64
}

func NewGetObjectsDetailsSpectraS3Request() *GetObjectsDetailsSpectraS3Request {
    return &GetObjectsDetailsSpectraS3Request{
    }
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithBucketId(bucketId string) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.BucketId = &bucketId
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithLastPage() *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.LastPage = true
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithLatest(latest bool) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.Latest = &latest
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithName(name string) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.Name = &name
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithPageLength(pageLength int) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.PageLength = &pageLength
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithPageOffset(pageOffset int) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.PageOffset = &pageOffset
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithS3ObjectType(s3ObjectType S3ObjectType) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.S3ObjectType = s3ObjectType
    return getObjectsDetailsSpectraS3Request
}

func (getObjectsDetailsSpectraS3Request *GetObjectsDetailsSpectraS3Request) WithVersion(version int64) *GetObjectsDetailsSpectraS3Request {
    getObjectsDetailsSpectraS3Request.Version = &version
    return getObjectsDetailsSpectraS3Request
}

type GetObjectsDetailsSpectraS3Response struct {
    S3ObjectList S3ObjectList
    Headers *http.Header
}

func (getObjectsDetailsSpectraS3Response *GetObjectsDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectsDetailsSpectraS3Response.S3ObjectList)
}

func NewGetObjectsDetailsSpectraS3Response(webResponse WebResponse) (*GetObjectsDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectsDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetObjectsWithFullDetailsSpectraS3Request struct {
    BucketId *string
    IncludePhysicalPlacement bool
    LastPage bool
    Latest *bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    S3ObjectType S3ObjectType
    Version *int64
}

func NewGetObjectsWithFullDetailsSpectraS3Request() *GetObjectsWithFullDetailsSpectraS3Request {
    return &GetObjectsWithFullDetailsSpectraS3Request{
    }
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithBucketId(bucketId string) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.BucketId = &bucketId
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithIncludePhysicalPlacement() *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.IncludePhysicalPlacement = true
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithLastPage() *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.LastPage = true
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithLatest(latest bool) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.Latest = &latest
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithName(name string) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.Name = &name
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithPageLength(pageLength int) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.PageLength = &pageLength
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithPageOffset(pageOffset int) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.PageOffset = &pageOffset
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithS3ObjectType(s3ObjectType S3ObjectType) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.S3ObjectType = s3ObjectType
    return getObjectsWithFullDetailsSpectraS3Request
}

func (getObjectsWithFullDetailsSpectraS3Request *GetObjectsWithFullDetailsSpectraS3Request) WithVersion(version int64) *GetObjectsWithFullDetailsSpectraS3Request {
    getObjectsWithFullDetailsSpectraS3Request.Version = &version
    return getObjectsWithFullDetailsSpectraS3Request
}

type GetObjectsWithFullDetailsSpectraS3Response struct {
    DetailedS3ObjectList DetailedS3ObjectList
    Headers *http.Header
}

func (getObjectsWithFullDetailsSpectraS3Response *GetObjectsWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getObjectsWithFullDetailsSpectraS3Response.DetailedS3ObjectList)
}

func NewGetObjectsWithFullDetailsSpectraS3Response(webResponse WebResponse) (*GetObjectsWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetObjectsWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPhysicalPlacementForObjectsSpectraS3Request struct {
    BucketName string
    ObjectNames []string
    StorageDomainId *string
}

func NewGetPhysicalPlacementForObjectsSpectraS3Request(bucketName string, objectNames []string) *GetPhysicalPlacementForObjectsSpectraS3Request {
    return &GetPhysicalPlacementForObjectsSpectraS3Request{
        BucketName: bucketName,
        ObjectNames: objectNames,
    }
}

func (getPhysicalPlacementForObjectsSpectraS3Request *GetPhysicalPlacementForObjectsSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetPhysicalPlacementForObjectsSpectraS3Request {
    getPhysicalPlacementForObjectsSpectraS3Request.StorageDomainId = &storageDomainId
    return getPhysicalPlacementForObjectsSpectraS3Request
}

type GetPhysicalPlacementForObjectsSpectraS3Response struct {
    PhysicalPlacement PhysicalPlacement
    Headers *http.Header
}

func (getPhysicalPlacementForObjectsSpectraS3Response *GetPhysicalPlacementForObjectsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPhysicalPlacementForObjectsSpectraS3Response.PhysicalPlacement)
}

func NewGetPhysicalPlacementForObjectsSpectraS3Response(webResponse WebResponse) (*GetPhysicalPlacementForObjectsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPhysicalPlacementForObjectsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request struct {
    BucketName string
    ObjectNames []string
    StorageDomainId *string
}

func NewGetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request(bucketName string, objectNames []string) *GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request {
    return &GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request{
        BucketName: bucketName,
        ObjectNames: objectNames,
    }
}

func (getPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request *GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request {
    getPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request.StorageDomainId = &storageDomainId
    return getPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request
}

type GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response *GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response.BulkObjectList)
}

func NewGetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response(webResponse WebResponse) (*GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetPoolFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetPoolFailureNotificationRegistrationSpectraS3Request {
    return &GetPoolFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetPoolFailureNotificationRegistrationSpectraS3Response struct {
    PoolFailureNotificationRegistration PoolFailureNotificationRegistration
    Headers *http.Header
}

func (getPoolFailureNotificationRegistrationSpectraS3Response *GetPoolFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolFailureNotificationRegistrationSpectraS3Response.PoolFailureNotificationRegistration)
}

func NewGetPoolFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetPoolFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetPoolFailureNotificationRegistrationsSpectraS3Request() *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    return &GetPoolFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getPoolFailureNotificationRegistrationsSpectraS3Request *GetPoolFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    getPoolFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getPoolFailureNotificationRegistrationsSpectraS3Request
}

func (getPoolFailureNotificationRegistrationsSpectraS3Request *GetPoolFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    getPoolFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getPoolFailureNotificationRegistrationsSpectraS3Request
}

func (getPoolFailureNotificationRegistrationsSpectraS3Request *GetPoolFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    getPoolFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getPoolFailureNotificationRegistrationsSpectraS3Request
}

func (getPoolFailureNotificationRegistrationsSpectraS3Request *GetPoolFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    getPoolFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getPoolFailureNotificationRegistrationsSpectraS3Request
}

func (getPoolFailureNotificationRegistrationsSpectraS3Request *GetPoolFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetPoolFailureNotificationRegistrationsSpectraS3Request {
    getPoolFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getPoolFailureNotificationRegistrationsSpectraS3Request
}

type GetPoolFailureNotificationRegistrationsSpectraS3Response struct {
    PoolFailureNotificationRegistrationList PoolFailureNotificationRegistrationList
    Headers *http.Header
}

func (getPoolFailureNotificationRegistrationsSpectraS3Response *GetPoolFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolFailureNotificationRegistrationsSpectraS3Response.PoolFailureNotificationRegistrationList)
}

func NewGetPoolFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetPoolFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PoolFailureType PoolFailureType
    PoolId *string
}

func NewGetPoolFailuresSpectraS3Request() *GetPoolFailuresSpectraS3Request {
    return &GetPoolFailuresSpectraS3Request{
    }
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithLastPage() *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.LastPage = true
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithPageLength(pageLength int) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.PageLength = &pageLength
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.PageOffset = &pageOffset
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithPoolId(poolId string) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.PoolId = &poolId
    return getPoolFailuresSpectraS3Request
}

func (getPoolFailuresSpectraS3Request *GetPoolFailuresSpectraS3Request) WithPoolFailureType(poolFailureType PoolFailureType) *GetPoolFailuresSpectraS3Request {
    getPoolFailuresSpectraS3Request.PoolFailureType = poolFailureType
    return getPoolFailuresSpectraS3Request
}

type GetPoolFailuresSpectraS3Response struct {
    PoolFailureList PoolFailureList
    Headers *http.Header
}

func (getPoolFailuresSpectraS3Response *GetPoolFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolFailuresSpectraS3Response.PoolFailureList)
}

func NewGetPoolFailuresSpectraS3Response(webResponse WebResponse) (*GetPoolFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolPartitionSpectraS3Request struct {
    PoolPartition string
}

func NewGetPoolPartitionSpectraS3Request(poolPartition string) *GetPoolPartitionSpectraS3Request {
    return &GetPoolPartitionSpectraS3Request{
        PoolPartition: poolPartition,
    }
}

type GetPoolPartitionSpectraS3Response struct {
    PoolPartition PoolPartition
    Headers *http.Header
}

func (getPoolPartitionSpectraS3Response *GetPoolPartitionSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolPartitionSpectraS3Response.PoolPartition)
}

func NewGetPoolPartitionSpectraS3Response(webResponse WebResponse) (*GetPoolPartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolPartitionSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolPartitionsSpectraS3Request struct {
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PoolType PoolType
}

func NewGetPoolPartitionsSpectraS3Request() *GetPoolPartitionsSpectraS3Request {
    return &GetPoolPartitionsSpectraS3Request{
    }
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithLastPage() *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.LastPage = true
    return getPoolPartitionsSpectraS3Request
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithName(name string) *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.Name = &name
    return getPoolPartitionsSpectraS3Request
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithPageLength(pageLength int) *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.PageLength = &pageLength
    return getPoolPartitionsSpectraS3Request
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithPageOffset(pageOffset int) *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.PageOffset = &pageOffset
    return getPoolPartitionsSpectraS3Request
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getPoolPartitionsSpectraS3Request
}

func (getPoolPartitionsSpectraS3Request *GetPoolPartitionsSpectraS3Request) WithPoolType(poolType PoolType) *GetPoolPartitionsSpectraS3Request {
    getPoolPartitionsSpectraS3Request.PoolType = poolType
    return getPoolPartitionsSpectraS3Request
}

type GetPoolPartitionsSpectraS3Response struct {
    PoolPartitionList PoolPartitionList
    Headers *http.Header
}

func (getPoolPartitionsSpectraS3Response *GetPoolPartitionsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolPartitionsSpectraS3Response.PoolPartitionList)
}

func NewGetPoolPartitionsSpectraS3Response(webResponse WebResponse) (*GetPoolPartitionsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolPartitionsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolSpectraS3Request struct {
    Pool string
}

func NewGetPoolSpectraS3Request(pool string) *GetPoolSpectraS3Request {
    return &GetPoolSpectraS3Request{
        Pool: pool,
    }
}

type GetPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (getPoolSpectraS3Response *GetPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolSpectraS3Response.Pool)
}

func NewGetPoolSpectraS3Response(webResponse WebResponse) (*GetPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetPoolsSpectraS3Request struct {
    AssignedToStorageDomain *bool
    BucketId *string
    Guid *string
    Health PoolHealth
    LastPage bool
    LastVerified *string
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PartitionId *string
    PoolType PoolType
    PoweredOn *bool
    State PoolState
    StorageDomainId *string
}

func NewGetPoolsSpectraS3Request() *GetPoolsSpectraS3Request {
    return &GetPoolsSpectraS3Request{
    }
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithAssignedToStorageDomain(assignedToStorageDomain bool) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.AssignedToStorageDomain = &assignedToStorageDomain
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithBucketId(bucketId string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.BucketId = &bucketId
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithGuid(guid string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.Guid = &guid
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithHealth(health PoolHealth) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.Health = health
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithLastPage() *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.LastPage = true
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithLastVerified(lastVerified string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.LastVerified = &lastVerified
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithName(name string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.Name = &name
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPageLength(pageLength int) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PageLength = &pageLength
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPageOffset(pageOffset int) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PageOffset = &pageOffset
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPartitionId(partitionId string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PartitionId = &partitionId
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPoweredOn(poweredOn bool) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PoweredOn = &poweredOn
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithState(state PoolState) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.State = state
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.StorageDomainId = &storageDomainId
    return getPoolsSpectraS3Request
}

func (getPoolsSpectraS3Request *GetPoolsSpectraS3Request) WithPoolType(poolType PoolType) *GetPoolsSpectraS3Request {
    getPoolsSpectraS3Request.PoolType = poolType
    return getPoolsSpectraS3Request
}

type GetPoolsSpectraS3Response struct {
    PoolList PoolList
    Headers *http.Header
}

func (getPoolsSpectraS3Response *GetPoolsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getPoolsSpectraS3Response.PoolList)
}

func NewGetPoolsSpectraS3Response(webResponse WebResponse) (*GetPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetPoolsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3DataReplicationRuleSpectraS3Request struct {
    S3DataReplicationRule string
}

func NewGetS3DataReplicationRuleSpectraS3Request(s3DataReplicationRule string) *GetS3DataReplicationRuleSpectraS3Request {
    return &GetS3DataReplicationRuleSpectraS3Request{
        S3DataReplicationRule: s3DataReplicationRule,
    }
}

type GetS3DataReplicationRuleSpectraS3Response struct {
    S3DataReplicationRule S3DataReplicationRule
    Headers *http.Header
}

func (getS3DataReplicationRuleSpectraS3Response *GetS3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3DataReplicationRuleSpectraS3Response.S3DataReplicationRule)
}

func NewGetS3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*GetS3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3DataReplicationRulesSpectraS3Request struct {
    DataPolicyId *string
    DataReplicationRuleType DataReplicationRuleType
    InitialDataPlacement S3InitialDataPlacementPolicy
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReplicateDeletes *bool
    State DataPlacementRuleState
    TargetId *string
}

func NewGetS3DataReplicationRulesSpectraS3Request() *GetS3DataReplicationRulesSpectraS3Request {
    return &GetS3DataReplicationRulesSpectraS3Request{
    }
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.DataPolicyId = &dataPolicyId
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithInitialDataPlacement(initialDataPlacement S3InitialDataPlacementPolicy) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.InitialDataPlacement = initialDataPlacement
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithLastPage() *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.LastPage = true
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithPageLength(pageLength int) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.PageLength = &pageLength
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithPageOffset(pageOffset int) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.PageOffset = &pageOffset
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithState(state DataPlacementRuleState) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.State = state
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithTargetId(targetId string) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.TargetId = &targetId
    return getS3DataReplicationRulesSpectraS3Request
}

func (getS3DataReplicationRulesSpectraS3Request *GetS3DataReplicationRulesSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *GetS3DataReplicationRulesSpectraS3Request {
    getS3DataReplicationRulesSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return getS3DataReplicationRulesSpectraS3Request
}

type GetS3DataReplicationRulesSpectraS3Response struct {
    S3DataReplicationRuleList S3DataReplicationRuleList
    Headers *http.Header
}

func (getS3DataReplicationRulesSpectraS3Response *GetS3DataReplicationRulesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3DataReplicationRulesSpectraS3Response.S3DataReplicationRuleList)
}

func NewGetS3DataReplicationRulesSpectraS3Response(webResponse WebResponse) (*GetS3DataReplicationRulesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3DataReplicationRulesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetBucketNamesSpectraS3Request struct {
    BucketId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetId *string
}

func NewGetS3TargetBucketNamesSpectraS3Request() *GetS3TargetBucketNamesSpectraS3Request {
    return &GetS3TargetBucketNamesSpectraS3Request{
    }
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithBucketId(bucketId string) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.BucketId = &bucketId
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithLastPage() *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.LastPage = true
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithName(name string) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.Name = &name
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithPageLength(pageLength int) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.PageLength = &pageLength
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithPageOffset(pageOffset int) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.PageOffset = &pageOffset
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3TargetBucketNamesSpectraS3Request
}

func (getS3TargetBucketNamesSpectraS3Request *GetS3TargetBucketNamesSpectraS3Request) WithTargetId(targetId string) *GetS3TargetBucketNamesSpectraS3Request {
    getS3TargetBucketNamesSpectraS3Request.TargetId = &targetId
    return getS3TargetBucketNamesSpectraS3Request
}

type GetS3TargetBucketNamesSpectraS3Response struct {
    S3TargetBucketNameList S3TargetBucketNameList
    Headers *http.Header
}

func (getS3TargetBucketNamesSpectraS3Response *GetS3TargetBucketNamesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetBucketNamesSpectraS3Response.S3TargetBucketNameList)
}

func NewGetS3TargetBucketNamesSpectraS3Response(webResponse WebResponse) (*GetS3TargetBucketNamesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetBucketNamesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetFailureNotificationRegistrationSpectraS3Request struct {
    S3TargetFailureNotificationRegistration string
}

func NewGetS3TargetFailureNotificationRegistrationSpectraS3Request(s3TargetFailureNotificationRegistration string) *GetS3TargetFailureNotificationRegistrationSpectraS3Request {
    return &GetS3TargetFailureNotificationRegistrationSpectraS3Request{
        S3TargetFailureNotificationRegistration: s3TargetFailureNotificationRegistration,
    }
}

type GetS3TargetFailureNotificationRegistrationSpectraS3Response struct {
    S3TargetFailureNotificationRegistration S3TargetFailureNotificationRegistration
    Headers *http.Header
}

func (getS3TargetFailureNotificationRegistrationSpectraS3Response *GetS3TargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetFailureNotificationRegistrationSpectraS3Response.S3TargetFailureNotificationRegistration)
}

func NewGetS3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetS3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetS3TargetFailureNotificationRegistrationsSpectraS3Request() *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    return &GetS3TargetFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Request *GetS3TargetFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    getS3TargetFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getS3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Request *GetS3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    getS3TargetFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getS3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Request *GetS3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    getS3TargetFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getS3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Request *GetS3TargetFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    getS3TargetFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3TargetFailureNotificationRegistrationsSpectraS3Request
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Request *GetS3TargetFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetS3TargetFailureNotificationRegistrationsSpectraS3Request {
    getS3TargetFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getS3TargetFailureNotificationRegistrationsSpectraS3Request
}

type GetS3TargetFailureNotificationRegistrationsSpectraS3Response struct {
    S3TargetFailureNotificationRegistrationList S3TargetFailureNotificationRegistrationList
    Headers *http.Header
}

func (getS3TargetFailureNotificationRegistrationsSpectraS3Response *GetS3TargetFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetFailureNotificationRegistrationsSpectraS3Response.S3TargetFailureNotificationRegistrationList)
}

func NewGetS3TargetFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetS3TargetFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetFailureType TargetFailureType
    TargetId *string
}

func NewGetS3TargetFailuresSpectraS3Request() *GetS3TargetFailuresSpectraS3Request {
    return &GetS3TargetFailuresSpectraS3Request{
    }
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithLastPage() *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.LastPage = true
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithPageLength(pageLength int) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.PageLength = &pageLength
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.PageOffset = &pageOffset
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithTargetId(targetId string) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.TargetId = &targetId
    return getS3TargetFailuresSpectraS3Request
}

func (getS3TargetFailuresSpectraS3Request *GetS3TargetFailuresSpectraS3Request) WithTargetFailureType(targetFailureType TargetFailureType) *GetS3TargetFailuresSpectraS3Request {
    getS3TargetFailuresSpectraS3Request.TargetFailureType = targetFailureType
    return getS3TargetFailuresSpectraS3Request
}

type GetS3TargetFailuresSpectraS3Response struct {
    S3TargetFailureList S3TargetFailureList
    Headers *http.Header
}

func (getS3TargetFailuresSpectraS3Response *GetS3TargetFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetFailuresSpectraS3Response.S3TargetFailureList)
}

func NewGetS3TargetFailuresSpectraS3Response(webResponse WebResponse) (*GetS3TargetFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetReadPreferenceSpectraS3Request struct {
    S3TargetReadPreference string
}

func NewGetS3TargetReadPreferenceSpectraS3Request(s3TargetReadPreference string) *GetS3TargetReadPreferenceSpectraS3Request {
    return &GetS3TargetReadPreferenceSpectraS3Request{
        S3TargetReadPreference: s3TargetReadPreference,
    }
}

type GetS3TargetReadPreferenceSpectraS3Response struct {
    S3TargetReadPreference S3TargetReadPreference
    Headers *http.Header
}

func (getS3TargetReadPreferenceSpectraS3Response *GetS3TargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetReadPreferenceSpectraS3Response.S3TargetReadPreference)
}

func NewGetS3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*GetS3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetReadPreferencesSpectraS3Request struct {
    BucketId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    ReadPreference TargetReadPreferenceType
    TargetId *string
}

func NewGetS3TargetReadPreferencesSpectraS3Request() *GetS3TargetReadPreferencesSpectraS3Request {
    return &GetS3TargetReadPreferencesSpectraS3Request{
    }
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithBucketId(bucketId string) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.BucketId = &bucketId
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithLastPage() *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.LastPage = true
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithPageLength(pageLength int) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.PageLength = &pageLength
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithPageOffset(pageOffset int) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.PageOffset = &pageOffset
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithReadPreference(readPreference TargetReadPreferenceType) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.ReadPreference = readPreference
    return getS3TargetReadPreferencesSpectraS3Request
}

func (getS3TargetReadPreferencesSpectraS3Request *GetS3TargetReadPreferencesSpectraS3Request) WithTargetId(targetId string) *GetS3TargetReadPreferencesSpectraS3Request {
    getS3TargetReadPreferencesSpectraS3Request.TargetId = &targetId
    return getS3TargetReadPreferencesSpectraS3Request
}

type GetS3TargetReadPreferencesSpectraS3Response struct {
    S3TargetReadPreferenceList S3TargetReadPreferenceList
    Headers *http.Header
}

func (getS3TargetReadPreferencesSpectraS3Response *GetS3TargetReadPreferencesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetReadPreferencesSpectraS3Response.S3TargetReadPreferenceList)
}

func NewGetS3TargetReadPreferencesSpectraS3Response(webResponse WebResponse) (*GetS3TargetReadPreferencesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetReadPreferencesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetSpectraS3Request struct {
    S3Target string
}

func NewGetS3TargetSpectraS3Request(s3Target string) *GetS3TargetSpectraS3Request {
    return &GetS3TargetSpectraS3Request{
        S3Target: s3Target,
    }
}

type GetS3TargetSpectraS3Response struct {
    S3Target S3Target
    Headers *http.Header
}

func (getS3TargetSpectraS3Response *GetS3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetSpectraS3Response.S3Target)
}

func NewGetS3TargetSpectraS3Response(webResponse WebResponse) (*GetS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetS3TargetsSpectraS3Request struct {
    AccessKey *string
    DataPathEndPoint *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PermitGoingOutOfSync *bool
    Quiesced Quiesced
    Region S3Region
    State TargetState
}

func NewGetS3TargetsSpectraS3Request() *GetS3TargetsSpectraS3Request {
    return &GetS3TargetsSpectraS3Request{
    }
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithAccessKey(accessKey string) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.AccessKey = &accessKey
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithHttps(https bool) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.Https = &https
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithLastPage() *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.LastPage = true
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithName(name string) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.Name = &name
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithPageLength(pageLength int) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.PageLength = &pageLength
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.PageOffset = &pageOffset
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithQuiesced(quiesced Quiesced) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.Quiesced = quiesced
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithRegion(region S3Region) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.Region = region
    return getS3TargetsSpectraS3Request
}

func (getS3TargetsSpectraS3Request *GetS3TargetsSpectraS3Request) WithState(state TargetState) *GetS3TargetsSpectraS3Request {
    getS3TargetsSpectraS3Request.State = state
    return getS3TargetsSpectraS3Request
}

type GetS3TargetsSpectraS3Response struct {
    S3TargetList S3TargetList
    Headers *http.Header
}

func (getS3TargetsSpectraS3Response *GetS3TargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getS3TargetsSpectraS3Response.S3TargetList)
}

func NewGetS3TargetsSpectraS3Response(webResponse WebResponse) (*GetS3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetS3TargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetServiceRequest struct {
}

func NewGetServiceRequest() *GetServiceRequest {
    return &GetServiceRequest{
    }
}

type GetServiceResponse struct {
    ListAllMyBucketsResult ListAllMyBucketsResult
    Headers *http.Header
}

func (getServiceResponse *GetServiceResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getServiceResponse.ListAllMyBucketsResult)
}

func NewGetServiceResponse(webResponse WebResponse) (*GetServiceResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetServiceResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainCapacitySummarySpectraS3Request struct {
    PoolHealth PoolHealth
    PoolState PoolState
    PoolType PoolType
    StorageDomainId string
    TapeState TapeState
    TapeType *string
}

func NewGetStorageDomainCapacitySummarySpectraS3Request(storageDomainId string) *GetStorageDomainCapacitySummarySpectraS3Request {
    return &GetStorageDomainCapacitySummarySpectraS3Request{
        StorageDomainId: storageDomainId,
    }
}

func (getStorageDomainCapacitySummarySpectraS3Request *GetStorageDomainCapacitySummarySpectraS3Request) WithPoolHealth(poolHealth PoolHealth) *GetStorageDomainCapacitySummarySpectraS3Request {
    getStorageDomainCapacitySummarySpectraS3Request.PoolHealth = poolHealth
    return getStorageDomainCapacitySummarySpectraS3Request
}

func (getStorageDomainCapacitySummarySpectraS3Request *GetStorageDomainCapacitySummarySpectraS3Request) WithPoolState(poolState PoolState) *GetStorageDomainCapacitySummarySpectraS3Request {
    getStorageDomainCapacitySummarySpectraS3Request.PoolState = poolState
    return getStorageDomainCapacitySummarySpectraS3Request
}

func (getStorageDomainCapacitySummarySpectraS3Request *GetStorageDomainCapacitySummarySpectraS3Request) WithPoolType(poolType PoolType) *GetStorageDomainCapacitySummarySpectraS3Request {
    getStorageDomainCapacitySummarySpectraS3Request.PoolType = poolType
    return getStorageDomainCapacitySummarySpectraS3Request
}

func (getStorageDomainCapacitySummarySpectraS3Request *GetStorageDomainCapacitySummarySpectraS3Request) WithTapeState(tapeState TapeState) *GetStorageDomainCapacitySummarySpectraS3Request {
    getStorageDomainCapacitySummarySpectraS3Request.TapeState = tapeState
    return getStorageDomainCapacitySummarySpectraS3Request
}

func (getStorageDomainCapacitySummarySpectraS3Request *GetStorageDomainCapacitySummarySpectraS3Request) WithTapeType(tapeType string) *GetStorageDomainCapacitySummarySpectraS3Request {
    getStorageDomainCapacitySummarySpectraS3Request.TapeType = &tapeType
    return getStorageDomainCapacitySummarySpectraS3Request
}

type GetStorageDomainCapacitySummarySpectraS3Response struct {
    CapacitySummaryContainer CapacitySummaryContainer
    Headers *http.Header
}

func (getStorageDomainCapacitySummarySpectraS3Response *GetStorageDomainCapacitySummarySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainCapacitySummarySpectraS3Response.CapacitySummaryContainer)
}

func NewGetStorageDomainCapacitySummarySpectraS3Response(webResponse WebResponse) (*GetStorageDomainCapacitySummarySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainCapacitySummarySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetStorageDomainFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetStorageDomainFailureNotificationRegistrationSpectraS3Request {
    return &GetStorageDomainFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetStorageDomainFailureNotificationRegistrationSpectraS3Response struct {
    StorageDomainFailureNotificationRegistration StorageDomainFailureNotificationRegistration
    Headers *http.Header
}

func (getStorageDomainFailureNotificationRegistrationSpectraS3Response *GetStorageDomainFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainFailureNotificationRegistrationSpectraS3Response.StorageDomainFailureNotificationRegistration)
}

func NewGetStorageDomainFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetStorageDomainFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetStorageDomainFailureNotificationRegistrationsSpectraS3Request() *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    return &GetStorageDomainFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Request *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    getStorageDomainFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getStorageDomainFailureNotificationRegistrationsSpectraS3Request
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Request *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    getStorageDomainFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getStorageDomainFailureNotificationRegistrationsSpectraS3Request
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Request *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    getStorageDomainFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getStorageDomainFailureNotificationRegistrationsSpectraS3Request
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Request *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    getStorageDomainFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getStorageDomainFailureNotificationRegistrationsSpectraS3Request
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Request *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetStorageDomainFailureNotificationRegistrationsSpectraS3Request {
    getStorageDomainFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getStorageDomainFailureNotificationRegistrationsSpectraS3Request
}

type GetStorageDomainFailureNotificationRegistrationsSpectraS3Response struct {
    StorageDomainFailureNotificationRegistrationList StorageDomainFailureNotificationRegistrationList
    Headers *http.Header
}

func (getStorageDomainFailureNotificationRegistrationsSpectraS3Response *GetStorageDomainFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainFailureNotificationRegistrationsSpectraS3Response.StorageDomainFailureNotificationRegistrationList)
}

func NewGetStorageDomainFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetStorageDomainFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    StorageDomainFailureType StorageDomainFailureType
    StorageDomainId *string
}

func NewGetStorageDomainFailuresSpectraS3Request() *GetStorageDomainFailuresSpectraS3Request {
    return &GetStorageDomainFailuresSpectraS3Request{
    }
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithLastPage() *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.LastPage = true
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithPageLength(pageLength int) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.PageLength = &pageLength
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.PageOffset = &pageOffset
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.StorageDomainId = &storageDomainId
    return getStorageDomainFailuresSpectraS3Request
}

func (getStorageDomainFailuresSpectraS3Request *GetStorageDomainFailuresSpectraS3Request) WithStorageDomainFailureType(storageDomainFailureType StorageDomainFailureType) *GetStorageDomainFailuresSpectraS3Request {
    getStorageDomainFailuresSpectraS3Request.StorageDomainFailureType = storageDomainFailureType
    return getStorageDomainFailuresSpectraS3Request
}

type GetStorageDomainFailuresSpectraS3Response struct {
    StorageDomainFailureList StorageDomainFailureList
    Headers *http.Header
}

func (getStorageDomainFailuresSpectraS3Response *GetStorageDomainFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainFailuresSpectraS3Response.StorageDomainFailureList)
}

func NewGetStorageDomainFailuresSpectraS3Response(webResponse WebResponse) (*GetStorageDomainFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainMemberSpectraS3Request struct {
    StorageDomainMember string
}

func NewGetStorageDomainMemberSpectraS3Request(storageDomainMember string) *GetStorageDomainMemberSpectraS3Request {
    return &GetStorageDomainMemberSpectraS3Request{
        StorageDomainMember: storageDomainMember,
    }
}

type GetStorageDomainMemberSpectraS3Response struct {
    StorageDomainMember StorageDomainMember
    Headers *http.Header
}

func (getStorageDomainMemberSpectraS3Response *GetStorageDomainMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainMemberSpectraS3Response.StorageDomainMember)
}

func NewGetStorageDomainMemberSpectraS3Response(webResponse WebResponse) (*GetStorageDomainMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainMembersSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PoolPartitionId *string
    State StorageDomainMemberState
    StorageDomainId *string
    TapePartitionId *string
    TapeType *string
    WritePreference WritePreferenceLevel
}

func NewGetStorageDomainMembersSpectraS3Request() *GetStorageDomainMembersSpectraS3Request {
    return &GetStorageDomainMembersSpectraS3Request{
    }
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithLastPage() *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.LastPage = true
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithPageLength(pageLength int) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.PageLength = &pageLength
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithPageOffset(pageOffset int) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.PageOffset = &pageOffset
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.PageStartMarker = &pageStartMarker
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithPoolPartitionId(poolPartitionId string) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.PoolPartitionId = &poolPartitionId
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithState(state StorageDomainMemberState) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.State = state
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.StorageDomainId = &storageDomainId
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithTapePartitionId(tapePartitionId string) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.TapePartitionId = &tapePartitionId
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithTapeType(tapeType string) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.TapeType = &tapeType
    return getStorageDomainMembersSpectraS3Request
}

func (getStorageDomainMembersSpectraS3Request *GetStorageDomainMembersSpectraS3Request) WithWritePreference(writePreference WritePreferenceLevel) *GetStorageDomainMembersSpectraS3Request {
    getStorageDomainMembersSpectraS3Request.WritePreference = writePreference
    return getStorageDomainMembersSpectraS3Request
}

type GetStorageDomainMembersSpectraS3Response struct {
    StorageDomainMemberList StorageDomainMemberList
    Headers *http.Header
}

func (getStorageDomainMembersSpectraS3Response *GetStorageDomainMembersSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainMembersSpectraS3Response.StorageDomainMemberList)
}

func NewGetStorageDomainMembersSpectraS3Response(webResponse WebResponse) (*GetStorageDomainMembersSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainMembersSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainSpectraS3Request struct {
    StorageDomain string
}

func NewGetStorageDomainSpectraS3Request(storageDomain string) *GetStorageDomainSpectraS3Request {
    return &GetStorageDomainSpectraS3Request{
        StorageDomain: storageDomain,
    }
}

type GetStorageDomainSpectraS3Response struct {
    StorageDomain StorageDomain
    Headers *http.Header
}

func (getStorageDomainSpectraS3Response *GetStorageDomainSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainSpectraS3Response.StorageDomain)
}

func NewGetStorageDomainSpectraS3Response(webResponse WebResponse) (*GetStorageDomainSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetStorageDomainsSpectraS3Request struct {
    AutoEjectUponCron *string
    AutoEjectUponJobCancellation *bool
    AutoEjectUponJobCompletion *bool
    AutoEjectUponMediaFull *bool
    LastPage bool
    MediaEjectionAllowed *bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    SecureMediaAllocation *bool
    WriteOptimization WriteOptimization
}

func NewGetStorageDomainsSpectraS3Request() *GetStorageDomainsSpectraS3Request {
    return &GetStorageDomainsSpectraS3Request{
    }
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithAutoEjectUponCron(autoEjectUponCron string) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.AutoEjectUponCron = &autoEjectUponCron
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithAutoEjectUponJobCancellation(autoEjectUponJobCancellation bool) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.AutoEjectUponJobCancellation = &autoEjectUponJobCancellation
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithAutoEjectUponJobCompletion(autoEjectUponJobCompletion bool) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.AutoEjectUponJobCompletion = &autoEjectUponJobCompletion
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithAutoEjectUponMediaFull(autoEjectUponMediaFull bool) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.AutoEjectUponMediaFull = &autoEjectUponMediaFull
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithLastPage() *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.LastPage = true
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithMediaEjectionAllowed(mediaEjectionAllowed bool) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.MediaEjectionAllowed = &mediaEjectionAllowed
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithName(name string) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.Name = &name
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithPageLength(pageLength int) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.PageLength = &pageLength
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithPageOffset(pageOffset int) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.PageOffset = &pageOffset
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithSecureMediaAllocation(secureMediaAllocation bool) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.SecureMediaAllocation = &secureMediaAllocation
    return getStorageDomainsSpectraS3Request
}

func (getStorageDomainsSpectraS3Request *GetStorageDomainsSpectraS3Request) WithWriteOptimization(writeOptimization WriteOptimization) *GetStorageDomainsSpectraS3Request {
    getStorageDomainsSpectraS3Request.WriteOptimization = writeOptimization
    return getStorageDomainsSpectraS3Request
}

type GetStorageDomainsSpectraS3Response struct {
    StorageDomainList StorageDomainList
    Headers *http.Header
}

func (getStorageDomainsSpectraS3Response *GetStorageDomainsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getStorageDomainsSpectraS3Response.StorageDomainList)
}

func NewGetStorageDomainsSpectraS3Response(webResponse WebResponse) (*GetStorageDomainsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetStorageDomainsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBlobAzureTargetsSpectraS3Request struct {
    BlobId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetId *string
}

func NewGetSuspectBlobAzureTargetsSpectraS3Request() *GetSuspectBlobAzureTargetsSpectraS3Request {
    return &GetSuspectBlobAzureTargetsSpectraS3Request{
    }
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithBlobId(blobId string) *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.BlobId = &blobId
    return getSuspectBlobAzureTargetsSpectraS3Request
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithLastPage() *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.LastPage = true
    return getSuspectBlobAzureTargetsSpectraS3Request
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.PageLength = &pageLength
    return getSuspectBlobAzureTargetsSpectraS3Request
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBlobAzureTargetsSpectraS3Request
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBlobAzureTargetsSpectraS3Request
}

func (getSuspectBlobAzureTargetsSpectraS3Request *GetSuspectBlobAzureTargetsSpectraS3Request) WithTargetId(targetId string) *GetSuspectBlobAzureTargetsSpectraS3Request {
    getSuspectBlobAzureTargetsSpectraS3Request.TargetId = &targetId
    return getSuspectBlobAzureTargetsSpectraS3Request
}

type GetSuspectBlobAzureTargetsSpectraS3Response struct {
    SuspectBlobAzureTargetList SuspectBlobAzureTargetList
    Headers *http.Header
}

func (getSuspectBlobAzureTargetsSpectraS3Response *GetSuspectBlobAzureTargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBlobAzureTargetsSpectraS3Response.SuspectBlobAzureTargetList)
}

func NewGetSuspectBlobAzureTargetsSpectraS3Response(webResponse WebResponse) (*GetSuspectBlobAzureTargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBlobAzureTargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBlobDs3TargetsSpectraS3Request struct {
    BlobId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetId *string
}

func NewGetSuspectBlobDs3TargetsSpectraS3Request() *GetSuspectBlobDs3TargetsSpectraS3Request {
    return &GetSuspectBlobDs3TargetsSpectraS3Request{
    }
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithBlobId(blobId string) *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.BlobId = &blobId
    return getSuspectBlobDs3TargetsSpectraS3Request
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithLastPage() *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.LastPage = true
    return getSuspectBlobDs3TargetsSpectraS3Request
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.PageLength = &pageLength
    return getSuspectBlobDs3TargetsSpectraS3Request
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBlobDs3TargetsSpectraS3Request
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBlobDs3TargetsSpectraS3Request
}

func (getSuspectBlobDs3TargetsSpectraS3Request *GetSuspectBlobDs3TargetsSpectraS3Request) WithTargetId(targetId string) *GetSuspectBlobDs3TargetsSpectraS3Request {
    getSuspectBlobDs3TargetsSpectraS3Request.TargetId = &targetId
    return getSuspectBlobDs3TargetsSpectraS3Request
}

type GetSuspectBlobDs3TargetsSpectraS3Response struct {
    SuspectBlobDs3TargetList SuspectBlobDs3TargetList
    Headers *http.Header
}

func (getSuspectBlobDs3TargetsSpectraS3Response *GetSuspectBlobDs3TargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBlobDs3TargetsSpectraS3Response.SuspectBlobDs3TargetList)
}

func NewGetSuspectBlobDs3TargetsSpectraS3Response(webResponse WebResponse) (*GetSuspectBlobDs3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBlobDs3TargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBlobPoolsSpectraS3Request struct {
    BlobId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PoolId *string
}

func NewGetSuspectBlobPoolsSpectraS3Request() *GetSuspectBlobPoolsSpectraS3Request {
    return &GetSuspectBlobPoolsSpectraS3Request{
    }
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithBlobId(blobId string) *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.BlobId = &blobId
    return getSuspectBlobPoolsSpectraS3Request
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithLastPage() *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.LastPage = true
    return getSuspectBlobPoolsSpectraS3Request
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.PageLength = &pageLength
    return getSuspectBlobPoolsSpectraS3Request
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBlobPoolsSpectraS3Request
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBlobPoolsSpectraS3Request
}

func (getSuspectBlobPoolsSpectraS3Request *GetSuspectBlobPoolsSpectraS3Request) WithPoolId(poolId string) *GetSuspectBlobPoolsSpectraS3Request {
    getSuspectBlobPoolsSpectraS3Request.PoolId = &poolId
    return getSuspectBlobPoolsSpectraS3Request
}

type GetSuspectBlobPoolsSpectraS3Response struct {
    SuspectBlobPoolList SuspectBlobPoolList
    Headers *http.Header
}

func (getSuspectBlobPoolsSpectraS3Response *GetSuspectBlobPoolsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBlobPoolsSpectraS3Response.SuspectBlobPoolList)
}

func NewGetSuspectBlobPoolsSpectraS3Response(webResponse WebResponse) (*GetSuspectBlobPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBlobPoolsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBlobS3TargetsSpectraS3Request struct {
    BlobId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TargetId *string
}

func NewGetSuspectBlobS3TargetsSpectraS3Request() *GetSuspectBlobS3TargetsSpectraS3Request {
    return &GetSuspectBlobS3TargetsSpectraS3Request{
    }
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithBlobId(blobId string) *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.BlobId = &blobId
    return getSuspectBlobS3TargetsSpectraS3Request
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithLastPage() *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.LastPage = true
    return getSuspectBlobS3TargetsSpectraS3Request
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.PageLength = &pageLength
    return getSuspectBlobS3TargetsSpectraS3Request
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBlobS3TargetsSpectraS3Request
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBlobS3TargetsSpectraS3Request
}

func (getSuspectBlobS3TargetsSpectraS3Request *GetSuspectBlobS3TargetsSpectraS3Request) WithTargetId(targetId string) *GetSuspectBlobS3TargetsSpectraS3Request {
    getSuspectBlobS3TargetsSpectraS3Request.TargetId = &targetId
    return getSuspectBlobS3TargetsSpectraS3Request
}

type GetSuspectBlobS3TargetsSpectraS3Response struct {
    SuspectBlobS3TargetList SuspectBlobS3TargetList
    Headers *http.Header
}

func (getSuspectBlobS3TargetsSpectraS3Response *GetSuspectBlobS3TargetsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBlobS3TargetsSpectraS3Response.SuspectBlobS3TargetList)
}

func NewGetSuspectBlobS3TargetsSpectraS3Response(webResponse WebResponse) (*GetSuspectBlobS3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBlobS3TargetsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBlobTapesSpectraS3Request struct {
    BlobId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TapeId *string
}

func NewGetSuspectBlobTapesSpectraS3Request() *GetSuspectBlobTapesSpectraS3Request {
    return &GetSuspectBlobTapesSpectraS3Request{
    }
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithBlobId(blobId string) *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.BlobId = &blobId
    return getSuspectBlobTapesSpectraS3Request
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithLastPage() *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.LastPage = true
    return getSuspectBlobTapesSpectraS3Request
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.PageLength = &pageLength
    return getSuspectBlobTapesSpectraS3Request
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBlobTapesSpectraS3Request
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBlobTapesSpectraS3Request
}

func (getSuspectBlobTapesSpectraS3Request *GetSuspectBlobTapesSpectraS3Request) WithTapeId(tapeId string) *GetSuspectBlobTapesSpectraS3Request {
    getSuspectBlobTapesSpectraS3Request.TapeId = &tapeId
    return getSuspectBlobTapesSpectraS3Request
}

type GetSuspectBlobTapesSpectraS3Response struct {
    SuspectBlobTapeList SuspectBlobTapeList
    Headers *http.Header
}

func (getSuspectBlobTapesSpectraS3Response *GetSuspectBlobTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBlobTapesSpectraS3Response.SuspectBlobTapeList)
}

func NewGetSuspectBlobTapesSpectraS3Response(webResponse WebResponse) (*GetSuspectBlobTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBlobTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectBucketsSpectraS3Request struct {
    DataPolicyId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetSuspectBucketsSpectraS3Request() *GetSuspectBucketsSpectraS3Request {
    return &GetSuspectBucketsSpectraS3Request{
    }
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithDataPolicyId(dataPolicyId string) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.DataPolicyId = &dataPolicyId
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithLastPage() *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.LastPage = true
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithName(name string) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.Name = &name
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.PageLength = &pageLength
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectBucketsSpectraS3Request
}

func (getSuspectBucketsSpectraS3Request *GetSuspectBucketsSpectraS3Request) WithUserId(userId string) *GetSuspectBucketsSpectraS3Request {
    getSuspectBucketsSpectraS3Request.UserId = &userId
    return getSuspectBucketsSpectraS3Request
}

type GetSuspectBucketsSpectraS3Response struct {
    BucketList BucketList
    Headers *http.Header
}

func (getSuspectBucketsSpectraS3Response *GetSuspectBucketsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectBucketsSpectraS3Response.BucketList)
}

func NewGetSuspectBucketsSpectraS3Response(webResponse WebResponse) (*GetSuspectBucketsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectBucketsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectObjectsSpectraS3Request struct {
    BucketId *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetSuspectObjectsSpectraS3Request() *GetSuspectObjectsSpectraS3Request {
    return &GetSuspectObjectsSpectraS3Request{
    }
}

func (getSuspectObjectsSpectraS3Request *GetSuspectObjectsSpectraS3Request) WithBucketId(bucketId string) *GetSuspectObjectsSpectraS3Request {
    getSuspectObjectsSpectraS3Request.BucketId = &bucketId
    return getSuspectObjectsSpectraS3Request
}

func (getSuspectObjectsSpectraS3Request *GetSuspectObjectsSpectraS3Request) WithLastPage() *GetSuspectObjectsSpectraS3Request {
    getSuspectObjectsSpectraS3Request.LastPage = true
    return getSuspectObjectsSpectraS3Request
}

func (getSuspectObjectsSpectraS3Request *GetSuspectObjectsSpectraS3Request) WithPageLength(pageLength int) *GetSuspectObjectsSpectraS3Request {
    getSuspectObjectsSpectraS3Request.PageLength = &pageLength
    return getSuspectObjectsSpectraS3Request
}

func (getSuspectObjectsSpectraS3Request *GetSuspectObjectsSpectraS3Request) WithPageOffset(pageOffset int) *GetSuspectObjectsSpectraS3Request {
    getSuspectObjectsSpectraS3Request.PageOffset = &pageOffset
    return getSuspectObjectsSpectraS3Request
}

func (getSuspectObjectsSpectraS3Request *GetSuspectObjectsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSuspectObjectsSpectraS3Request {
    getSuspectObjectsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSuspectObjectsSpectraS3Request
}

type GetSuspectObjectsSpectraS3Response struct {
    S3ObjectList S3ObjectList
    Headers *http.Header
}

func (getSuspectObjectsSpectraS3Response *GetSuspectObjectsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectObjectsSpectraS3Response.S3ObjectList)
}

func NewGetSuspectObjectsSpectraS3Response(webResponse WebResponse) (*GetSuspectObjectsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectObjectsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSuspectObjectsWithFullDetailsSpectraS3Request struct {
    BucketId *string
    StorageDomainId *string
}

func NewGetSuspectObjectsWithFullDetailsSpectraS3Request() *GetSuspectObjectsWithFullDetailsSpectraS3Request {
    return &GetSuspectObjectsWithFullDetailsSpectraS3Request{
    }
}

func (getSuspectObjectsWithFullDetailsSpectraS3Request *GetSuspectObjectsWithFullDetailsSpectraS3Request) WithBucketId(bucketId string) *GetSuspectObjectsWithFullDetailsSpectraS3Request {
    getSuspectObjectsWithFullDetailsSpectraS3Request.BucketId = &bucketId
    return getSuspectObjectsWithFullDetailsSpectraS3Request
}

func (getSuspectObjectsWithFullDetailsSpectraS3Request *GetSuspectObjectsWithFullDetailsSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetSuspectObjectsWithFullDetailsSpectraS3Request {
    getSuspectObjectsWithFullDetailsSpectraS3Request.StorageDomainId = &storageDomainId
    return getSuspectObjectsWithFullDetailsSpectraS3Request
}

type GetSuspectObjectsWithFullDetailsSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (getSuspectObjectsWithFullDetailsSpectraS3Response *GetSuspectObjectsWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSuspectObjectsWithFullDetailsSpectraS3Response.BulkObjectList)
}

func NewGetSuspectObjectsWithFullDetailsSpectraS3Response(webResponse WebResponse) (*GetSuspectObjectsWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSuspectObjectsWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSystemCapacitySummarySpectraS3Request struct {
    PoolHealth PoolHealth
    PoolState PoolState
    PoolType PoolType
    TapeState TapeState
    TapeType *string
}

func NewGetSystemCapacitySummarySpectraS3Request() *GetSystemCapacitySummarySpectraS3Request {
    return &GetSystemCapacitySummarySpectraS3Request{
    }
}

func (getSystemCapacitySummarySpectraS3Request *GetSystemCapacitySummarySpectraS3Request) WithPoolHealth(poolHealth PoolHealth) *GetSystemCapacitySummarySpectraS3Request {
    getSystemCapacitySummarySpectraS3Request.PoolHealth = poolHealth
    return getSystemCapacitySummarySpectraS3Request
}

func (getSystemCapacitySummarySpectraS3Request *GetSystemCapacitySummarySpectraS3Request) WithPoolState(poolState PoolState) *GetSystemCapacitySummarySpectraS3Request {
    getSystemCapacitySummarySpectraS3Request.PoolState = poolState
    return getSystemCapacitySummarySpectraS3Request
}

func (getSystemCapacitySummarySpectraS3Request *GetSystemCapacitySummarySpectraS3Request) WithPoolType(poolType PoolType) *GetSystemCapacitySummarySpectraS3Request {
    getSystemCapacitySummarySpectraS3Request.PoolType = poolType
    return getSystemCapacitySummarySpectraS3Request
}

func (getSystemCapacitySummarySpectraS3Request *GetSystemCapacitySummarySpectraS3Request) WithTapeState(tapeState TapeState) *GetSystemCapacitySummarySpectraS3Request {
    getSystemCapacitySummarySpectraS3Request.TapeState = tapeState
    return getSystemCapacitySummarySpectraS3Request
}

func (getSystemCapacitySummarySpectraS3Request *GetSystemCapacitySummarySpectraS3Request) WithTapeType(tapeType string) *GetSystemCapacitySummarySpectraS3Request {
    getSystemCapacitySummarySpectraS3Request.TapeType = &tapeType
    return getSystemCapacitySummarySpectraS3Request
}

type GetSystemCapacitySummarySpectraS3Response struct {
    CapacitySummaryContainer CapacitySummaryContainer
    Headers *http.Header
}

func (getSystemCapacitySummarySpectraS3Response *GetSystemCapacitySummarySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSystemCapacitySummarySpectraS3Response.CapacitySummaryContainer)
}

func NewGetSystemCapacitySummarySpectraS3Response(webResponse WebResponse) (*GetSystemCapacitySummarySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSystemCapacitySummarySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSystemFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetSystemFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetSystemFailureNotificationRegistrationSpectraS3Request {
    return &GetSystemFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetSystemFailureNotificationRegistrationSpectraS3Response struct {
    SystemFailureNotificationRegistration SystemFailureNotificationRegistration
    Headers *http.Header
}

func (getSystemFailureNotificationRegistrationSpectraS3Response *GetSystemFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSystemFailureNotificationRegistrationSpectraS3Response.SystemFailureNotificationRegistration)
}

func NewGetSystemFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetSystemFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSystemFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSystemFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetSystemFailureNotificationRegistrationsSpectraS3Request() *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    return &GetSystemFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getSystemFailureNotificationRegistrationsSpectraS3Request *GetSystemFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    getSystemFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getSystemFailureNotificationRegistrationsSpectraS3Request
}

func (getSystemFailureNotificationRegistrationsSpectraS3Request *GetSystemFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    getSystemFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getSystemFailureNotificationRegistrationsSpectraS3Request
}

func (getSystemFailureNotificationRegistrationsSpectraS3Request *GetSystemFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    getSystemFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getSystemFailureNotificationRegistrationsSpectraS3Request
}

func (getSystemFailureNotificationRegistrationsSpectraS3Request *GetSystemFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    getSystemFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSystemFailureNotificationRegistrationsSpectraS3Request
}

func (getSystemFailureNotificationRegistrationsSpectraS3Request *GetSystemFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetSystemFailureNotificationRegistrationsSpectraS3Request {
    getSystemFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getSystemFailureNotificationRegistrationsSpectraS3Request
}

type GetSystemFailureNotificationRegistrationsSpectraS3Response struct {
    SystemFailureNotificationRegistrationList SystemFailureNotificationRegistrationList
    Headers *http.Header
}

func (getSystemFailureNotificationRegistrationsSpectraS3Response *GetSystemFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSystemFailureNotificationRegistrationsSpectraS3Response.SystemFailureNotificationRegistrationList)
}

func NewGetSystemFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetSystemFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSystemFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSystemFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    SystemFailureType SystemFailureType
}

func NewGetSystemFailuresSpectraS3Request() *GetSystemFailuresSpectraS3Request {
    return &GetSystemFailuresSpectraS3Request{
    }
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getSystemFailuresSpectraS3Request
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithLastPage() *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.LastPage = true
    return getSystemFailuresSpectraS3Request
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithPageLength(pageLength int) *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.PageLength = &pageLength
    return getSystemFailuresSpectraS3Request
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.PageOffset = &pageOffset
    return getSystemFailuresSpectraS3Request
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getSystemFailuresSpectraS3Request
}

func (getSystemFailuresSpectraS3Request *GetSystemFailuresSpectraS3Request) WithSystemFailureType(systemFailureType SystemFailureType) *GetSystemFailuresSpectraS3Request {
    getSystemFailuresSpectraS3Request.SystemFailureType = systemFailureType
    return getSystemFailuresSpectraS3Request
}

type GetSystemFailuresSpectraS3Response struct {
    SystemFailureList SystemFailureList
    Headers *http.Header
}

func (getSystemFailuresSpectraS3Response *GetSystemFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSystemFailuresSpectraS3Response.SystemFailureList)
}

func NewGetSystemFailuresSpectraS3Response(webResponse WebResponse) (*GetSystemFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSystemFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetSystemInformationSpectraS3Request struct {
}

func NewGetSystemInformationSpectraS3Request() *GetSystemInformationSpectraS3Request {
    return &GetSystemInformationSpectraS3Request{
    }
}

type GetSystemInformationSpectraS3Response struct {
    SystemInformation SystemInformation
    Headers *http.Header
}

func (getSystemInformationSpectraS3Response *GetSystemInformationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getSystemInformationSpectraS3Response.SystemInformation)
}

func NewGetSystemInformationSpectraS3Response(webResponse WebResponse) (*GetSystemInformationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetSystemInformationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeDensityDirectiveSpectraS3Request struct {
    TapeDensityDirective string
}

func NewGetTapeDensityDirectiveSpectraS3Request(tapeDensityDirective string) *GetTapeDensityDirectiveSpectraS3Request {
    return &GetTapeDensityDirectiveSpectraS3Request{
        TapeDensityDirective: tapeDensityDirective,
    }
}

type GetTapeDensityDirectiveSpectraS3Response struct {
    TapeDensityDirective TapeDensityDirective
    Headers *http.Header
}

func (getTapeDensityDirectiveSpectraS3Response *GetTapeDensityDirectiveSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeDensityDirectiveSpectraS3Response.TapeDensityDirective)
}

func NewGetTapeDensityDirectiveSpectraS3Response(webResponse WebResponse) (*GetTapeDensityDirectiveSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeDensityDirectiveSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeDensityDirectivesSpectraS3Request struct {
    Density TapeDriveType
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PartitionId *string
    TapeType *string
}

func NewGetTapeDensityDirectivesSpectraS3Request() *GetTapeDensityDirectivesSpectraS3Request {
    return &GetTapeDensityDirectivesSpectraS3Request{
    }
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithDensity(density TapeDriveType) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.Density = density
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithLastPage() *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.LastPage = true
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithPageLength(pageLength int) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.PageLength = &pageLength
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithPageOffset(pageOffset int) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.PageOffset = &pageOffset
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithPartitionId(partitionId string) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.PartitionId = &partitionId
    return getTapeDensityDirectivesSpectraS3Request
}

func (getTapeDensityDirectivesSpectraS3Request *GetTapeDensityDirectivesSpectraS3Request) WithTapeType(tapeType string) *GetTapeDensityDirectivesSpectraS3Request {
    getTapeDensityDirectivesSpectraS3Request.TapeType = &tapeType
    return getTapeDensityDirectivesSpectraS3Request
}

type GetTapeDensityDirectivesSpectraS3Response struct {
    TapeDensityDirectiveList TapeDensityDirectiveList
    Headers *http.Header
}

func (getTapeDensityDirectivesSpectraS3Response *GetTapeDensityDirectivesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeDensityDirectivesSpectraS3Response.TapeDensityDirectiveList)
}

func NewGetTapeDensityDirectivesSpectraS3Response(webResponse WebResponse) (*GetTapeDensityDirectivesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeDensityDirectivesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeDriveSpectraS3Request struct {
    TapeDriveId string
}

func NewGetTapeDriveSpectraS3Request(tapeDriveId string) *GetTapeDriveSpectraS3Request {
    return &GetTapeDriveSpectraS3Request{
        TapeDriveId: tapeDriveId,
    }
}

type GetTapeDriveSpectraS3Response struct {
    TapeDrive TapeDrive
    Headers *http.Header
}

func (getTapeDriveSpectraS3Response *GetTapeDriveSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeDriveSpectraS3Response.TapeDrive)
}

func NewGetTapeDriveSpectraS3Response(webResponse WebResponse) (*GetTapeDriveSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeDriveSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeDrivesSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PartitionId *string
    SerialNumber *string
    State TapeDriveState
    TapeDriveType TapeDriveType
}

func NewGetTapeDrivesSpectraS3Request() *GetTapeDrivesSpectraS3Request {
    return &GetTapeDrivesSpectraS3Request{
    }
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithLastPage() *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.LastPage = true
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithPageLength(pageLength int) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.PageLength = &pageLength
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithPageOffset(pageOffset int) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.PageOffset = &pageOffset
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithPartitionId(partitionId string) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.PartitionId = &partitionId
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithSerialNumber(serialNumber string) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.SerialNumber = &serialNumber
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithState(state TapeDriveState) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.State = state
    return getTapeDrivesSpectraS3Request
}

func (getTapeDrivesSpectraS3Request *GetTapeDrivesSpectraS3Request) WithTapeDriveType(tapeDriveType TapeDriveType) *GetTapeDrivesSpectraS3Request {
    getTapeDrivesSpectraS3Request.TapeDriveType = tapeDriveType
    return getTapeDrivesSpectraS3Request
}

type GetTapeDrivesSpectraS3Response struct {
    TapeDriveList TapeDriveList
    Headers *http.Header
}

func (getTapeDrivesSpectraS3Response *GetTapeDrivesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeDrivesSpectraS3Response.TapeDriveList)
}

func NewGetTapeDrivesSpectraS3Response(webResponse WebResponse) (*GetTapeDrivesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeDrivesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetTapeFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetTapeFailureNotificationRegistrationSpectraS3Request {
    return &GetTapeFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetTapeFailureNotificationRegistrationSpectraS3Response struct {
    TapeFailureNotificationRegistration TapeFailureNotificationRegistration
    Headers *http.Header
}

func (getTapeFailureNotificationRegistrationSpectraS3Response *GetTapeFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeFailureNotificationRegistrationSpectraS3Response.TapeFailureNotificationRegistration)
}

func NewGetTapeFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetTapeFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetTapeFailureNotificationRegistrationsSpectraS3Request() *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    return &GetTapeFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getTapeFailureNotificationRegistrationsSpectraS3Request *GetTapeFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    getTapeFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getTapeFailureNotificationRegistrationsSpectraS3Request
}

func (getTapeFailureNotificationRegistrationsSpectraS3Request *GetTapeFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    getTapeFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getTapeFailureNotificationRegistrationsSpectraS3Request
}

func (getTapeFailureNotificationRegistrationsSpectraS3Request *GetTapeFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    getTapeFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getTapeFailureNotificationRegistrationsSpectraS3Request
}

func (getTapeFailureNotificationRegistrationsSpectraS3Request *GetTapeFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    getTapeFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapeFailureNotificationRegistrationsSpectraS3Request
}

func (getTapeFailureNotificationRegistrationsSpectraS3Request *GetTapeFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetTapeFailureNotificationRegistrationsSpectraS3Request {
    getTapeFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getTapeFailureNotificationRegistrationsSpectraS3Request
}

type GetTapeFailureNotificationRegistrationsSpectraS3Response struct {
    TapeFailureNotificationRegistrationList TapeFailureNotificationRegistrationList
    Headers *http.Header
}

func (getTapeFailureNotificationRegistrationsSpectraS3Response *GetTapeFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeFailureNotificationRegistrationsSpectraS3Response.TapeFailureNotificationRegistrationList)
}

func NewGetTapeFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetTapeFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    TapeDriveId *string
    TapeFailureType TapeFailureType
    TapeId *string
}

func NewGetTapeFailuresSpectraS3Request() *GetTapeFailuresSpectraS3Request {
    return &GetTapeFailuresSpectraS3Request{
    }
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithLastPage() *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.LastPage = true
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithPageLength(pageLength int) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.PageLength = &pageLength
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.PageOffset = &pageOffset
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithTapeDriveId(tapeDriveId string) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.TapeDriveId = &tapeDriveId
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithTapeId(tapeId string) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.TapeId = &tapeId
    return getTapeFailuresSpectraS3Request
}

func (getTapeFailuresSpectraS3Request *GetTapeFailuresSpectraS3Request) WithTapeFailureType(tapeFailureType TapeFailureType) *GetTapeFailuresSpectraS3Request {
    getTapeFailuresSpectraS3Request.TapeFailureType = tapeFailureType
    return getTapeFailuresSpectraS3Request
}

type GetTapeFailuresSpectraS3Response struct {
    DetailedTapeFailureList DetailedTapeFailureList
    Headers *http.Header
}

func (getTapeFailuresSpectraS3Response *GetTapeFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeFailuresSpectraS3Response.DetailedTapeFailureList)
}

func NewGetTapeFailuresSpectraS3Response(webResponse WebResponse) (*GetTapeFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeLibrariesSpectraS3Request struct {
    LastPage bool
    ManagementUrl *string
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    SerialNumber *string
}

func NewGetTapeLibrariesSpectraS3Request() *GetTapeLibrariesSpectraS3Request {
    return &GetTapeLibrariesSpectraS3Request{
    }
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithLastPage() *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.LastPage = true
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithManagementUrl(managementUrl string) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.ManagementUrl = &managementUrl
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithName(name string) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.Name = &name
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithPageLength(pageLength int) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.PageLength = &pageLength
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithPageOffset(pageOffset int) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.PageOffset = &pageOffset
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapeLibrariesSpectraS3Request
}

func (getTapeLibrariesSpectraS3Request *GetTapeLibrariesSpectraS3Request) WithSerialNumber(serialNumber string) *GetTapeLibrariesSpectraS3Request {
    getTapeLibrariesSpectraS3Request.SerialNumber = &serialNumber
    return getTapeLibrariesSpectraS3Request
}

type GetTapeLibrariesSpectraS3Response struct {
    TapeLibraryList TapeLibraryList
    Headers *http.Header
}

func (getTapeLibrariesSpectraS3Response *GetTapeLibrariesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeLibrariesSpectraS3Response.TapeLibraryList)
}

func NewGetTapeLibrariesSpectraS3Response(webResponse WebResponse) (*GetTapeLibrariesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeLibrariesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeLibrarySpectraS3Request struct {
    TapeLibraryId string
}

func NewGetTapeLibrarySpectraS3Request(tapeLibraryId string) *GetTapeLibrarySpectraS3Request {
    return &GetTapeLibrarySpectraS3Request{
        TapeLibraryId: tapeLibraryId,
    }
}

type GetTapeLibrarySpectraS3Response struct {
    TapeLibrary TapeLibrary
    Headers *http.Header
}

func (getTapeLibrarySpectraS3Response *GetTapeLibrarySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeLibrarySpectraS3Response.TapeLibrary)
}

func NewGetTapeLibrarySpectraS3Response(webResponse WebResponse) (*GetTapeLibrarySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeLibrarySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionFailureNotificationRegistrationSpectraS3Request struct {
    NotificationId string
}

func NewGetTapePartitionFailureNotificationRegistrationSpectraS3Request(notificationId string) *GetTapePartitionFailureNotificationRegistrationSpectraS3Request {
    return &GetTapePartitionFailureNotificationRegistrationSpectraS3Request{
        NotificationId: notificationId,
    }
}

type GetTapePartitionFailureNotificationRegistrationSpectraS3Response struct {
    TapePartitionFailureNotificationRegistration TapePartitionFailureNotificationRegistration
    Headers *http.Header
}

func (getTapePartitionFailureNotificationRegistrationSpectraS3Response *GetTapePartitionFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionFailureNotificationRegistrationSpectraS3Response.TapePartitionFailureNotificationRegistration)
}

func NewGetTapePartitionFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*GetTapePartitionFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionFailureNotificationRegistrationsSpectraS3Request struct {
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    UserId *string
}

func NewGetTapePartitionFailureNotificationRegistrationsSpectraS3Request() *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    return &GetTapePartitionFailureNotificationRegistrationsSpectraS3Request{
    }
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Request *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request) WithLastPage() *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    getTapePartitionFailureNotificationRegistrationsSpectraS3Request.LastPage = true
    return getTapePartitionFailureNotificationRegistrationsSpectraS3Request
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Request *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request) WithPageLength(pageLength int) *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    getTapePartitionFailureNotificationRegistrationsSpectraS3Request.PageLength = &pageLength
    return getTapePartitionFailureNotificationRegistrationsSpectraS3Request
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Request *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request) WithPageOffset(pageOffset int) *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    getTapePartitionFailureNotificationRegistrationsSpectraS3Request.PageOffset = &pageOffset
    return getTapePartitionFailureNotificationRegistrationsSpectraS3Request
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Request *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    getTapePartitionFailureNotificationRegistrationsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapePartitionFailureNotificationRegistrationsSpectraS3Request
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Request *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request) WithUserId(userId string) *GetTapePartitionFailureNotificationRegistrationsSpectraS3Request {
    getTapePartitionFailureNotificationRegistrationsSpectraS3Request.UserId = &userId
    return getTapePartitionFailureNotificationRegistrationsSpectraS3Request
}

type GetTapePartitionFailureNotificationRegistrationsSpectraS3Response struct {
    TapePartitionFailureNotificationRegistrationList TapePartitionFailureNotificationRegistrationList
    Headers *http.Header
}

func (getTapePartitionFailureNotificationRegistrationsSpectraS3Response *GetTapePartitionFailureNotificationRegistrationsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionFailureNotificationRegistrationsSpectraS3Response.TapePartitionFailureNotificationRegistrationList)
}

func NewGetTapePartitionFailureNotificationRegistrationsSpectraS3Response(webResponse WebResponse) (*GetTapePartitionFailureNotificationRegistrationsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionFailureNotificationRegistrationsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionFailuresSpectraS3Request struct {
    ErrorMessage *string
    LastPage bool
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PartitionId *string
    TapePartitionFailureType TapePartitionFailureType
}

func NewGetTapePartitionFailuresSpectraS3Request() *GetTapePartitionFailuresSpectraS3Request {
    return &GetTapePartitionFailuresSpectraS3Request{
    }
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithErrorMessage(errorMessage string) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.ErrorMessage = &errorMessage
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithLastPage() *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.LastPage = true
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithPageLength(pageLength int) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.PageLength = &pageLength
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithPageOffset(pageOffset int) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.PageOffset = &pageOffset
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithPartitionId(partitionId string) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.PartitionId = &partitionId
    return getTapePartitionFailuresSpectraS3Request
}

func (getTapePartitionFailuresSpectraS3Request *GetTapePartitionFailuresSpectraS3Request) WithTapePartitionFailureType(tapePartitionFailureType TapePartitionFailureType) *GetTapePartitionFailuresSpectraS3Request {
    getTapePartitionFailuresSpectraS3Request.TapePartitionFailureType = tapePartitionFailureType
    return getTapePartitionFailuresSpectraS3Request
}

type GetTapePartitionFailuresSpectraS3Response struct {
    TapePartitionFailureList TapePartitionFailureList
    Headers *http.Header
}

func (getTapePartitionFailuresSpectraS3Response *GetTapePartitionFailuresSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionFailuresSpectraS3Response.TapePartitionFailureList)
}

func NewGetTapePartitionFailuresSpectraS3Response(webResponse WebResponse) (*GetTapePartitionFailuresSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionFailuresSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionSpectraS3Request struct {
    TapePartition string
}

func NewGetTapePartitionSpectraS3Request(tapePartition string) *GetTapePartitionSpectraS3Request {
    return &GetTapePartitionSpectraS3Request{
        TapePartition: tapePartition,
    }
}

type GetTapePartitionSpectraS3Response struct {
    TapePartition TapePartition
    Headers *http.Header
}

func (getTapePartitionSpectraS3Response *GetTapePartitionSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionSpectraS3Response.TapePartition)
}

func NewGetTapePartitionSpectraS3Response(webResponse WebResponse) (*GetTapePartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionWithFullDetailsSpectraS3Request struct {
    TapePartition string
}

func NewGetTapePartitionWithFullDetailsSpectraS3Request(tapePartition string) *GetTapePartitionWithFullDetailsSpectraS3Request {
    return &GetTapePartitionWithFullDetailsSpectraS3Request{
        TapePartition: tapePartition,
    }
}

type GetTapePartitionWithFullDetailsSpectraS3Response struct {
    DetailedTapePartition DetailedTapePartition
    Headers *http.Header
}

func (getTapePartitionWithFullDetailsSpectraS3Response *GetTapePartitionWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionWithFullDetailsSpectraS3Response.DetailedTapePartition)
}

func NewGetTapePartitionWithFullDetailsSpectraS3Response(webResponse WebResponse) (*GetTapePartitionWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionsSpectraS3Request struct {
    ImportExportConfiguration ImportExportConfiguration
    LastPage bool
    LibraryId *string
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Quiesced Quiesced
    SerialNumber *string
    State TapePartitionState
}

func NewGetTapePartitionsSpectraS3Request() *GetTapePartitionsSpectraS3Request {
    return &GetTapePartitionsSpectraS3Request{
    }
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithImportExportConfiguration(importExportConfiguration ImportExportConfiguration) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.ImportExportConfiguration = importExportConfiguration
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithLastPage() *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.LastPage = true
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithLibraryId(libraryId string) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.LibraryId = &libraryId
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithName(name string) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.Name = &name
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithPageLength(pageLength int) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.PageLength = &pageLength
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithPageOffset(pageOffset int) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.PageOffset = &pageOffset
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithQuiesced(quiesced Quiesced) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.Quiesced = quiesced
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithSerialNumber(serialNumber string) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.SerialNumber = &serialNumber
    return getTapePartitionsSpectraS3Request
}

func (getTapePartitionsSpectraS3Request *GetTapePartitionsSpectraS3Request) WithState(state TapePartitionState) *GetTapePartitionsSpectraS3Request {
    getTapePartitionsSpectraS3Request.State = state
    return getTapePartitionsSpectraS3Request
}

type GetTapePartitionsSpectraS3Response struct {
    TapePartitionList TapePartitionList
    Headers *http.Header
}

func (getTapePartitionsSpectraS3Response *GetTapePartitionsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionsSpectraS3Response.TapePartitionList)
}

func NewGetTapePartitionsSpectraS3Response(webResponse WebResponse) (*GetTapePartitionsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapePartitionsWithFullDetailsSpectraS3Request struct {
    ImportExportConfiguration ImportExportConfiguration
    LastPage bool
    LibraryId *string
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    Quiesced Quiesced
    SerialNumber *string
    State TapePartitionState
}

func NewGetTapePartitionsWithFullDetailsSpectraS3Request() *GetTapePartitionsWithFullDetailsSpectraS3Request {
    return &GetTapePartitionsWithFullDetailsSpectraS3Request{
    }
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithImportExportConfiguration(importExportConfiguration ImportExportConfiguration) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.ImportExportConfiguration = importExportConfiguration
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithLastPage() *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.LastPage = true
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithLibraryId(libraryId string) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.LibraryId = &libraryId
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithName(name string) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.Name = &name
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithPageLength(pageLength int) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.PageLength = &pageLength
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithPageOffset(pageOffset int) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.PageOffset = &pageOffset
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithQuiesced(quiesced Quiesced) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.Quiesced = quiesced
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithSerialNumber(serialNumber string) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.SerialNumber = &serialNumber
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

func (getTapePartitionsWithFullDetailsSpectraS3Request *GetTapePartitionsWithFullDetailsSpectraS3Request) WithState(state TapePartitionState) *GetTapePartitionsWithFullDetailsSpectraS3Request {
    getTapePartitionsWithFullDetailsSpectraS3Request.State = state
    return getTapePartitionsWithFullDetailsSpectraS3Request
}

type GetTapePartitionsWithFullDetailsSpectraS3Response struct {
    NamedDetailedTapePartitionList NamedDetailedTapePartitionList
    Headers *http.Header
}

func (getTapePartitionsWithFullDetailsSpectraS3Response *GetTapePartitionsWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapePartitionsWithFullDetailsSpectraS3Response.NamedDetailedTapePartitionList)
}

func NewGetTapePartitionsWithFullDetailsSpectraS3Response(webResponse WebResponse) (*GetTapePartitionsWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapePartitionsWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapeSpectraS3Request struct {
    TapeId string
}

func NewGetTapeSpectraS3Request(tapeId string) *GetTapeSpectraS3Request {
    return &GetTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type GetTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (getTapeSpectraS3Response *GetTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapeSpectraS3Response.Tape)
}

func NewGetTapeSpectraS3Response(webResponse WebResponse) (*GetTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetTapesSpectraS3Request struct {
    AssignedToStorageDomain *bool
    AvailableRawCapacity *int64
    BarCode *string
    BucketId *string
    EjectLabel *string
    EjectLocation *string
    FullOfData *bool
    LastPage bool
    LastVerified *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
    PartiallyVerifiedEndOfTape *string
    PartitionId *string
    PreviousState TapeState
    SerialNumber *string
    SortBy *string
    State TapeState
    StorageDomainId *string
    String *string
    VerifyPending Priority
    WriteProtected *bool
}

func NewGetTapesSpectraS3Request() *GetTapesSpectraS3Request {
    return &GetTapesSpectraS3Request{
    }
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithAssignedToStorageDomain(assignedToStorageDomain bool) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.AssignedToStorageDomain = &assignedToStorageDomain
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithAvailableRawCapacity(availableRawCapacity int64) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.AvailableRawCapacity = &availableRawCapacity
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithBarCode(barCode string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.BarCode = &barCode
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithBucketId(bucketId string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.BucketId = &bucketId
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithEjectLabel(ejectLabel string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.EjectLabel = &ejectLabel
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithEjectLocation(ejectLocation string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.EjectLocation = &ejectLocation
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithFullOfData(fullOfData bool) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.FullOfData = &fullOfData
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithLastPage() *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.LastPage = true
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithLastVerified(lastVerified string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.LastVerified = &lastVerified
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPageLength(pageLength int) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PageLength = &pageLength
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPageOffset(pageOffset int) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PageOffset = &pageOffset
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PageStartMarker = &pageStartMarker
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPartiallyVerifiedEndOfTape(partiallyVerifiedEndOfTape string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PartiallyVerifiedEndOfTape = &partiallyVerifiedEndOfTape
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPartitionId(partitionId string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PartitionId = &partitionId
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithPreviousState(previousState TapeState) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.PreviousState = previousState
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithSerialNumber(serialNumber string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.SerialNumber = &serialNumber
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithSortBy(sortBy string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.SortBy = &sortBy
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithState(state TapeState) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.State = state
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithStorageDomainId(storageDomainId string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.StorageDomainId = &storageDomainId
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithString(string string) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.String = &string
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithVerifyPending(verifyPending Priority) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.VerifyPending = verifyPending
    return getTapesSpectraS3Request
}

func (getTapesSpectraS3Request *GetTapesSpectraS3Request) WithWriteProtected(writeProtected bool) *GetTapesSpectraS3Request {
    getTapesSpectraS3Request.WriteProtected = &writeProtected
    return getTapesSpectraS3Request
}

type GetTapesSpectraS3Response struct {
    TapeList TapeList
    Headers *http.Header
}

func (getTapesSpectraS3Response *GetTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getTapesSpectraS3Response.TapeList)
}

func NewGetTapesSpectraS3Response(webResponse WebResponse) (*GetTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetUserSpectraS3Request struct {
    UserId string
}

func NewGetUserSpectraS3Request(userId string) *GetUserSpectraS3Request {
    return &GetUserSpectraS3Request{
        UserId: userId,
    }
}

type GetUserSpectraS3Response struct {
    SpectraUser SpectraUser
    Headers *http.Header
}

func (getUserSpectraS3Response *GetUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getUserSpectraS3Response.SpectraUser)
}

func NewGetUserSpectraS3Response(webResponse WebResponse) (*GetUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type GetUsersSpectraS3Request struct {
    AuthId *string
    DefaultDataPolicyId *string
    LastPage bool
    Name *string
    PageLength *int
    PageOffset *int
    PageStartMarker *string
}

func NewGetUsersSpectraS3Request() *GetUsersSpectraS3Request {
    return &GetUsersSpectraS3Request{
    }
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithAuthId(authId string) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.AuthId = &authId
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithDefaultDataPolicyId(defaultDataPolicyId string) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.DefaultDataPolicyId = &defaultDataPolicyId
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithLastPage() *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.LastPage = true
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithName(name string) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.Name = &name
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithPageLength(pageLength int) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.PageLength = &pageLength
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithPageOffset(pageOffset int) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.PageOffset = &pageOffset
    return getUsersSpectraS3Request
}

func (getUsersSpectraS3Request *GetUsersSpectraS3Request) WithPageStartMarker(pageStartMarker string) *GetUsersSpectraS3Request {
    getUsersSpectraS3Request.PageStartMarker = &pageStartMarker
    return getUsersSpectraS3Request
}

type GetUsersSpectraS3Response struct {
    SpectraUserList SpectraUserList
    Headers *http.Header
}

func (getUsersSpectraS3Response *GetUsersSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &getUsersSpectraS3Response.SpectraUserList)
}

func NewGetUsersSpectraS3Response(webResponse WebResponse) (*GetUsersSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body GetUsersSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type Group struct {
    BuiltIn bool
    Id string
    Name *string
}
type GroupList struct {
    Groups []Group
}
func (groupList *GroupList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Group":
            var model Group
            model.parse(&child, aggErr)
            groupList.Groups = append(groupList.Groups, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing GroupList.", child.XMLName.Local)
        }
    }
}
type GroupMember struct {
    GroupId string
    Id string
    MemberGroupId *string
    MemberUserId *string
}
type GroupMemberList struct {
    GroupMembers []GroupMember
}
func (groupMemberList *GroupMemberList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "GroupMember":
            var model GroupMember
            model.parse(&child, aggErr)
            groupMemberList.GroupMembers = append(groupMemberList.GroupMembers, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing GroupMemberList.", child.XMLName.Local)
        }
    }
}
func (groupMember *GroupMember) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "GroupId":
            groupMember.GroupId = parseString(child.Content)
        case "Id":
            groupMember.Id = parseString(child.Content)
        case "MemberGroupId":
            groupMember.MemberGroupId = parseNullableString(child.Content)
        case "MemberUserId":
            groupMember.MemberUserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing GroupMember.", child.XMLName.Local)
        }
    }
}
func (group *Group) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BuiltIn":
            group.BuiltIn = parseBool(child.Content, aggErr)
        case "Id":
            group.Id = parseString(child.Content)
        case "Name":
            group.Name = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Group.", child.XMLName.Local)
        }
    }
}
type HeadBucketRequest struct {
    BucketName string
}

func NewHeadBucketRequest(bucketName string) *HeadBucketRequest {
    return &HeadBucketRequest{
        BucketName: bucketName,
    }
}

type HeadBucketResponse struct {
    
    Headers *http.Header
}



func NewHeadBucketResponse(webResponse WebResponse) (*HeadBucketResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &HeadBucketResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type HeadObjectRequest struct {
    BucketName string
    ObjectName string
}

func NewHeadObjectRequest(bucketName string, objectName string) *HeadObjectRequest {
    return &HeadObjectRequest{
        BucketName: bucketName,
        ObjectName: objectName,
    }
}

type HeadObjectResponse struct {
    
    Headers *http.Header
}



func NewHeadObjectResponse(webResponse WebResponse) (*HeadObjectResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &HeadObjectResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type HealthVerificationResult struct {
    DatabaseFilesystemFreeSpace DatabasePhysicalSpaceState
    MsRequiredToVerifyDataPlannerHealth int64
}
func (healthVerificationResult *HealthVerificationResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DatabaseFilesystemFreeSpace":
            parseEnum(child.Content, &healthVerificationResult.DatabaseFilesystemFreeSpace, aggErr)
        case "MsRequiredToVerifyDataPlannerHealth":
            healthVerificationResult.MsRequiredToVerifyDataPlannerHealth = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing HealthVerificationResult.", child.XMLName.Local)
        }
    }
}
type HttpResponseFormatType Enum

const (
    HTTP_RESPONSE_FORMAT_TYPE_DEFAULT HttpResponseFormatType = 1 + iota
    HTTP_RESPONSE_FORMAT_TYPE_JSON HttpResponseFormatType = 1 + iota
    HTTP_RESPONSE_FORMAT_TYPE_XML HttpResponseFormatType = 1 + iota
)

func (httpResponseFormatType *HttpResponseFormatType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *httpResponseFormatType = UNDEFINED
        case "DEFAULT": *httpResponseFormatType = HTTP_RESPONSE_FORMAT_TYPE_DEFAULT
        case "JSON": *httpResponseFormatType = HTTP_RESPONSE_FORMAT_TYPE_JSON
        case "XML": *httpResponseFormatType = HTTP_RESPONSE_FORMAT_TYPE_XML
        default:
            *httpResponseFormatType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into HttpResponseFormatType", str))
    }
    return nil
}

func (httpResponseFormatType HttpResponseFormatType) String() string {
    switch httpResponseFormatType {
        case HTTP_RESPONSE_FORMAT_TYPE_DEFAULT: return "DEFAULT"
        case HTTP_RESPONSE_FORMAT_TYPE_JSON: return "JSON"
        case HTTP_RESPONSE_FORMAT_TYPE_XML: return "XML"
        default:
            log.Printf("Error: invalid HttpResponseFormatType represented by '%d'", httpResponseFormatType)
            return ""
    }
}

func (httpResponseFormatType HttpResponseFormatType) StringPtr() *string {
    if httpResponseFormatType == UNDEFINED {
        return nil
    }
    result := httpResponseFormatType.String()
    return &result
}
type ImportAllPoolsSpectraS3Request struct {
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Priority Priority
    StorageDomainId *string
    UserId *string
    VerifyDataAfterImport Priority
    VerifyDataPriorToImport *bool
}

func NewImportAllPoolsSpectraS3Request() *ImportAllPoolsSpectraS3Request {
    return &ImportAllPoolsSpectraS3Request{
    }
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.DataPolicyId = &dataPolicyId
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithPriority(priority Priority) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.Priority = priority
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithStorageDomainId(storageDomainId string) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.StorageDomainId = &storageDomainId
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithUserId(userId string) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.UserId = &userId
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithVerifyDataAfterImport(verifyDataAfterImport Priority) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.VerifyDataAfterImport = verifyDataAfterImport
    return importAllPoolsSpectraS3Request
}

func (importAllPoolsSpectraS3Request *ImportAllPoolsSpectraS3Request) WithVerifyDataPriorToImport(verifyDataPriorToImport bool) *ImportAllPoolsSpectraS3Request {
    importAllPoolsSpectraS3Request.VerifyDataPriorToImport = &verifyDataPriorToImport
    return importAllPoolsSpectraS3Request
}

type ImportAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewImportAllPoolsSpectraS3Response(webResponse WebResponse) (*ImportAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ImportAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ImportAllTapesSpectraS3Request struct {
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Priority Priority
    StorageDomainId *string
    UserId *string
    VerifyDataAfterImport Priority
    VerifyDataPriorToImport *bool
}

func NewImportAllTapesSpectraS3Request() *ImportAllTapesSpectraS3Request {
    return &ImportAllTapesSpectraS3Request{
    }
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.DataPolicyId = &dataPolicyId
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithPriority(priority Priority) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.Priority = priority
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithStorageDomainId(storageDomainId string) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.StorageDomainId = &storageDomainId
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithUserId(userId string) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.UserId = &userId
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithVerifyDataAfterImport(verifyDataAfterImport Priority) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.VerifyDataAfterImport = verifyDataAfterImport
    return importAllTapesSpectraS3Request
}

func (importAllTapesSpectraS3Request *ImportAllTapesSpectraS3Request) WithVerifyDataPriorToImport(verifyDataPriorToImport bool) *ImportAllTapesSpectraS3Request {
    importAllTapesSpectraS3Request.VerifyDataPriorToImport = &verifyDataPriorToImport
    return importAllTapesSpectraS3Request
}

type ImportAllTapesSpectraS3Response struct {
    
    Headers *http.Header
}



func NewImportAllTapesSpectraS3Response(webResponse WebResponse) (*ImportAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ImportAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ImportAzureTargetSpectraS3Request struct {
    AzureTarget string
    CloudBucketName string
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Priority Priority
    UserId *string
}

func NewImportAzureTargetSpectraS3Request(azureTarget string, cloudBucketName string) *ImportAzureTargetSpectraS3Request {
    return &ImportAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
        CloudBucketName: cloudBucketName,
    }
}

func (importAzureTargetSpectraS3Request *ImportAzureTargetSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportAzureTargetSpectraS3Request {
    importAzureTargetSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importAzureTargetSpectraS3Request
}

func (importAzureTargetSpectraS3Request *ImportAzureTargetSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportAzureTargetSpectraS3Request {
    importAzureTargetSpectraS3Request.DataPolicyId = &dataPolicyId
    return importAzureTargetSpectraS3Request
}

func (importAzureTargetSpectraS3Request *ImportAzureTargetSpectraS3Request) WithPriority(priority Priority) *ImportAzureTargetSpectraS3Request {
    importAzureTargetSpectraS3Request.Priority = priority
    return importAzureTargetSpectraS3Request
}

func (importAzureTargetSpectraS3Request *ImportAzureTargetSpectraS3Request) WithUserId(userId string) *ImportAzureTargetSpectraS3Request {
    importAzureTargetSpectraS3Request.UserId = &userId
    return importAzureTargetSpectraS3Request
}

type ImportAzureTargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewImportAzureTargetSpectraS3Response(webResponse WebResponse) (*ImportAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ImportAzureTargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ImportConflictResolutionMode Enum

const (
    IMPORT_CONFLICT_RESOLUTION_MODE_CANCEL ImportConflictResolutionMode = 1 + iota
    IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_MOST_RECENT ImportConflictResolutionMode = 1 + iota
    IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_EXISTING ImportConflictResolutionMode = 1 + iota
)

func (importConflictResolutionMode *ImportConflictResolutionMode) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *importConflictResolutionMode = UNDEFINED
        case "CANCEL": *importConflictResolutionMode = IMPORT_CONFLICT_RESOLUTION_MODE_CANCEL
        case "ACCEPT_MOST_RECENT": *importConflictResolutionMode = IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_MOST_RECENT
        case "ACCEPT_EXISTING": *importConflictResolutionMode = IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_EXISTING
        default:
            *importConflictResolutionMode = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into ImportConflictResolutionMode", str))
    }
    return nil
}

func (importConflictResolutionMode ImportConflictResolutionMode) String() string {
    switch importConflictResolutionMode {
        case IMPORT_CONFLICT_RESOLUTION_MODE_CANCEL: return "CANCEL"
        case IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_MOST_RECENT: return "ACCEPT_MOST_RECENT"
        case IMPORT_CONFLICT_RESOLUTION_MODE_ACCEPT_EXISTING: return "ACCEPT_EXISTING"
        default:
            log.Printf("Error: invalid ImportConflictResolutionMode represented by '%d'", importConflictResolutionMode)
            return ""
    }
}

func (importConflictResolutionMode ImportConflictResolutionMode) StringPtr() *string {
    if importConflictResolutionMode == UNDEFINED {
        return nil
    }
    result := importConflictResolutionMode.String()
    return &result
}
type ImportExportConfiguration Enum

const (
    IMPORT_EXPORT_CONFIGURATION_SUPPORTED ImportExportConfiguration = 1 + iota
    IMPORT_EXPORT_CONFIGURATION_NOT_SUPPORTED ImportExportConfiguration = 1 + iota
)

func (importExportConfiguration *ImportExportConfiguration) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *importExportConfiguration = UNDEFINED
        case "SUPPORTED": *importExportConfiguration = IMPORT_EXPORT_CONFIGURATION_SUPPORTED
        case "NOT_SUPPORTED": *importExportConfiguration = IMPORT_EXPORT_CONFIGURATION_NOT_SUPPORTED
        default:
            *importExportConfiguration = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into ImportExportConfiguration", str))
    }
    return nil
}

func (importExportConfiguration ImportExportConfiguration) String() string {
    switch importExportConfiguration {
        case IMPORT_EXPORT_CONFIGURATION_SUPPORTED: return "SUPPORTED"
        case IMPORT_EXPORT_CONFIGURATION_NOT_SUPPORTED: return "NOT_SUPPORTED"
        default:
            log.Printf("Error: invalid ImportExportConfiguration represented by '%d'", importExportConfiguration)
            return ""
    }
}

func (importExportConfiguration ImportExportConfiguration) StringPtr() *string {
    if importExportConfiguration == UNDEFINED {
        return nil
    }
    result := importExportConfiguration.String()
    return &result
}
type ImportPoolSpectraS3Request struct {
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Pool string
    Priority Priority
    StorageDomainId *string
    UserId *string
    VerifyDataAfterImport Priority
    VerifyDataPriorToImport *bool
}

func NewImportPoolSpectraS3Request(pool string) *ImportPoolSpectraS3Request {
    return &ImportPoolSpectraS3Request{
        Pool: pool,
    }
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.DataPolicyId = &dataPolicyId
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithPriority(priority Priority) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.Priority = priority
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithStorageDomainId(storageDomainId string) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.StorageDomainId = &storageDomainId
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithUserId(userId string) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.UserId = &userId
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithVerifyDataAfterImport(verifyDataAfterImport Priority) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.VerifyDataAfterImport = verifyDataAfterImport
    return importPoolSpectraS3Request
}

func (importPoolSpectraS3Request *ImportPoolSpectraS3Request) WithVerifyDataPriorToImport(verifyDataPriorToImport bool) *ImportPoolSpectraS3Request {
    importPoolSpectraS3Request.VerifyDataPriorToImport = &verifyDataPriorToImport
    return importPoolSpectraS3Request
}

type ImportPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (importPoolSpectraS3Response *ImportPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &importPoolSpectraS3Response.Pool)
}

func NewImportPoolSpectraS3Response(webResponse WebResponse) (*ImportPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ImportPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ImportS3TargetSpectraS3Request struct {
    CloudBucketName string
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Priority Priority
    S3Target string
    UserId *string
}

func NewImportS3TargetSpectraS3Request(cloudBucketName string, s3Target string) *ImportS3TargetSpectraS3Request {
    return &ImportS3TargetSpectraS3Request{
        S3Target: s3Target,
        CloudBucketName: cloudBucketName,
    }
}

func (importS3TargetSpectraS3Request *ImportS3TargetSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportS3TargetSpectraS3Request {
    importS3TargetSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importS3TargetSpectraS3Request
}

func (importS3TargetSpectraS3Request *ImportS3TargetSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportS3TargetSpectraS3Request {
    importS3TargetSpectraS3Request.DataPolicyId = &dataPolicyId
    return importS3TargetSpectraS3Request
}

func (importS3TargetSpectraS3Request *ImportS3TargetSpectraS3Request) WithPriority(priority Priority) *ImportS3TargetSpectraS3Request {
    importS3TargetSpectraS3Request.Priority = priority
    return importS3TargetSpectraS3Request
}

func (importS3TargetSpectraS3Request *ImportS3TargetSpectraS3Request) WithUserId(userId string) *ImportS3TargetSpectraS3Request {
    importS3TargetSpectraS3Request.UserId = &userId
    return importS3TargetSpectraS3Request
}

type ImportS3TargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewImportS3TargetSpectraS3Response(webResponse WebResponse) (*ImportS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ImportS3TargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ImportTapeSpectraS3Request struct {
    ConflictResolutionMode ImportConflictResolutionMode
    DataPolicyId *string
    Priority Priority
    StorageDomainId *string
    TapeId string
    UserId *string
    VerifyDataAfterImport Priority
    VerifyDataPriorToImport *bool
}

func NewImportTapeSpectraS3Request(tapeId string) *ImportTapeSpectraS3Request {
    return &ImportTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithConflictResolutionMode(conflictResolutionMode ImportConflictResolutionMode) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.ConflictResolutionMode = conflictResolutionMode
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.DataPolicyId = &dataPolicyId
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithPriority(priority Priority) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.Priority = priority
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithStorageDomainId(storageDomainId string) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.StorageDomainId = &storageDomainId
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithUserId(userId string) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.UserId = &userId
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithVerifyDataAfterImport(verifyDataAfterImport Priority) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.VerifyDataAfterImport = verifyDataAfterImport
    return importTapeSpectraS3Request
}

func (importTapeSpectraS3Request *ImportTapeSpectraS3Request) WithVerifyDataPriorToImport(verifyDataPriorToImport bool) *ImportTapeSpectraS3Request {
    importTapeSpectraS3Request.VerifyDataPriorToImport = &verifyDataPriorToImport
    return importTapeSpectraS3Request
}

type ImportTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (importTapeSpectraS3Response *ImportTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &importTapeSpectraS3Response.Tape)
}

func NewImportTapeSpectraS3Response(webResponse WebResponse) (*ImportTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ImportTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type InitiateMultiPartUploadRequest struct {
    BucketName string
    ObjectName string
}

func NewInitiateMultiPartUploadRequest(bucketName string, objectName string) *InitiateMultiPartUploadRequest {
    return &InitiateMultiPartUploadRequest{
        BucketName: bucketName,
        ObjectName: objectName,
    }
}

type InitiateMultiPartUploadResponse struct {
    InitiateMultipartUploadResult InitiateMultipartUploadResult
    Headers *http.Header
}

func (initiateMultiPartUploadResponse *InitiateMultiPartUploadResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &initiateMultiPartUploadResponse.InitiateMultipartUploadResult)
}

func NewInitiateMultiPartUploadResponse(webResponse WebResponse) (*InitiateMultiPartUploadResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body InitiateMultiPartUploadResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type InitiateMultipartUploadResult struct {
    Bucket *string
    Key *string
    UploadId *string
}
func (initiateMultipartUploadResult *InitiateMultipartUploadResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Bucket":
            initiateMultipartUploadResult.Bucket = parseNullableString(child.Content)
        case "Key":
            initiateMultipartUploadResult.Key = parseNullableString(child.Content)
        case "UploadId":
            initiateMultipartUploadResult.UploadId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing InitiateMultipartUploadResult.", child.XMLName.Local)
        }
    }
}
type InspectAllTapesSpectraS3Request struct {
    TaskPriority Priority
}

func NewInspectAllTapesSpectraS3Request() *InspectAllTapesSpectraS3Request {
    return &InspectAllTapesSpectraS3Request{
    }
}

func (inspectAllTapesSpectraS3Request *InspectAllTapesSpectraS3Request) WithTaskPriority(taskPriority Priority) *InspectAllTapesSpectraS3Request {
    inspectAllTapesSpectraS3Request.TaskPriority = taskPriority
    return inspectAllTapesSpectraS3Request
}

type InspectAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (inspectAllTapesSpectraS3Response *InspectAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, inspectAllTapesSpectraS3Response.TapeFailureList)
}

func NewInspectAllTapesSpectraS3Response(webResponse WebResponse) (*InspectAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &InspectAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body InspectAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type InspectTapeSpectraS3Request struct {
    TapeId string
    TaskPriority Priority
}

func NewInspectTapeSpectraS3Request(tapeId string) *InspectTapeSpectraS3Request {
    return &InspectTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (inspectTapeSpectraS3Request *InspectTapeSpectraS3Request) WithTaskPriority(taskPriority Priority) *InspectTapeSpectraS3Request {
    inspectTapeSpectraS3Request.TaskPriority = taskPriority
    return inspectTapeSpectraS3Request
}

type InspectTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (inspectTapeSpectraS3Response *InspectTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &inspectTapeSpectraS3Response.Tape)
}

func NewInspectTapeSpectraS3Response(webResponse WebResponse) (*InspectTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body InspectTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type Job struct {
    Aggregating bool
    BucketName *string
    CachedSizeInBytes int64
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    CompletedSizeInBytes int64
    EntirelyInCache *bool
    JobId string
    Naked bool
    Name *string
    Nodes []JobNode
    OriginalSizeInBytes int64
    Priority Priority
    RequestType JobRequestType
    StartDate string
    Status JobStatus
    UserId string
    UserName *string
}
type JobChunk struct {
    BlobStoreState JobChunkBlobStoreState
    ChunkNumber int
    Id string
    JobCreationDate string
    JobId string
    NodeId *string
    PendingTargetCommit bool
    ReadFromAzureTargetId *string
    ReadFromDs3TargetId *string
    ReadFromPoolId *string
    ReadFromS3TargetId *string
    ReadFromTapeId *string
}
type JobChunkBlobStoreState Enum

const (
    JOB_CHUNK_BLOB_STORE_STATE_PENDING JobChunkBlobStoreState = 1 + iota
    JOB_CHUNK_BLOB_STORE_STATE_IN_PROGRESS JobChunkBlobStoreState = 1 + iota
    JOB_CHUNK_BLOB_STORE_STATE_COMPLETED JobChunkBlobStoreState = 1 + iota
)

func (jobChunkBlobStoreState *JobChunkBlobStoreState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *jobChunkBlobStoreState = UNDEFINED
        case "PENDING": *jobChunkBlobStoreState = JOB_CHUNK_BLOB_STORE_STATE_PENDING
        case "IN_PROGRESS": *jobChunkBlobStoreState = JOB_CHUNK_BLOB_STORE_STATE_IN_PROGRESS
        case "COMPLETED": *jobChunkBlobStoreState = JOB_CHUNK_BLOB_STORE_STATE_COMPLETED
        default:
            *jobChunkBlobStoreState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into JobChunkBlobStoreState", str))
    }
    return nil
}

func (jobChunkBlobStoreState JobChunkBlobStoreState) String() string {
    switch jobChunkBlobStoreState {
        case JOB_CHUNK_BLOB_STORE_STATE_PENDING: return "PENDING"
        case JOB_CHUNK_BLOB_STORE_STATE_IN_PROGRESS: return "IN_PROGRESS"
        case JOB_CHUNK_BLOB_STORE_STATE_COMPLETED: return "COMPLETED"
        default:
            log.Printf("Error: invalid JobChunkBlobStoreState represented by '%d'", jobChunkBlobStoreState)
            return ""
    }
}

func (jobChunkBlobStoreState JobChunkBlobStoreState) StringPtr() *string {
    if jobChunkBlobStoreState == UNDEFINED {
        return nil
    }
    result := jobChunkBlobStoreState.String()
    return &result
}
type JobChunkClientProcessingOrderGuarantee Enum

const (
    JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_NONE JobChunkClientProcessingOrderGuarantee = 1 + iota
    JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_IN_ORDER JobChunkClientProcessingOrderGuarantee = 1 + iota
)

func (jobChunkClientProcessingOrderGuarantee *JobChunkClientProcessingOrderGuarantee) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *jobChunkClientProcessingOrderGuarantee = UNDEFINED
        case "NONE": *jobChunkClientProcessingOrderGuarantee = JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_NONE
        case "IN_ORDER": *jobChunkClientProcessingOrderGuarantee = JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_IN_ORDER
        default:
            *jobChunkClientProcessingOrderGuarantee = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into JobChunkClientProcessingOrderGuarantee", str))
    }
    return nil
}

func (jobChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) String() string {
    switch jobChunkClientProcessingOrderGuarantee {
        case JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_NONE: return "NONE"
        case JOB_CHUNK_CLIENT_PROCESSING_ORDER_GUARANTEE_IN_ORDER: return "IN_ORDER"
        default:
            log.Printf("Error: invalid JobChunkClientProcessingOrderGuarantee represented by '%d'", jobChunkClientProcessingOrderGuarantee)
            return ""
    }
}

func (jobChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee) StringPtr() *string {
    if jobChunkClientProcessingOrderGuarantee == UNDEFINED {
        return nil
    }
    result := jobChunkClientProcessingOrderGuarantee.String()
    return &result
}
func (jobChunk *JobChunk) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobStoreState":
            parseEnum(child.Content, &jobChunk.BlobStoreState, aggErr)
        case "ChunkNumber":
            jobChunk.ChunkNumber = parseInt(child.Content, aggErr)
        case "Id":
            jobChunk.Id = parseString(child.Content)
        case "JobCreationDate":
            jobChunk.JobCreationDate = parseString(child.Content)
        case "JobId":
            jobChunk.JobId = parseString(child.Content)
        case "NodeId":
            jobChunk.NodeId = parseNullableString(child.Content)
        case "PendingTargetCommit":
            jobChunk.PendingTargetCommit = parseBool(child.Content, aggErr)
        case "ReadFromAzureTargetId":
            jobChunk.ReadFromAzureTargetId = parseNullableString(child.Content)
        case "ReadFromDs3TargetId":
            jobChunk.ReadFromDs3TargetId = parseNullableString(child.Content)
        case "ReadFromPoolId":
            jobChunk.ReadFromPoolId = parseNullableString(child.Content)
        case "ReadFromS3TargetId":
            jobChunk.ReadFromS3TargetId = parseNullableString(child.Content)
        case "ReadFromTapeId":
            jobChunk.ReadFromTapeId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobChunk.", child.XMLName.Local)
        }
    }
}
type JobCompletedNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    JobId *string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type JobCompletedNotificationRegistrationList struct {
    JobCompletedNotificationRegistrations []JobCompletedNotificationRegistration
}
func (jobCompletedNotificationRegistrationList *JobCompletedNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "JobCompletedNotificationRegistration":
            var model JobCompletedNotificationRegistration
            model.parse(&child, aggErr)
            jobCompletedNotificationRegistrationList.JobCompletedNotificationRegistrations = append(jobCompletedNotificationRegistrationList.JobCompletedNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCompletedNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (jobCompletedNotificationRegistration *JobCompletedNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            jobCompletedNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &jobCompletedNotificationRegistration.Format, aggErr)
        case "Id":
            jobCompletedNotificationRegistration.Id = parseString(child.Content)
        case "JobId":
            jobCompletedNotificationRegistration.JobId = parseNullableString(child.Content)
        case "LastFailure":
            jobCompletedNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            jobCompletedNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            jobCompletedNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &jobCompletedNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            jobCompletedNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &jobCompletedNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            jobCompletedNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            jobCompletedNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCompletedNotificationRegistration.", child.XMLName.Local)
        }
    }
}
type JobCreatedNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type JobCreatedNotificationRegistrationList struct {
    JobCreatedNotificationRegistrations []JobCreatedNotificationRegistration
}
func (jobCreatedNotificationRegistrationList *JobCreatedNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "JobCreatedNotificationRegistration":
            var model JobCreatedNotificationRegistration
            model.parse(&child, aggErr)
            jobCreatedNotificationRegistrationList.JobCreatedNotificationRegistrations = append(jobCreatedNotificationRegistrationList.JobCreatedNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCreatedNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (jobCreatedNotificationRegistration *JobCreatedNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            jobCreatedNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &jobCreatedNotificationRegistration.Format, aggErr)
        case "Id":
            jobCreatedNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            jobCreatedNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            jobCreatedNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            jobCreatedNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &jobCreatedNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            jobCreatedNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &jobCreatedNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            jobCreatedNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            jobCreatedNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCreatedNotificationRegistration.", child.XMLName.Local)
        }
    }
}
type JobCreationFailedNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type JobCreationFailedNotificationRegistrationList struct {
    JobCreationFailedNotificationRegistrations []JobCreationFailedNotificationRegistration
}
func (jobCreationFailedNotificationRegistrationList *JobCreationFailedNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "JobCreationFailedNotificationRegistration":
            var model JobCreationFailedNotificationRegistration
            model.parse(&child, aggErr)
            jobCreationFailedNotificationRegistrationList.JobCreationFailedNotificationRegistrations = append(jobCreationFailedNotificationRegistrationList.JobCreationFailedNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCreationFailedNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (jobCreationFailedNotificationRegistration *JobCreationFailedNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            jobCreationFailedNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &jobCreationFailedNotificationRegistration.Format, aggErr)
        case "Id":
            jobCreationFailedNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            jobCreationFailedNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            jobCreationFailedNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            jobCreationFailedNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &jobCreationFailedNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            jobCreationFailedNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &jobCreationFailedNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            jobCreationFailedNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            jobCreationFailedNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobCreationFailedNotificationRegistration.", child.XMLName.Local)
        }
    }
}
type JobList struct {
    Jobs []Job
}
func (jobList *JobList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Job":
            var model Job
            model.parse(&child, aggErr)
            jobList.Jobs = append(jobList.Jobs, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing JobList.", child.XMLName.Local)
        }
    }
}
type JobNode struct {
    EndPoint *string
    HttpPort *int
    HttpsPort *int
    Id string
}
func (jobNode *JobNode) parse(xmlNode *XmlNode, aggErr *AggregateError) {
    // Parse Attributes
    for _, attr := range xmlNode.Attrs {
        switch attr.Name.Local {
        case "EndPoint":
            jobNode.EndPoint = parseNullableStringFromString(attr.Value)
        case "HttpPort":
            jobNode.HttpPort = parseNullableIntFromString(attr.Value, aggErr)
        case "HttpsPort":
            jobNode.HttpsPort = parseNullableIntFromString(attr.Value, aggErr)
        case "Id":
            jobNode.Id = attr.Value
        default:
            log.Printf("WARNING: unable to parse unknown attribute '%s' while parsing JobNode.", attr.Name.Local)
        }
    }

}

func parseJobNodeSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []JobNode {
    var result []JobNode
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult JobNode
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing JobNode struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
func (job *Job) parse(xmlNode *XmlNode, aggErr *AggregateError) {
    // Parse Attributes
    for _, attr := range xmlNode.Attrs {
        switch attr.Name.Local {
        case "Aggregating":
            job.Aggregating = parseBoolFromString(attr.Value, aggErr)
        case "BucketName":
            job.BucketName = parseNullableStringFromString(attr.Value)
        case "CachedSizeInBytes":
            job.CachedSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "ChunkClientProcessingOrderGuarantee":
            parseEnumFromString(attr.Value, &job.ChunkClientProcessingOrderGuarantee, aggErr)
        case "CompletedSizeInBytes":
            job.CompletedSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "EntirelyInCache":
            job.EntirelyInCache = parseNullableBoolFromString(attr.Value, aggErr)
        case "JobId":
            job.JobId = attr.Value
        case "Naked":
            job.Naked = parseBoolFromString(attr.Value, aggErr)
        case "Name":
            job.Name = parseNullableStringFromString(attr.Value)
        case "OriginalSizeInBytes":
            job.OriginalSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "Priority":
            parseEnumFromString(attr.Value, &job.Priority, aggErr)
        case "RequestType":
            parseEnumFromString(attr.Value, &job.RequestType, aggErr)
        case "StartDate":
            job.StartDate = attr.Value
        case "Status":
            parseEnumFromString(attr.Value, &job.Status, aggErr)
        case "UserId":
            job.UserId = attr.Value
        case "UserName":
            job.UserName = parseNullableStringFromString(attr.Value)
        default:
            log.Printf("WARNING: unable to parse unknown attribute '%s' while parsing Job.", attr.Name.Local)
        }
    }

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Nodes":
            job.Nodes = parseJobNodeSlice("Node", child.Children, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Job.", child.XMLName.Local)
        }
    }
}

func parseJobSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []Job {
    var result []Job
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult Job
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing Job struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type JobRequestType Enum

const (
    JOB_REQUEST_TYPE_PUT JobRequestType = 1 + iota
    JOB_REQUEST_TYPE_GET JobRequestType = 1 + iota
    JOB_REQUEST_TYPE_VERIFY JobRequestType = 1 + iota
)

func (jobRequestType *JobRequestType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *jobRequestType = UNDEFINED
        case "PUT": *jobRequestType = JOB_REQUEST_TYPE_PUT
        case "GET": *jobRequestType = JOB_REQUEST_TYPE_GET
        case "VERIFY": *jobRequestType = JOB_REQUEST_TYPE_VERIFY
        default:
            *jobRequestType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into JobRequestType", str))
    }
    return nil
}

func (jobRequestType JobRequestType) String() string {
    switch jobRequestType {
        case JOB_REQUEST_TYPE_PUT: return "PUT"
        case JOB_REQUEST_TYPE_GET: return "GET"
        case JOB_REQUEST_TYPE_VERIFY: return "VERIFY"
        default:
            log.Printf("Error: invalid JobRequestType represented by '%d'", jobRequestType)
            return ""
    }
}

func (jobRequestType JobRequestType) StringPtr() *string {
    if jobRequestType == UNDEFINED {
        return nil
    }
    result := jobRequestType.String()
    return &result
}
type JobStatus Enum

const (
    JOB_STATUS_IN_PROGRESS JobStatus = 1 + iota
    JOB_STATUS_COMPLETED JobStatus = 1 + iota
    JOB_STATUS_CANCELED JobStatus = 1 + iota
)

func (jobStatus *JobStatus) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *jobStatus = UNDEFINED
        case "IN_PROGRESS": *jobStatus = JOB_STATUS_IN_PROGRESS
        case "COMPLETED": *jobStatus = JOB_STATUS_COMPLETED
        case "CANCELED": *jobStatus = JOB_STATUS_CANCELED
        default:
            *jobStatus = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into JobStatus", str))
    }
    return nil
}

func (jobStatus JobStatus) String() string {
    switch jobStatus {
        case JOB_STATUS_IN_PROGRESS: return "IN_PROGRESS"
        case JOB_STATUS_COMPLETED: return "COMPLETED"
        case JOB_STATUS_CANCELED: return "CANCELED"
        default:
            log.Printf("Error: invalid JobStatus represented by '%d'", jobStatus)
            return ""
    }
}

func (jobStatus JobStatus) StringPtr() *string {
    if jobStatus == UNDEFINED {
        return nil
    }
    result := jobStatus.String()
    return &result
}
type ListAllMyBucketsResult struct {
    Buckets []BucketDetails
    Owner User
}
func (listAllMyBucketsResult *ListAllMyBucketsResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Buckets":
            listAllMyBucketsResult.Buckets = parseBucketDetailsSlice("Bucket", child.Children, aggErr)
        case "Owner":
            listAllMyBucketsResult.Owner.parse(&child, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ListAllMyBucketsResult.", child.XMLName.Local)
        }
    }
}
type ListBucketResult struct {
    CommonPrefixes []string
    CreationDate *string
    Delimiter *string
    Marker *string
    MaxKeys int
    Name *string
    NextMarker *string
    Objects []Contents
    Prefix *string
    Truncated bool
}
func (listBucketResult *ListBucketResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CommonPrefixes":
            var prefixes []string
            prefixes = parseStringSlice("Prefix", child.Children, aggErr)
            listBucketResult.CommonPrefixes = append(listBucketResult.CommonPrefixes, prefixes...)
        case "CreationDate":
            listBucketResult.CreationDate = parseNullableString(child.Content)
        case "Delimiter":
            listBucketResult.Delimiter = parseNullableString(child.Content)
        case "Marker":
            listBucketResult.Marker = parseNullableString(child.Content)
        case "MaxKeys":
            listBucketResult.MaxKeys = parseInt(child.Content, aggErr)
        case "Name":
            listBucketResult.Name = parseNullableString(child.Content)
        case "NextMarker":
            listBucketResult.NextMarker = parseNullableString(child.Content)
        case "Contents":
            var model Contents
            model.parse(&child, aggErr)
            listBucketResult.Objects = append(listBucketResult.Objects, model)
        case "Prefix":
            listBucketResult.Prefix = parseNullableString(child.Content)
        case "IsTruncated":
            listBucketResult.Truncated = parseBool(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ListBucketResult.", child.XMLName.Local)
        }
    }
}
type ListMultiPartUploadPartsRequest struct {
    BucketName string
    ObjectName string
    MaxParts *int
    PartNumberMarker *int
    UploadId string
}

func NewListMultiPartUploadPartsRequest(bucketName string, objectName string, uploadId string) *ListMultiPartUploadPartsRequest {
    return &ListMultiPartUploadPartsRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        UploadId: uploadId,
    }
}

func (listMultiPartUploadPartsRequest *ListMultiPartUploadPartsRequest) WithMaxParts(maxParts int) *ListMultiPartUploadPartsRequest {
    listMultiPartUploadPartsRequest.MaxParts = &maxParts
    return listMultiPartUploadPartsRequest
}

func (listMultiPartUploadPartsRequest *ListMultiPartUploadPartsRequest) WithPartNumberMarker(partNumberMarker int) *ListMultiPartUploadPartsRequest {
    listMultiPartUploadPartsRequest.PartNumberMarker = &partNumberMarker
    return listMultiPartUploadPartsRequest
}

type ListMultiPartUploadPartsResponse struct {
    ListPartsResult ListPartsResult
    Headers *http.Header
}

func (listMultiPartUploadPartsResponse *ListMultiPartUploadPartsResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &listMultiPartUploadPartsResponse.ListPartsResult)
}

func NewListMultiPartUploadPartsResponse(webResponse WebResponse) (*ListMultiPartUploadPartsResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ListMultiPartUploadPartsResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ListMultiPartUploadsRequest struct {
    BucketName string
    Delimiter *string
    KeyMarker *string
    MaxUploads *int
    Prefix *string
    UploadIdMarker *string
}

func NewListMultiPartUploadsRequest(bucketName string) *ListMultiPartUploadsRequest {
    return &ListMultiPartUploadsRequest{
        BucketName: bucketName,
    }
}

func (listMultiPartUploadsRequest *ListMultiPartUploadsRequest) WithDelimiter(delimiter string) *ListMultiPartUploadsRequest {
    listMultiPartUploadsRequest.Delimiter = &delimiter
    return listMultiPartUploadsRequest
}

func (listMultiPartUploadsRequest *ListMultiPartUploadsRequest) WithKeyMarker(keyMarker string) *ListMultiPartUploadsRequest {
    listMultiPartUploadsRequest.KeyMarker = &keyMarker
    return listMultiPartUploadsRequest
}

func (listMultiPartUploadsRequest *ListMultiPartUploadsRequest) WithMaxUploads(maxUploads int) *ListMultiPartUploadsRequest {
    listMultiPartUploadsRequest.MaxUploads = &maxUploads
    return listMultiPartUploadsRequest
}

func (listMultiPartUploadsRequest *ListMultiPartUploadsRequest) WithPrefix(prefix string) *ListMultiPartUploadsRequest {
    listMultiPartUploadsRequest.Prefix = &prefix
    return listMultiPartUploadsRequest
}

func (listMultiPartUploadsRequest *ListMultiPartUploadsRequest) WithUploadIdMarker(uploadIdMarker string) *ListMultiPartUploadsRequest {
    listMultiPartUploadsRequest.UploadIdMarker = &uploadIdMarker
    return listMultiPartUploadsRequest
}

type ListMultiPartUploadsResponse struct {
    ListMultiPartUploadsResult ListMultiPartUploadsResult
    Headers *http.Header
}

func (listMultiPartUploadsResponse *ListMultiPartUploadsResponse) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &listMultiPartUploadsResponse.ListMultiPartUploadsResult)
}

func NewListMultiPartUploadsResponse(webResponse WebResponse) (*ListMultiPartUploadsResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ListMultiPartUploadsResponse
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ListMultiPartUploadsResult struct {
    Bucket *string
    CommonPrefixes []string
    Delimiter *string
    KeyMarker *string
    MaxUploads int
    NextKeyMarker *string
    NextUploadIdMarker *string
    Prefix *string
    Truncated bool
    UploadIdMarker *string
    Uploads []MultiPartUpload
}
func (listMultiPartUploadsResult *ListMultiPartUploadsResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Bucket":
            listMultiPartUploadsResult.Bucket = parseNullableString(child.Content)
        case "CommonPrefixes":
            var prefixes []string
            prefixes = parseStringSlice("Prefix", child.Children, aggErr)
            listMultiPartUploadsResult.CommonPrefixes = append(listMultiPartUploadsResult.CommonPrefixes, prefixes...)
        case "Delimiter":
            listMultiPartUploadsResult.Delimiter = parseNullableString(child.Content)
        case "KeyMarker":
            listMultiPartUploadsResult.KeyMarker = parseNullableString(child.Content)
        case "MaxUploads":
            listMultiPartUploadsResult.MaxUploads = parseInt(child.Content, aggErr)
        case "NextKeyMarker":
            listMultiPartUploadsResult.NextKeyMarker = parseNullableString(child.Content)
        case "NextUploadIdMarker":
            listMultiPartUploadsResult.NextUploadIdMarker = parseNullableString(child.Content)
        case "Prefix":
            listMultiPartUploadsResult.Prefix = parseNullableString(child.Content)
        case "IsTruncated":
            listMultiPartUploadsResult.Truncated = parseBool(child.Content, aggErr)
        case "UploadIdMarker":
            listMultiPartUploadsResult.UploadIdMarker = parseNullableString(child.Content)
        case "Upload":
            var model MultiPartUpload
            model.parse(&child, aggErr)
            listMultiPartUploadsResult.Uploads = append(listMultiPartUploadsResult.Uploads, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ListMultiPartUploadsResult.", child.XMLName.Local)
        }
    }
}
type ListPartsResult struct {
    Bucket *string
    Key *string
    MaxParts int
    NextPartNumberMarker int
    Owner User
    PartNumberMarker *int
    Parts []MultiPartUploadPart
    Truncated bool
    UploadId string
}
func (listPartsResult *ListPartsResult) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Bucket":
            listPartsResult.Bucket = parseNullableString(child.Content)
        case "Key":
            listPartsResult.Key = parseNullableString(child.Content)
        case "MaxParts":
            listPartsResult.MaxParts = parseInt(child.Content, aggErr)
        case "NextPartNumberMarker":
            listPartsResult.NextPartNumberMarker = parseInt(child.Content, aggErr)
        case "Owner":
            listPartsResult.Owner.parse(&child, aggErr)
        case "PartNumberMarker":
            listPartsResult.PartNumberMarker = parseNullableInt(child.Content, aggErr)
        case "Part":
            var model MultiPartUploadPart
            model.parse(&child, aggErr)
            listPartsResult.Parts = append(listPartsResult.Parts, model)
        case "IsTruncated":
            listPartsResult.Truncated = parseBool(child.Content, aggErr)
        case "UploadId":
            listPartsResult.UploadId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing ListPartsResult.", child.XMLName.Local)
        }
    }
}
type LtfsFileNamingMode Enum

const (
    LTFS_FILE_NAMING_MODE_OBJECT_NAME LtfsFileNamingMode = 1 + iota
    LTFS_FILE_NAMING_MODE_OBJECT_ID LtfsFileNamingMode = 1 + iota
)

func (ltfsFileNamingMode *LtfsFileNamingMode) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *ltfsFileNamingMode = UNDEFINED
        case "OBJECT_NAME": *ltfsFileNamingMode = LTFS_FILE_NAMING_MODE_OBJECT_NAME
        case "OBJECT_ID": *ltfsFileNamingMode = LTFS_FILE_NAMING_MODE_OBJECT_ID
        default:
            *ltfsFileNamingMode = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into LtfsFileNamingMode", str))
    }
    return nil
}

func (ltfsFileNamingMode LtfsFileNamingMode) String() string {
    switch ltfsFileNamingMode {
        case LTFS_FILE_NAMING_MODE_OBJECT_NAME: return "OBJECT_NAME"
        case LTFS_FILE_NAMING_MODE_OBJECT_ID: return "OBJECT_ID"
        default:
            log.Printf("Error: invalid LtfsFileNamingMode represented by '%d'", ltfsFileNamingMode)
            return ""
    }
}

func (ltfsFileNamingMode LtfsFileNamingMode) StringPtr() *string {
    if ltfsFileNamingMode == UNDEFINED {
        return nil
    }
    result := ltfsFileNamingMode.String()
    return &result
}
type MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewMarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request(ids []string) *MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request {
    return &MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request{
        Ids: ids,
    }
}

func (markSuspectBlobAzureTargetsAsDegradedSpectraS3Request *MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request) WithForce() *MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Request {
    markSuspectBlobAzureTargetsAsDegradedSpectraS3Request.Force = true
    return markSuspectBlobAzureTargetsAsDegradedSpectraS3Request
}

type MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Response struct {
    
    Headers *http.Header
}



func NewMarkSuspectBlobAzureTargetsAsDegradedSpectraS3Response(webResponse WebResponse) (*MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &MarkSuspectBlobAzureTargetsAsDegradedSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewMarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request(ids []string) *MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request {
    return &MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request{
        Ids: ids,
    }
}

func (markSuspectBlobDs3TargetsAsDegradedSpectraS3Request *MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request) WithForce() *MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Request {
    markSuspectBlobDs3TargetsAsDegradedSpectraS3Request.Force = true
    return markSuspectBlobDs3TargetsAsDegradedSpectraS3Request
}

type MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Response struct {
    
    Headers *http.Header
}



func NewMarkSuspectBlobDs3TargetsAsDegradedSpectraS3Response(webResponse WebResponse) (*MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &MarkSuspectBlobDs3TargetsAsDegradedSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MarkSuspectBlobPoolsAsDegradedSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewMarkSuspectBlobPoolsAsDegradedSpectraS3Request(ids []string) *MarkSuspectBlobPoolsAsDegradedSpectraS3Request {
    return &MarkSuspectBlobPoolsAsDegradedSpectraS3Request{
        Ids: ids,
    }
}

func (markSuspectBlobPoolsAsDegradedSpectraS3Request *MarkSuspectBlobPoolsAsDegradedSpectraS3Request) WithForce() *MarkSuspectBlobPoolsAsDegradedSpectraS3Request {
    markSuspectBlobPoolsAsDegradedSpectraS3Request.Force = true
    return markSuspectBlobPoolsAsDegradedSpectraS3Request
}

type MarkSuspectBlobPoolsAsDegradedSpectraS3Response struct {
    
    Headers *http.Header
}



func NewMarkSuspectBlobPoolsAsDegradedSpectraS3Response(webResponse WebResponse) (*MarkSuspectBlobPoolsAsDegradedSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &MarkSuspectBlobPoolsAsDegradedSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MarkSuspectBlobS3TargetsAsDegradedSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewMarkSuspectBlobS3TargetsAsDegradedSpectraS3Request(ids []string) *MarkSuspectBlobS3TargetsAsDegradedSpectraS3Request {
    return &MarkSuspectBlobS3TargetsAsDegradedSpectraS3Request{
        Ids: ids,
    }
}

func (markSuspectBlobS3TargetsAsDegradedSpectraS3Request *MarkSuspectBlobS3TargetsAsDegradedSpectraS3Request) WithForce() *MarkSuspectBlobS3TargetsAsDegradedSpectraS3Request {
    markSuspectBlobS3TargetsAsDegradedSpectraS3Request.Force = true
    return markSuspectBlobS3TargetsAsDegradedSpectraS3Request
}

type MarkSuspectBlobS3TargetsAsDegradedSpectraS3Response struct {
    
    Headers *http.Header
}



func NewMarkSuspectBlobS3TargetsAsDegradedSpectraS3Response(webResponse WebResponse) (*MarkSuspectBlobS3TargetsAsDegradedSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &MarkSuspectBlobS3TargetsAsDegradedSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MarkSuspectBlobTapesAsDegradedSpectraS3Request struct {
    Force bool
    Ids []string
}

func NewMarkSuspectBlobTapesAsDegradedSpectraS3Request(ids []string) *MarkSuspectBlobTapesAsDegradedSpectraS3Request {
    return &MarkSuspectBlobTapesAsDegradedSpectraS3Request{
        Ids: ids,
    }
}

func (markSuspectBlobTapesAsDegradedSpectraS3Request *MarkSuspectBlobTapesAsDegradedSpectraS3Request) WithForce() *MarkSuspectBlobTapesAsDegradedSpectraS3Request {
    markSuspectBlobTapesAsDegradedSpectraS3Request.Force = true
    return markSuspectBlobTapesAsDegradedSpectraS3Request
}

type MarkSuspectBlobTapesAsDegradedSpectraS3Response struct {
    
    Headers *http.Header
}



func NewMarkSuspectBlobTapesAsDegradedSpectraS3Response(webResponse WebResponse) (*MarkSuspectBlobTapesAsDegradedSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &MarkSuspectBlobTapesAsDegradedSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MasterObjectList struct {
    Aggregating bool
    BucketName *string
    CachedSizeInBytes int64
    ChunkClientProcessingOrderGuarantee JobChunkClientProcessingOrderGuarantee
    CompletedSizeInBytes int64
    EntirelyInCache *bool
    JobId string
    Naked bool
    Name *string
    Nodes []JobNode
    Objects []Objects
    OriginalSizeInBytes int64
    Priority Priority
    RequestType JobRequestType
    StartDate string
    Status JobStatus
    UserId string
    UserName *string
}
func (masterObjectList *MasterObjectList) parse(xmlNode *XmlNode, aggErr *AggregateError) {
    // Parse Attributes
    for _, attr := range xmlNode.Attrs {
        switch attr.Name.Local {
        case "Aggregating":
            masterObjectList.Aggregating = parseBoolFromString(attr.Value, aggErr)
        case "BucketName":
            masterObjectList.BucketName = parseNullableStringFromString(attr.Value)
        case "CachedSizeInBytes":
            masterObjectList.CachedSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "ChunkClientProcessingOrderGuarantee":
            parseEnumFromString(attr.Value, &masterObjectList.ChunkClientProcessingOrderGuarantee, aggErr)
        case "CompletedSizeInBytes":
            masterObjectList.CompletedSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "EntirelyInCache":
            masterObjectList.EntirelyInCache = parseNullableBoolFromString(attr.Value, aggErr)
        case "JobId":
            masterObjectList.JobId = attr.Value
        case "Naked":
            masterObjectList.Naked = parseBoolFromString(attr.Value, aggErr)
        case "Name":
            masterObjectList.Name = parseNullableStringFromString(attr.Value)
        case "OriginalSizeInBytes":
            masterObjectList.OriginalSizeInBytes = parseInt64FromString(attr.Value, aggErr)
        case "Priority":
            parseEnumFromString(attr.Value, &masterObjectList.Priority, aggErr)
        case "RequestType":
            parseEnumFromString(attr.Value, &masterObjectList.RequestType, aggErr)
        case "StartDate":
            masterObjectList.StartDate = attr.Value
        case "Status":
            parseEnumFromString(attr.Value, &masterObjectList.Status, aggErr)
        case "UserId":
            masterObjectList.UserId = attr.Value
        case "UserName":
            masterObjectList.UserName = parseNullableStringFromString(attr.Value)
        default:
            log.Printf("WARNING: unable to parse unknown attribute '%s' while parsing MasterObjectList.", attr.Name.Local)
        }
    }

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Nodes":
            masterObjectList.Nodes = parseJobNodeSlice("Node", child.Children, aggErr)
        case "Objects":
            var model Objects
            model.parse(&child, aggErr)
            masterObjectList.Objects = append(masterObjectList.Objects, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing MasterObjectList.", child.XMLName.Local)
        }
    }
}
type ModifyActiveJobSpectraS3Request struct {
    ActiveJobId string
    CreatedAt *string
    Name *string
    Priority Priority
}

func NewModifyActiveJobSpectraS3Request(activeJobId string) *ModifyActiveJobSpectraS3Request {
    return &ModifyActiveJobSpectraS3Request{
        ActiveJobId: activeJobId,
    }
}

func (modifyActiveJobSpectraS3Request *ModifyActiveJobSpectraS3Request) WithCreatedAt(createdAt string) *ModifyActiveJobSpectraS3Request {
    modifyActiveJobSpectraS3Request.CreatedAt = &createdAt
    return modifyActiveJobSpectraS3Request
}

func (modifyActiveJobSpectraS3Request *ModifyActiveJobSpectraS3Request) WithName(name string) *ModifyActiveJobSpectraS3Request {
    modifyActiveJobSpectraS3Request.Name = &name
    return modifyActiveJobSpectraS3Request
}

func (modifyActiveJobSpectraS3Request *ModifyActiveJobSpectraS3Request) WithPriority(priority Priority) *ModifyActiveJobSpectraS3Request {
    modifyActiveJobSpectraS3Request.Priority = priority
    return modifyActiveJobSpectraS3Request
}

type ModifyActiveJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (modifyActiveJobSpectraS3Response *ModifyActiveJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyActiveJobSpectraS3Response.MasterObjectList)
}

func NewModifyActiveJobSpectraS3Response(webResponse WebResponse) (*ModifyActiveJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyActiveJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAllAzureTargetsSpectraS3Request struct {
    Quiesced Quiesced
}

func NewModifyAllAzureTargetsSpectraS3Request(quiesced Quiesced) *ModifyAllAzureTargetsSpectraS3Request {
    return &ModifyAllAzureTargetsSpectraS3Request{
        Quiesced: quiesced,
    }
}

type ModifyAllAzureTargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewModifyAllAzureTargetsSpectraS3Response(webResponse WebResponse) (*ModifyAllAzureTargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ModifyAllAzureTargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAllDs3TargetsSpectraS3Request struct {
    Quiesced Quiesced
}

func NewModifyAllDs3TargetsSpectraS3Request(quiesced Quiesced) *ModifyAllDs3TargetsSpectraS3Request {
    return &ModifyAllDs3TargetsSpectraS3Request{
        Quiesced: quiesced,
    }
}

type ModifyAllDs3TargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewModifyAllDs3TargetsSpectraS3Response(webResponse WebResponse) (*ModifyAllDs3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ModifyAllDs3TargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAllPoolsSpectraS3Request struct {
    Quiesced Quiesced
}

func NewModifyAllPoolsSpectraS3Request(quiesced Quiesced) *ModifyAllPoolsSpectraS3Request {
    return &ModifyAllPoolsSpectraS3Request{
        Quiesced: quiesced,
    }
}

type ModifyAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewModifyAllPoolsSpectraS3Response(webResponse WebResponse) (*ModifyAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ModifyAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAllS3TargetsSpectraS3Request struct {
    Quiesced Quiesced
}

func NewModifyAllS3TargetsSpectraS3Request(quiesced Quiesced) *ModifyAllS3TargetsSpectraS3Request {
    return &ModifyAllS3TargetsSpectraS3Request{
        Quiesced: quiesced,
    }
}

type ModifyAllS3TargetsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewModifyAllS3TargetsSpectraS3Response(webResponse WebResponse) (*ModifyAllS3TargetsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ModifyAllS3TargetsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAllTapePartitionsSpectraS3Request struct {
    Quiesced Quiesced
}

func NewModifyAllTapePartitionsSpectraS3Request(quiesced Quiesced) *ModifyAllTapePartitionsSpectraS3Request {
    return &ModifyAllTapePartitionsSpectraS3Request{
        Quiesced: quiesced,
    }
}

type ModifyAllTapePartitionsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewModifyAllTapePartitionsSpectraS3Response(webResponse WebResponse) (*ModifyAllTapePartitionsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &ModifyAllTapePartitionsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAzureDataReplicationRuleSpectraS3Request struct {
    AzureDataReplicationRule string
    DataReplicationRuleType DataReplicationRuleType
    MaxBlobPartSizeInBytes *int64
    ReplicateDeletes *bool
}

func NewModifyAzureDataReplicationRuleSpectraS3Request(azureDataReplicationRule string) *ModifyAzureDataReplicationRuleSpectraS3Request {
    return &ModifyAzureDataReplicationRuleSpectraS3Request{
        AzureDataReplicationRule: azureDataReplicationRule,
    }
}

func (modifyAzureDataReplicationRuleSpectraS3Request *ModifyAzureDataReplicationRuleSpectraS3Request) WithMaxBlobPartSizeInBytes(maxBlobPartSizeInBytes int64) *ModifyAzureDataReplicationRuleSpectraS3Request {
    modifyAzureDataReplicationRuleSpectraS3Request.MaxBlobPartSizeInBytes = &maxBlobPartSizeInBytes
    return modifyAzureDataReplicationRuleSpectraS3Request
}

func (modifyAzureDataReplicationRuleSpectraS3Request *ModifyAzureDataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *ModifyAzureDataReplicationRuleSpectraS3Request {
    modifyAzureDataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return modifyAzureDataReplicationRuleSpectraS3Request
}

func (modifyAzureDataReplicationRuleSpectraS3Request *ModifyAzureDataReplicationRuleSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *ModifyAzureDataReplicationRuleSpectraS3Request {
    modifyAzureDataReplicationRuleSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return modifyAzureDataReplicationRuleSpectraS3Request
}

type ModifyAzureDataReplicationRuleSpectraS3Response struct {
    AzureDataReplicationRule AzureDataReplicationRule
    Headers *http.Header
}

func (modifyAzureDataReplicationRuleSpectraS3Response *ModifyAzureDataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyAzureDataReplicationRuleSpectraS3Response.AzureDataReplicationRule)
}

func NewModifyAzureDataReplicationRuleSpectraS3Response(webResponse WebResponse) (*ModifyAzureDataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyAzureDataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyAzureTargetSpectraS3Request struct {
    AccountKey *string
    AccountName *string
    AutoVerifyFrequencyInDays *int
    AzureTarget string
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    Name *string
    PermitGoingOutOfSync *bool
    Quiesced Quiesced
}

func NewModifyAzureTargetSpectraS3Request(azureTarget string) *ModifyAzureTargetSpectraS3Request {
    return &ModifyAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
    }
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithAccountKey(accountKey string) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.AccountKey = &accountKey
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithAccountName(accountName string) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.AccountName = &accountName
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithAutoVerifyFrequencyInDays(autoVerifyFrequencyInDays int) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.AutoVerifyFrequencyInDays = &autoVerifyFrequencyInDays
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithCloudBucketPrefix(cloudBucketPrefix string) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.CloudBucketPrefix = &cloudBucketPrefix
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithCloudBucketSuffix(cloudBucketSuffix string) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.CloudBucketSuffix = &cloudBucketSuffix
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithHttps(https bool) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.Https = &https
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithName(name string) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.Name = &name
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return modifyAzureTargetSpectraS3Request
}

func (modifyAzureTargetSpectraS3Request *ModifyAzureTargetSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyAzureTargetSpectraS3Request {
    modifyAzureTargetSpectraS3Request.Quiesced = quiesced
    return modifyAzureTargetSpectraS3Request
}

type ModifyAzureTargetSpectraS3Response struct {
    AzureTarget AzureTarget
    Headers *http.Header
}

func (modifyAzureTargetSpectraS3Response *ModifyAzureTargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyAzureTargetSpectraS3Response.AzureTarget)
}

func NewModifyAzureTargetSpectraS3Response(webResponse WebResponse) (*ModifyAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyAzureTargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyBucketSpectraS3Request struct {
    BucketName string
    DataPolicyId *string
    UserId *string
}

func NewModifyBucketSpectraS3Request(bucketName string) *ModifyBucketSpectraS3Request {
    return &ModifyBucketSpectraS3Request{
        BucketName: bucketName,
    }
}

func (modifyBucketSpectraS3Request *ModifyBucketSpectraS3Request) WithDataPolicyId(dataPolicyId string) *ModifyBucketSpectraS3Request {
    modifyBucketSpectraS3Request.DataPolicyId = &dataPolicyId
    return modifyBucketSpectraS3Request
}

func (modifyBucketSpectraS3Request *ModifyBucketSpectraS3Request) WithUserId(userId string) *ModifyBucketSpectraS3Request {
    modifyBucketSpectraS3Request.UserId = &userId
    return modifyBucketSpectraS3Request
}

type ModifyBucketSpectraS3Response struct {
    Bucket Bucket
    Headers *http.Header
}

func (modifyBucketSpectraS3Response *ModifyBucketSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyBucketSpectraS3Response.Bucket)
}

func NewModifyBucketSpectraS3Response(webResponse WebResponse) (*ModifyBucketSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyBucketSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyCacheFilesystemSpectraS3Request struct {
    AutoReclaimInitiateThreshold *float64
    AutoReclaimTerminateThreshold *float64
    BurstThreshold *float64
    CacheFilesystem string
    MaxCapacityInBytes *int64
}

func NewModifyCacheFilesystemSpectraS3Request(cacheFilesystem string) *ModifyCacheFilesystemSpectraS3Request {
    return &ModifyCacheFilesystemSpectraS3Request{
        CacheFilesystem: cacheFilesystem,
    }
}

func (modifyCacheFilesystemSpectraS3Request *ModifyCacheFilesystemSpectraS3Request) WithAutoReclaimInitiateThreshold(autoReclaimInitiateThreshold float64) *ModifyCacheFilesystemSpectraS3Request {
    modifyCacheFilesystemSpectraS3Request.AutoReclaimInitiateThreshold = &autoReclaimInitiateThreshold
    return modifyCacheFilesystemSpectraS3Request
}

func (modifyCacheFilesystemSpectraS3Request *ModifyCacheFilesystemSpectraS3Request) WithAutoReclaimTerminateThreshold(autoReclaimTerminateThreshold float64) *ModifyCacheFilesystemSpectraS3Request {
    modifyCacheFilesystemSpectraS3Request.AutoReclaimTerminateThreshold = &autoReclaimTerminateThreshold
    return modifyCacheFilesystemSpectraS3Request
}

func (modifyCacheFilesystemSpectraS3Request *ModifyCacheFilesystemSpectraS3Request) WithBurstThreshold(burstThreshold float64) *ModifyCacheFilesystemSpectraS3Request {
    modifyCacheFilesystemSpectraS3Request.BurstThreshold = &burstThreshold
    return modifyCacheFilesystemSpectraS3Request
}

func (modifyCacheFilesystemSpectraS3Request *ModifyCacheFilesystemSpectraS3Request) WithMaxCapacityInBytes(maxCapacityInBytes int64) *ModifyCacheFilesystemSpectraS3Request {
    modifyCacheFilesystemSpectraS3Request.MaxCapacityInBytes = &maxCapacityInBytes
    return modifyCacheFilesystemSpectraS3Request
}

type ModifyCacheFilesystemSpectraS3Response struct {
    CacheFilesystem CacheFilesystem
    Headers *http.Header
}

func (modifyCacheFilesystemSpectraS3Response *ModifyCacheFilesystemSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyCacheFilesystemSpectraS3Response.CacheFilesystem)
}

func NewModifyCacheFilesystemSpectraS3Response(webResponse WebResponse) (*ModifyCacheFilesystemSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyCacheFilesystemSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyDataPathBackendSpectraS3Request struct {
    Activated *bool
    AutoActivateTimeoutInMins *int
    AutoInspect AutoInspectMode
    DefaultImportConflictResolutionMode ImportConflictResolutionMode
    DefaultVerifyDataAfterImport Priority
    DefaultVerifyDataPriorToImport *bool
    PartiallyVerifyLastPercentOfTapes *int
    UnavailableMediaPolicy UnavailableMediaUsagePolicy
    UnavailablePoolMaxJobRetryInMins *int
    UnavailableTapePartitionMaxJobRetryInMins *int
}

func NewModifyDataPathBackendSpectraS3Request() *ModifyDataPathBackendSpectraS3Request {
    return &ModifyDataPathBackendSpectraS3Request{
    }
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithActivated(activated bool) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.Activated = &activated
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithAutoActivateTimeoutInMins(autoActivateTimeoutInMins int) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.AutoActivateTimeoutInMins = &autoActivateTimeoutInMins
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithAutoInspect(autoInspect AutoInspectMode) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.AutoInspect = autoInspect
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithDefaultImportConflictResolutionMode(defaultImportConflictResolutionMode ImportConflictResolutionMode) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.DefaultImportConflictResolutionMode = defaultImportConflictResolutionMode
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithDefaultVerifyDataAfterImport(defaultVerifyDataAfterImport Priority) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.DefaultVerifyDataAfterImport = defaultVerifyDataAfterImport
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithDefaultVerifyDataPriorToImport(defaultVerifyDataPriorToImport bool) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.DefaultVerifyDataPriorToImport = &defaultVerifyDataPriorToImport
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithPartiallyVerifyLastPercentOfTapes(partiallyVerifyLastPercentOfTapes int) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.PartiallyVerifyLastPercentOfTapes = &partiallyVerifyLastPercentOfTapes
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithUnavailableMediaPolicy(unavailableMediaPolicy UnavailableMediaUsagePolicy) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.UnavailableMediaPolicy = unavailableMediaPolicy
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithUnavailablePoolMaxJobRetryInMins(unavailablePoolMaxJobRetryInMins int) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.UnavailablePoolMaxJobRetryInMins = &unavailablePoolMaxJobRetryInMins
    return modifyDataPathBackendSpectraS3Request
}

func (modifyDataPathBackendSpectraS3Request *ModifyDataPathBackendSpectraS3Request) WithUnavailableTapePartitionMaxJobRetryInMins(unavailableTapePartitionMaxJobRetryInMins int) *ModifyDataPathBackendSpectraS3Request {
    modifyDataPathBackendSpectraS3Request.UnavailableTapePartitionMaxJobRetryInMins = &unavailableTapePartitionMaxJobRetryInMins
    return modifyDataPathBackendSpectraS3Request
}

type ModifyDataPathBackendSpectraS3Response struct {
    DataPathBackend DataPathBackend
    Headers *http.Header
}

func (modifyDataPathBackendSpectraS3Response *ModifyDataPathBackendSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyDataPathBackendSpectraS3Response.DataPathBackend)
}

func NewModifyDataPathBackendSpectraS3Response(webResponse WebResponse) (*ModifyDataPathBackendSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyDataPathBackendSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyDataPersistenceRuleSpectraS3Request struct {
    DataPersistenceRuleId string
    DataPersistenceRuleType DataPersistenceRuleType
    IsolationLevel DataIsolationLevel
    MinimumDaysToRetain *int
}

func NewModifyDataPersistenceRuleSpectraS3Request(dataPersistenceRuleId string) *ModifyDataPersistenceRuleSpectraS3Request {
    return &ModifyDataPersistenceRuleSpectraS3Request{
        DataPersistenceRuleId: dataPersistenceRuleId,
    }
}

func (modifyDataPersistenceRuleSpectraS3Request *ModifyDataPersistenceRuleSpectraS3Request) WithIsolationLevel(isolationLevel DataIsolationLevel) *ModifyDataPersistenceRuleSpectraS3Request {
    modifyDataPersistenceRuleSpectraS3Request.IsolationLevel = isolationLevel
    return modifyDataPersistenceRuleSpectraS3Request
}

func (modifyDataPersistenceRuleSpectraS3Request *ModifyDataPersistenceRuleSpectraS3Request) WithMinimumDaysToRetain(minimumDaysToRetain int) *ModifyDataPersistenceRuleSpectraS3Request {
    modifyDataPersistenceRuleSpectraS3Request.MinimumDaysToRetain = &minimumDaysToRetain
    return modifyDataPersistenceRuleSpectraS3Request
}

func (modifyDataPersistenceRuleSpectraS3Request *ModifyDataPersistenceRuleSpectraS3Request) WithDataPersistenceRuleType(dataPersistenceRuleType DataPersistenceRuleType) *ModifyDataPersistenceRuleSpectraS3Request {
    modifyDataPersistenceRuleSpectraS3Request.DataPersistenceRuleType = dataPersistenceRuleType
    return modifyDataPersistenceRuleSpectraS3Request
}

type ModifyDataPersistenceRuleSpectraS3Response struct {
    DataPersistenceRule DataPersistenceRule
    Headers *http.Header
}

func (modifyDataPersistenceRuleSpectraS3Response *ModifyDataPersistenceRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyDataPersistenceRuleSpectraS3Response.DataPersistenceRule)
}

func NewModifyDataPersistenceRuleSpectraS3Response(webResponse WebResponse) (*ModifyDataPersistenceRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyDataPersistenceRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyDataPolicySpectraS3Request struct {
    AlwaysForcePutJobCreation *bool
    AlwaysMinimizeSpanningAcrossMedia *bool
    BlobbingEnabled *bool
    ChecksumType ChecksumType
    DataPolicyId string
    DefaultBlobSize *int64
    DefaultGetJobPriority Priority
    DefaultPutJobPriority Priority
    DefaultVerifyAfterWrite *bool
    DefaultVerifyJobPriority Priority
    EndToEndCrcRequired *bool
    Name *string
    RebuildPriority Priority
    Versioning VersioningLevel
}

func NewModifyDataPolicySpectraS3Request(dataPolicyId string) *ModifyDataPolicySpectraS3Request {
    return &ModifyDataPolicySpectraS3Request{
        DataPolicyId: dataPolicyId,
    }
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithAlwaysForcePutJobCreation(alwaysForcePutJobCreation bool) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.AlwaysForcePutJobCreation = &alwaysForcePutJobCreation
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithAlwaysMinimizeSpanningAcrossMedia(alwaysMinimizeSpanningAcrossMedia bool) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.AlwaysMinimizeSpanningAcrossMedia = &alwaysMinimizeSpanningAcrossMedia
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithBlobbingEnabled(blobbingEnabled bool) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.BlobbingEnabled = &blobbingEnabled
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithChecksumType(checksumType ChecksumType) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.ChecksumType = checksumType
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithDefaultBlobSize(defaultBlobSize int64) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.DefaultBlobSize = &defaultBlobSize
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithDefaultGetJobPriority(defaultGetJobPriority Priority) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.DefaultGetJobPriority = defaultGetJobPriority
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithDefaultPutJobPriority(defaultPutJobPriority Priority) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.DefaultPutJobPriority = defaultPutJobPriority
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithDefaultVerifyAfterWrite(defaultVerifyAfterWrite bool) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.DefaultVerifyAfterWrite = &defaultVerifyAfterWrite
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithDefaultVerifyJobPriority(defaultVerifyJobPriority Priority) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.DefaultVerifyJobPriority = defaultVerifyJobPriority
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithEndToEndCrcRequired(endToEndCrcRequired bool) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.EndToEndCrcRequired = &endToEndCrcRequired
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithName(name string) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.Name = &name
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithRebuildPriority(rebuildPriority Priority) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.RebuildPriority = rebuildPriority
    return modifyDataPolicySpectraS3Request
}

func (modifyDataPolicySpectraS3Request *ModifyDataPolicySpectraS3Request) WithVersioning(versioning VersioningLevel) *ModifyDataPolicySpectraS3Request {
    modifyDataPolicySpectraS3Request.Versioning = versioning
    return modifyDataPolicySpectraS3Request
}

type ModifyDataPolicySpectraS3Response struct {
    DataPolicy DataPolicy
    Headers *http.Header
}

func (modifyDataPolicySpectraS3Response *ModifyDataPolicySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyDataPolicySpectraS3Response.DataPolicy)
}

func NewModifyDataPolicySpectraS3Response(webResponse WebResponse) (*ModifyDataPolicySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyDataPolicySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyDs3DataReplicationRuleSpectraS3Request struct {
    DataReplicationRuleType DataReplicationRuleType
    Ds3DataReplicationRule string
    ReplicateDeletes *bool
    TargetDataPolicy *string
}

func NewModifyDs3DataReplicationRuleSpectraS3Request(ds3DataReplicationRule string) *ModifyDs3DataReplicationRuleSpectraS3Request {
    return &ModifyDs3DataReplicationRuleSpectraS3Request{
        Ds3DataReplicationRule: ds3DataReplicationRule,
    }
}

func (modifyDs3DataReplicationRuleSpectraS3Request *ModifyDs3DataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *ModifyDs3DataReplicationRuleSpectraS3Request {
    modifyDs3DataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return modifyDs3DataReplicationRuleSpectraS3Request
}

func (modifyDs3DataReplicationRuleSpectraS3Request *ModifyDs3DataReplicationRuleSpectraS3Request) WithTargetDataPolicy(targetDataPolicy string) *ModifyDs3DataReplicationRuleSpectraS3Request {
    modifyDs3DataReplicationRuleSpectraS3Request.TargetDataPolicy = &targetDataPolicy
    return modifyDs3DataReplicationRuleSpectraS3Request
}

func (modifyDs3DataReplicationRuleSpectraS3Request *ModifyDs3DataReplicationRuleSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *ModifyDs3DataReplicationRuleSpectraS3Request {
    modifyDs3DataReplicationRuleSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return modifyDs3DataReplicationRuleSpectraS3Request
}

type ModifyDs3DataReplicationRuleSpectraS3Response struct {
    Ds3DataReplicationRule Ds3DataReplicationRule
    Headers *http.Header
}

func (modifyDs3DataReplicationRuleSpectraS3Response *ModifyDs3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyDs3DataReplicationRuleSpectraS3Response.Ds3DataReplicationRule)
}

func NewModifyDs3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*ModifyDs3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyDs3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyDs3TargetSpectraS3Request struct {
    AccessControlReplication Ds3TargetAccessControlReplication
    AdminAuthId *string
    AdminSecretKey *string
    DataPathEndPoint *string
    DataPathHttps *bool
    DataPathPort *int
    DataPathProxy *string
    DataPathVerifyCertificate *bool
    DefaultReadPreference TargetReadPreferenceType
    Ds3Target string
    Name *string
    PermitGoingOutOfSync *bool
    Quiesced Quiesced
    ReplicatedUserDefaultDataPolicy *string
}

func NewModifyDs3TargetSpectraS3Request(ds3Target string) *ModifyDs3TargetSpectraS3Request {
    return &ModifyDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithAccessControlReplication(accessControlReplication Ds3TargetAccessControlReplication) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.AccessControlReplication = accessControlReplication
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithAdminAuthId(adminAuthId string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.AdminAuthId = &adminAuthId
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithAdminSecretKey(adminSecretKey string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.AdminSecretKey = &adminSecretKey
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDataPathHttps(dataPathHttps bool) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DataPathHttps = &dataPathHttps
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDataPathPort(dataPathPort int) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DataPathPort = &dataPathPort
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDataPathProxy(dataPathProxy string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DataPathProxy = &dataPathProxy
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDataPathVerifyCertificate(dataPathVerifyCertificate bool) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DataPathVerifyCertificate = &dataPathVerifyCertificate
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithName(name string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.Name = &name
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.Quiesced = quiesced
    return modifyDs3TargetSpectraS3Request
}

func (modifyDs3TargetSpectraS3Request *ModifyDs3TargetSpectraS3Request) WithReplicatedUserDefaultDataPolicy(replicatedUserDefaultDataPolicy string) *ModifyDs3TargetSpectraS3Request {
    modifyDs3TargetSpectraS3Request.ReplicatedUserDefaultDataPolicy = &replicatedUserDefaultDataPolicy
    return modifyDs3TargetSpectraS3Request
}

type ModifyDs3TargetSpectraS3Response struct {
    Ds3Target Ds3Target
    Headers *http.Header
}

func (modifyDs3TargetSpectraS3Response *ModifyDs3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyDs3TargetSpectraS3Response.Ds3Target)
}

func NewModifyDs3TargetSpectraS3Response(webResponse WebResponse) (*ModifyDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyDs3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyGroupSpectraS3Request struct {
    Group string
    Name *string
}

func NewModifyGroupSpectraS3Request(group string) *ModifyGroupSpectraS3Request {
    return &ModifyGroupSpectraS3Request{
        Group: group,
    }
}

func (modifyGroupSpectraS3Request *ModifyGroupSpectraS3Request) WithName(name string) *ModifyGroupSpectraS3Request {
    modifyGroupSpectraS3Request.Name = &name
    return modifyGroupSpectraS3Request
}

type ModifyGroupSpectraS3Response struct {
    Group Group
    Headers *http.Header
}

func (modifyGroupSpectraS3Response *ModifyGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyGroupSpectraS3Response.Group)
}

func NewModifyGroupSpectraS3Response(webResponse WebResponse) (*ModifyGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyJobSpectraS3Request struct {
    CreatedAt *string
    JobId string
    Name *string
    Priority Priority
}

func NewModifyJobSpectraS3Request(jobId string) *ModifyJobSpectraS3Request {
    return &ModifyJobSpectraS3Request{
        JobId: jobId,
    }
}

func (modifyJobSpectraS3Request *ModifyJobSpectraS3Request) WithCreatedAt(createdAt string) *ModifyJobSpectraS3Request {
    modifyJobSpectraS3Request.CreatedAt = &createdAt
    return modifyJobSpectraS3Request
}

func (modifyJobSpectraS3Request *ModifyJobSpectraS3Request) WithName(name string) *ModifyJobSpectraS3Request {
    modifyJobSpectraS3Request.Name = &name
    return modifyJobSpectraS3Request
}

func (modifyJobSpectraS3Request *ModifyJobSpectraS3Request) WithPriority(priority Priority) *ModifyJobSpectraS3Request {
    modifyJobSpectraS3Request.Priority = priority
    return modifyJobSpectraS3Request
}

type ModifyJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (modifyJobSpectraS3Response *ModifyJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyJobSpectraS3Response.MasterObjectList)
}

func NewModifyJobSpectraS3Response(webResponse WebResponse) (*ModifyJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyNodeSpectraS3Request struct {
    DnsName *string
    Name *string
    Node string
}

func NewModifyNodeSpectraS3Request(node string) *ModifyNodeSpectraS3Request {
    return &ModifyNodeSpectraS3Request{
        Node: node,
    }
}

func (modifyNodeSpectraS3Request *ModifyNodeSpectraS3Request) WithDnsName(dnsName string) *ModifyNodeSpectraS3Request {
    modifyNodeSpectraS3Request.DnsName = &dnsName
    return modifyNodeSpectraS3Request
}

func (modifyNodeSpectraS3Request *ModifyNodeSpectraS3Request) WithName(name string) *ModifyNodeSpectraS3Request {
    modifyNodeSpectraS3Request.Name = &name
    return modifyNodeSpectraS3Request
}

type ModifyNodeSpectraS3Response struct {
    Node Node
    Headers *http.Header
}

func (modifyNodeSpectraS3Response *ModifyNodeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyNodeSpectraS3Response.Node)
}

func NewModifyNodeSpectraS3Response(webResponse WebResponse) (*ModifyNodeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyNodeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyPoolPartitionSpectraS3Request struct {
    Name *string
    PoolPartition string
}

func NewModifyPoolPartitionSpectraS3Request(poolPartition string) *ModifyPoolPartitionSpectraS3Request {
    return &ModifyPoolPartitionSpectraS3Request{
        PoolPartition: poolPartition,
    }
}

func (modifyPoolPartitionSpectraS3Request *ModifyPoolPartitionSpectraS3Request) WithName(name string) *ModifyPoolPartitionSpectraS3Request {
    modifyPoolPartitionSpectraS3Request.Name = &name
    return modifyPoolPartitionSpectraS3Request
}

type ModifyPoolPartitionSpectraS3Response struct {
    PoolPartition PoolPartition
    Headers *http.Header
}

func (modifyPoolPartitionSpectraS3Response *ModifyPoolPartitionSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyPoolPartitionSpectraS3Response.PoolPartition)
}

func NewModifyPoolPartitionSpectraS3Response(webResponse WebResponse) (*ModifyPoolPartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyPoolPartitionSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyPoolSpectraS3Request struct {
    PartitionId *string
    Pool string
    Quiesced Quiesced
}

func NewModifyPoolSpectraS3Request(pool string) *ModifyPoolSpectraS3Request {
    return &ModifyPoolSpectraS3Request{
        Pool: pool,
    }
}

func (modifyPoolSpectraS3Request *ModifyPoolSpectraS3Request) WithPartitionId(partitionId string) *ModifyPoolSpectraS3Request {
    modifyPoolSpectraS3Request.PartitionId = &partitionId
    return modifyPoolSpectraS3Request
}

func (modifyPoolSpectraS3Request *ModifyPoolSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyPoolSpectraS3Request {
    modifyPoolSpectraS3Request.Quiesced = quiesced
    return modifyPoolSpectraS3Request
}

type ModifyPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (modifyPoolSpectraS3Response *ModifyPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyPoolSpectraS3Response.Pool)
}

func NewModifyPoolSpectraS3Response(webResponse WebResponse) (*ModifyPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyS3DataReplicationRuleSpectraS3Request struct {
    DataReplicationRuleType DataReplicationRuleType
    InitialDataPlacement S3InitialDataPlacementPolicy
    MaxBlobPartSizeInBytes *int64
    ReplicateDeletes *bool
    S3DataReplicationRule string
}

func NewModifyS3DataReplicationRuleSpectraS3Request(s3DataReplicationRule string) *ModifyS3DataReplicationRuleSpectraS3Request {
    return &ModifyS3DataReplicationRuleSpectraS3Request{
        S3DataReplicationRule: s3DataReplicationRule,
    }
}

func (modifyS3DataReplicationRuleSpectraS3Request *ModifyS3DataReplicationRuleSpectraS3Request) WithInitialDataPlacement(initialDataPlacement S3InitialDataPlacementPolicy) *ModifyS3DataReplicationRuleSpectraS3Request {
    modifyS3DataReplicationRuleSpectraS3Request.InitialDataPlacement = initialDataPlacement
    return modifyS3DataReplicationRuleSpectraS3Request
}

func (modifyS3DataReplicationRuleSpectraS3Request *ModifyS3DataReplicationRuleSpectraS3Request) WithMaxBlobPartSizeInBytes(maxBlobPartSizeInBytes int64) *ModifyS3DataReplicationRuleSpectraS3Request {
    modifyS3DataReplicationRuleSpectraS3Request.MaxBlobPartSizeInBytes = &maxBlobPartSizeInBytes
    return modifyS3DataReplicationRuleSpectraS3Request
}

func (modifyS3DataReplicationRuleSpectraS3Request *ModifyS3DataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *ModifyS3DataReplicationRuleSpectraS3Request {
    modifyS3DataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return modifyS3DataReplicationRuleSpectraS3Request
}

func (modifyS3DataReplicationRuleSpectraS3Request *ModifyS3DataReplicationRuleSpectraS3Request) WithDataReplicationRuleType(dataReplicationRuleType DataReplicationRuleType) *ModifyS3DataReplicationRuleSpectraS3Request {
    modifyS3DataReplicationRuleSpectraS3Request.DataReplicationRuleType = dataReplicationRuleType
    return modifyS3DataReplicationRuleSpectraS3Request
}

type ModifyS3DataReplicationRuleSpectraS3Response struct {
    S3DataReplicationRule S3DataReplicationRule
    Headers *http.Header
}

func (modifyS3DataReplicationRuleSpectraS3Response *ModifyS3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyS3DataReplicationRuleSpectraS3Response.S3DataReplicationRule)
}

func NewModifyS3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*ModifyS3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyS3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyS3TargetSpectraS3Request struct {
    AccessKey *string
    AutoVerifyFrequencyInDays *int
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DataPathEndPoint *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    Name *string
    OfflineDataStagingWindowInTb *int
    PermitGoingOutOfSync *bool
    ProxyDomain *string
    ProxyHost *string
    ProxyPassword *string
    ProxyPort *int
    ProxyUsername *string
    Quiesced Quiesced
    Region S3Region
    S3Target string
    SecretKey *string
    StagedDataExpirationInDays *int
}

func NewModifyS3TargetSpectraS3Request(s3Target string) *ModifyS3TargetSpectraS3Request {
    return &ModifyS3TargetSpectraS3Request{
        S3Target: s3Target,
    }
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithAccessKey(accessKey string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.AccessKey = &accessKey
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithAutoVerifyFrequencyInDays(autoVerifyFrequencyInDays int) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.AutoVerifyFrequencyInDays = &autoVerifyFrequencyInDays
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithCloudBucketPrefix(cloudBucketPrefix string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.CloudBucketPrefix = &cloudBucketPrefix
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithCloudBucketSuffix(cloudBucketSuffix string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.CloudBucketSuffix = &cloudBucketSuffix
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithHttps(https bool) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.Https = &https
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithName(name string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.Name = &name
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithOfflineDataStagingWindowInTb(offlineDataStagingWindowInTb int) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.OfflineDataStagingWindowInTb = &offlineDataStagingWindowInTb
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithProxyDomain(proxyDomain string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.ProxyDomain = &proxyDomain
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithProxyHost(proxyHost string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.ProxyHost = &proxyHost
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithProxyPassword(proxyPassword string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.ProxyPassword = &proxyPassword
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithProxyPort(proxyPort int) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.ProxyPort = &proxyPort
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithProxyUsername(proxyUsername string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.ProxyUsername = &proxyUsername
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.Quiesced = quiesced
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithRegion(region S3Region) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.Region = region
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithSecretKey(secretKey string) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.SecretKey = &secretKey
    return modifyS3TargetSpectraS3Request
}

func (modifyS3TargetSpectraS3Request *ModifyS3TargetSpectraS3Request) WithStagedDataExpirationInDays(stagedDataExpirationInDays int) *ModifyS3TargetSpectraS3Request {
    modifyS3TargetSpectraS3Request.StagedDataExpirationInDays = &stagedDataExpirationInDays
    return modifyS3TargetSpectraS3Request
}

type ModifyS3TargetSpectraS3Response struct {
    S3Target S3Target
    Headers *http.Header
}

func (modifyS3TargetSpectraS3Response *ModifyS3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyS3TargetSpectraS3Response.S3Target)
}

func NewModifyS3TargetSpectraS3Response(webResponse WebResponse) (*ModifyS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyS3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyStorageDomainMemberSpectraS3Request struct {
    StorageDomainMember string
    WritePreference WritePreferenceLevel
}

func NewModifyStorageDomainMemberSpectraS3Request(storageDomainMember string) *ModifyStorageDomainMemberSpectraS3Request {
    return &ModifyStorageDomainMemberSpectraS3Request{
        StorageDomainMember: storageDomainMember,
    }
}

func (modifyStorageDomainMemberSpectraS3Request *ModifyStorageDomainMemberSpectraS3Request) WithWritePreference(writePreference WritePreferenceLevel) *ModifyStorageDomainMemberSpectraS3Request {
    modifyStorageDomainMemberSpectraS3Request.WritePreference = writePreference
    return modifyStorageDomainMemberSpectraS3Request
}

type ModifyStorageDomainMemberSpectraS3Response struct {
    StorageDomainMember StorageDomainMember
    Headers *http.Header
}

func (modifyStorageDomainMemberSpectraS3Response *ModifyStorageDomainMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyStorageDomainMemberSpectraS3Response.StorageDomainMember)
}

func NewModifyStorageDomainMemberSpectraS3Response(webResponse WebResponse) (*ModifyStorageDomainMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyStorageDomainMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyStorageDomainSpectraS3Request struct {
    AutoEjectMediaFullThreshold *int64
    AutoEjectUponCron *string
    AutoEjectUponJobCancellation *bool
    AutoEjectUponJobCompletion *bool
    AutoEjectUponMediaFull *bool
    LtfsFileNaming LtfsFileNamingMode
    MaximumAutoVerificationFrequencyInDays *int
    MaxTapeFragmentationPercent *int
    MediaEjectionAllowed *bool
    Name *string
    SecureMediaAllocation *bool
    StorageDomain string
    VerifyPriorToAutoEject Priority
    WriteOptimization WriteOptimization
}

func NewModifyStorageDomainSpectraS3Request(storageDomain string) *ModifyStorageDomainSpectraS3Request {
    return &ModifyStorageDomainSpectraS3Request{
        StorageDomain: storageDomain,
    }
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithAutoEjectMediaFullThreshold(autoEjectMediaFullThreshold int64) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.AutoEjectMediaFullThreshold = &autoEjectMediaFullThreshold
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithAutoEjectUponCron(autoEjectUponCron string) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.AutoEjectUponCron = &autoEjectUponCron
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithAutoEjectUponJobCancellation(autoEjectUponJobCancellation bool) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.AutoEjectUponJobCancellation = &autoEjectUponJobCancellation
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithAutoEjectUponJobCompletion(autoEjectUponJobCompletion bool) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.AutoEjectUponJobCompletion = &autoEjectUponJobCompletion
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithAutoEjectUponMediaFull(autoEjectUponMediaFull bool) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.AutoEjectUponMediaFull = &autoEjectUponMediaFull
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithLtfsFileNaming(ltfsFileNaming LtfsFileNamingMode) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.LtfsFileNaming = ltfsFileNaming
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithMaxTapeFragmentationPercent(maxTapeFragmentationPercent int) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.MaxTapeFragmentationPercent = &maxTapeFragmentationPercent
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithMaximumAutoVerificationFrequencyInDays(maximumAutoVerificationFrequencyInDays int) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.MaximumAutoVerificationFrequencyInDays = &maximumAutoVerificationFrequencyInDays
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithMediaEjectionAllowed(mediaEjectionAllowed bool) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.MediaEjectionAllowed = &mediaEjectionAllowed
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithName(name string) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.Name = &name
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithSecureMediaAllocation(secureMediaAllocation bool) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.SecureMediaAllocation = &secureMediaAllocation
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithVerifyPriorToAutoEject(verifyPriorToAutoEject Priority) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.VerifyPriorToAutoEject = verifyPriorToAutoEject
    return modifyStorageDomainSpectraS3Request
}

func (modifyStorageDomainSpectraS3Request *ModifyStorageDomainSpectraS3Request) WithWriteOptimization(writeOptimization WriteOptimization) *ModifyStorageDomainSpectraS3Request {
    modifyStorageDomainSpectraS3Request.WriteOptimization = writeOptimization
    return modifyStorageDomainSpectraS3Request
}

type ModifyStorageDomainSpectraS3Response struct {
    StorageDomain StorageDomain
    Headers *http.Header
}

func (modifyStorageDomainSpectraS3Response *ModifyStorageDomainSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyStorageDomainSpectraS3Response.StorageDomain)
}

func NewModifyStorageDomainSpectraS3Response(webResponse WebResponse) (*ModifyStorageDomainSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyStorageDomainSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyTapeDriveSpectraS3Request struct {
    Quiesced Quiesced
    TapeDriveId string
}

func NewModifyTapeDriveSpectraS3Request(tapeDriveId string) *ModifyTapeDriveSpectraS3Request {
    return &ModifyTapeDriveSpectraS3Request{
        TapeDriveId: tapeDriveId,
    }
}

func (modifyTapeDriveSpectraS3Request *ModifyTapeDriveSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyTapeDriveSpectraS3Request {
    modifyTapeDriveSpectraS3Request.Quiesced = quiesced
    return modifyTapeDriveSpectraS3Request
}

type ModifyTapeDriveSpectraS3Response struct {
    TapeDrive TapeDrive
    Headers *http.Header
}

func (modifyTapeDriveSpectraS3Response *ModifyTapeDriveSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyTapeDriveSpectraS3Response.TapeDrive)
}

func NewModifyTapeDriveSpectraS3Response(webResponse WebResponse) (*ModifyTapeDriveSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyTapeDriveSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyTapePartitionSpectraS3Request struct {
    Quiesced Quiesced
    TapePartition string
}

func NewModifyTapePartitionSpectraS3Request(tapePartition string) *ModifyTapePartitionSpectraS3Request {
    return &ModifyTapePartitionSpectraS3Request{
        TapePartition: tapePartition,
    }
}

func (modifyTapePartitionSpectraS3Request *ModifyTapePartitionSpectraS3Request) WithQuiesced(quiesced Quiesced) *ModifyTapePartitionSpectraS3Request {
    modifyTapePartitionSpectraS3Request.Quiesced = quiesced
    return modifyTapePartitionSpectraS3Request
}

type ModifyTapePartitionSpectraS3Response struct {
    TapePartition TapePartition
    Headers *http.Header
}

func (modifyTapePartitionSpectraS3Response *ModifyTapePartitionSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyTapePartitionSpectraS3Response.TapePartition)
}

func NewModifyTapePartitionSpectraS3Response(webResponse WebResponse) (*ModifyTapePartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyTapePartitionSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyTapeSpectraS3Request struct {
    EjectLabel *string
    EjectLocation *string
    State TapeState
    TapeId string
}

func NewModifyTapeSpectraS3Request(tapeId string) *ModifyTapeSpectraS3Request {
    return &ModifyTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (modifyTapeSpectraS3Request *ModifyTapeSpectraS3Request) WithEjectLabel(ejectLabel string) *ModifyTapeSpectraS3Request {
    modifyTapeSpectraS3Request.EjectLabel = &ejectLabel
    return modifyTapeSpectraS3Request
}

func (modifyTapeSpectraS3Request *ModifyTapeSpectraS3Request) WithEjectLocation(ejectLocation string) *ModifyTapeSpectraS3Request {
    modifyTapeSpectraS3Request.EjectLocation = &ejectLocation
    return modifyTapeSpectraS3Request
}

func (modifyTapeSpectraS3Request *ModifyTapeSpectraS3Request) WithState(state TapeState) *ModifyTapeSpectraS3Request {
    modifyTapeSpectraS3Request.State = state
    return modifyTapeSpectraS3Request
}

type ModifyTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (modifyTapeSpectraS3Response *ModifyTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyTapeSpectraS3Response.Tape)
}

func NewModifyTapeSpectraS3Response(webResponse WebResponse) (*ModifyTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ModifyUserSpectraS3Request struct {
    DefaultDataPolicyId *string
    Name *string
    SecretKey *string
    UserId string
}

func NewModifyUserSpectraS3Request(userId string) *ModifyUserSpectraS3Request {
    return &ModifyUserSpectraS3Request{
        UserId: userId,
    }
}

func (modifyUserSpectraS3Request *ModifyUserSpectraS3Request) WithDefaultDataPolicyId(defaultDataPolicyId string) *ModifyUserSpectraS3Request {
    modifyUserSpectraS3Request.DefaultDataPolicyId = &defaultDataPolicyId
    return modifyUserSpectraS3Request
}

func (modifyUserSpectraS3Request *ModifyUserSpectraS3Request) WithName(name string) *ModifyUserSpectraS3Request {
    modifyUserSpectraS3Request.Name = &name
    return modifyUserSpectraS3Request
}

func (modifyUserSpectraS3Request *ModifyUserSpectraS3Request) WithSecretKey(secretKey string) *ModifyUserSpectraS3Request {
    modifyUserSpectraS3Request.SecretKey = &secretKey
    return modifyUserSpectraS3Request
}

type ModifyUserSpectraS3Response struct {
    SpectraUser SpectraUser
    Headers *http.Header
}

func (modifyUserSpectraS3Response *ModifyUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &modifyUserSpectraS3Response.SpectraUser)
}

func NewModifyUserSpectraS3Response(webResponse WebResponse) (*ModifyUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ModifyUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type MultiPartUpload struct {
    Initiated string
    Key *string
    Owner User
    UploadId string
}
func (multiPartUpload *MultiPartUpload) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Initiated":
            multiPartUpload.Initiated = parseString(child.Content)
        case "Key":
            multiPartUpload.Key = parseNullableString(child.Content)
        case "Owner":
            multiPartUpload.Owner.parse(&child, aggErr)
        case "UploadId":
            multiPartUpload.UploadId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing MultiPartUpload.", child.XMLName.Local)
        }
    }
}
type MultiPartUploadPart struct {
    ETag *string
    LastModified string
    PartNumber int
}
func (multiPartUploadPart *MultiPartUploadPart) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "ETag":
            multiPartUploadPart.ETag = parseNullableString(child.Content)
        case "LastModified":
            multiPartUploadPart.LastModified = parseString(child.Content)
        case "PartNumber":
            multiPartUploadPart.PartNumber = parseInt(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing MultiPartUploadPart.", child.XMLName.Local)
        }
    }
}
type NamedDetailedTapePartition struct {
    DriveType *TapeDriveType
    DriveTypes []TapeDriveType
    ErrorMessage *string
    Id string
    ImportExportConfiguration ImportExportConfiguration
    LibraryId string
    Name *string
    Quiesced Quiesced
    SerialId *string
    SerialNumber *string
    State TapePartitionState
    TapeTypes []string
}
type NamedDetailedTapePartitionList struct {
    NamedDetailedTapePartitions []NamedDetailedTapePartition
}
func (namedDetailedTapePartitionList *NamedDetailedTapePartitionList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapePartition":
            var model NamedDetailedTapePartition
            model.parse(&child, aggErr)
            namedDetailedTapePartitionList.NamedDetailedTapePartitions = append(namedDetailedTapePartitionList.NamedDetailedTapePartitions, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing NamedDetailedTapePartitionList.", child.XMLName.Local)
        }
    }
}
func (namedDetailedTapePartition *NamedDetailedTapePartition) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DriveType":
            parseNullableEnum(child.Content, namedDetailedTapePartition.DriveType, aggErr)
        case "DriveTypes":
            var model TapeDriveType
            parseEnum(child.Content, &model, aggErr)
            namedDetailedTapePartition.DriveTypes = append(namedDetailedTapePartition.DriveTypes, model)
        case "ErrorMessage":
            namedDetailedTapePartition.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            namedDetailedTapePartition.Id = parseString(child.Content)
        case "ImportExportConfiguration":
            parseEnum(child.Content, &namedDetailedTapePartition.ImportExportConfiguration, aggErr)
        case "LibraryId":
            namedDetailedTapePartition.LibraryId = parseString(child.Content)
        case "Name":
            namedDetailedTapePartition.Name = parseNullableString(child.Content)
        case "Quiesced":
            parseEnum(child.Content, &namedDetailedTapePartition.Quiesced, aggErr)
        case "SerialId":
            namedDetailedTapePartition.SerialId = parseNullableString(child.Content)
        case "SerialNumber":
            namedDetailedTapePartition.SerialNumber = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &namedDetailedTapePartition.State, aggErr)
        case "TapeTypes":
            var str = parseString(child.Content)
            namedDetailedTapePartition.TapeTypes = append(namedDetailedTapePartition.TapeTypes, str)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing NamedDetailedTapePartition.", child.XMLName.Local)
        }
    }
}
type NamingConventionType Enum

const (
    NAMING_CONVENTION_TYPE_CONCAT_LOWERCASE NamingConventionType = 1 + iota
    NAMING_CONVENTION_TYPE_CONSTANT NamingConventionType = 1 + iota
    NAMING_CONVENTION_TYPE_UNDERSCORED NamingConventionType = 1 + iota
    NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_UPPERCASE NamingConventionType = 1 + iota
    NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_LOWERCASE NamingConventionType = 1 + iota
)

func (namingConventionType *NamingConventionType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *namingConventionType = UNDEFINED
        case "CONCAT_LOWERCASE": *namingConventionType = NAMING_CONVENTION_TYPE_CONCAT_LOWERCASE
        case "CONSTANT": *namingConventionType = NAMING_CONVENTION_TYPE_CONSTANT
        case "UNDERSCORED": *namingConventionType = NAMING_CONVENTION_TYPE_UNDERSCORED
        case "CAMEL_CASE_WITH_FIRST_LETTER_UPPERCASE": *namingConventionType = NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_UPPERCASE
        case "CAMEL_CASE_WITH_FIRST_LETTER_LOWERCASE": *namingConventionType = NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_LOWERCASE
        default:
            *namingConventionType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into NamingConventionType", str))
    }
    return nil
}

func (namingConventionType NamingConventionType) String() string {
    switch namingConventionType {
        case NAMING_CONVENTION_TYPE_CONCAT_LOWERCASE: return "CONCAT_LOWERCASE"
        case NAMING_CONVENTION_TYPE_CONSTANT: return "CONSTANT"
        case NAMING_CONVENTION_TYPE_UNDERSCORED: return "UNDERSCORED"
        case NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_UPPERCASE: return "CAMEL_CASE_WITH_FIRST_LETTER_UPPERCASE"
        case NAMING_CONVENTION_TYPE_CAMEL_CASE_WITH_FIRST_LETTER_LOWERCASE: return "CAMEL_CASE_WITH_FIRST_LETTER_LOWERCASE"
        default:
            log.Printf("Error: invalid NamingConventionType represented by '%d'", namingConventionType)
            return ""
    }
}

func (namingConventionType NamingConventionType) StringPtr() *string {
    if namingConventionType == UNDEFINED {
        return nil
    }
    result := namingConventionType.String()
    return &result
}
type Node struct {
    DataPathHttpPort *int
    DataPathHttpsPort *int
    DataPathIpAddress *string
    DnsName *string
    Id string
    LastHeartbeat string
    Name *string
    SerialNumber *string
}
type NodeList struct {
    Nodes []Node
}
func (nodeList *NodeList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Node":
            var model Node
            model.parse(&child, aggErr)
            nodeList.Nodes = append(nodeList.Nodes, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing NodeList.", child.XMLName.Local)
        }
    }
}
func (node *Node) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPathHttpPort":
            node.DataPathHttpPort = parseNullableInt(child.Content, aggErr)
        case "DataPathHttpsPort":
            node.DataPathHttpsPort = parseNullableInt(child.Content, aggErr)
        case "DataPathIpAddress":
            node.DataPathIpAddress = parseNullableString(child.Content)
        case "DnsName":
            node.DnsName = parseNullableString(child.Content)
        case "Id":
            node.Id = parseString(child.Content)
        case "LastHeartbeat":
            node.LastHeartbeat = parseString(child.Content)
        case "Name":
            node.Name = parseNullableString(child.Content)
        case "SerialNumber":
            node.SerialNumber = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Node.", child.XMLName.Local)
        }
    }
}
type Objects struct {
    ChunkId string
    ChunkNumber int
    NodeId *string
    Objects []BulkObject
}
func (objects *Objects) parse(xmlNode *XmlNode, aggErr *AggregateError) {
    // Parse Attributes
    for _, attr := range xmlNode.Attrs {
        switch attr.Name.Local {
        case "ChunkId":
            objects.ChunkId = attr.Value
        case "ChunkNumber":
            objects.ChunkNumber = parseIntFromString(attr.Value, aggErr)
        case "NodeId":
            objects.NodeId = parseNullableStringFromString(attr.Value)
        default:
            log.Printf("WARNING: unable to parse unknown attribute '%s' while parsing Objects.", attr.Name.Local)
        }
    }

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Object":
            var model BulkObject
            model.parse(&child, aggErr)
            objects.Objects = append(objects.Objects, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Objects.", child.XMLName.Local)
        }
    }
}
type OnlineAllTapesSpectraS3Request struct {
}

func NewOnlineAllTapesSpectraS3Request() *OnlineAllTapesSpectraS3Request {
    return &OnlineAllTapesSpectraS3Request{
    }
}

type OnlineAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (onlineAllTapesSpectraS3Response *OnlineAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, onlineAllTapesSpectraS3Response.TapeFailureList)
}

func NewOnlineAllTapesSpectraS3Response(webResponse WebResponse) (*OnlineAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &OnlineAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body OnlineAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type OnlineTapeSpectraS3Request struct {
    TapeId string
}

func NewOnlineTapeSpectraS3Request(tapeId string) *OnlineTapeSpectraS3Request {
    return &OnlineTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

type OnlineTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (onlineTapeSpectraS3Response *OnlineTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &onlineTapeSpectraS3Response.Tape)
}

func NewOnlineTapeSpectraS3Response(webResponse WebResponse) (*OnlineTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body OnlineTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PairBackRegisteredDs3TargetSpectraS3Request struct {
    AccessControlReplication Ds3TargetAccessControlReplication
    AdminAuthId *string
    AdminSecretKey *string
    DataPathEndPoint *string
    DataPathHttps *bool
    DataPathPort *int
    DataPathProxy *string
    DataPathVerifyCertificate *bool
    DefaultReadPreference TargetReadPreferenceType
    Ds3Target string
    Name *string
    PermitGoingOutOfSync *bool
    ReplicatedUserDefaultDataPolicy *string
}

func NewPairBackRegisteredDs3TargetSpectraS3Request(ds3Target string) *PairBackRegisteredDs3TargetSpectraS3Request {
    return &PairBackRegisteredDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithAccessControlReplication(accessControlReplication Ds3TargetAccessControlReplication) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.AccessControlReplication = accessControlReplication
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithAdminAuthId(adminAuthId string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.AdminAuthId = &adminAuthId
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithAdminSecretKey(adminSecretKey string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.AdminSecretKey = &adminSecretKey
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDataPathHttps(dataPathHttps bool) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DataPathHttps = &dataPathHttps
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDataPathPort(dataPathPort int) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DataPathPort = &dataPathPort
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDataPathProxy(dataPathProxy string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DataPathProxy = &dataPathProxy
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDataPathVerifyCertificate(dataPathVerifyCertificate bool) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DataPathVerifyCertificate = &dataPathVerifyCertificate
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithName(name string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.Name = &name
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return pairBackRegisteredDs3TargetSpectraS3Request
}

func (pairBackRegisteredDs3TargetSpectraS3Request *PairBackRegisteredDs3TargetSpectraS3Request) WithReplicatedUserDefaultDataPolicy(replicatedUserDefaultDataPolicy string) *PairBackRegisteredDs3TargetSpectraS3Request {
    pairBackRegisteredDs3TargetSpectraS3Request.ReplicatedUserDefaultDataPolicy = &replicatedUserDefaultDataPolicy
    return pairBackRegisteredDs3TargetSpectraS3Request
}

type PairBackRegisteredDs3TargetSpectraS3Response struct {
    
    Headers *http.Header
}



func NewPairBackRegisteredDs3TargetSpectraS3Response(webResponse WebResponse) (*PairBackRegisteredDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &PairBackRegisteredDs3TargetSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PhysicalPlacement struct {
    AzureTargets []AzureTarget
    Ds3Targets []Ds3Target
    Pools []Pool
    S3Targets []S3Target
    Tapes []Tape
}
func (physicalPlacement *PhysicalPlacement) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AzureTargets":
            physicalPlacement.AzureTargets = parseAzureTargetSlice("AzureTarget", child.Children, aggErr)
        case "Ds3Targets":
            physicalPlacement.Ds3Targets = parseDs3TargetSlice("Ds3Target", child.Children, aggErr)
        case "Pools":
            physicalPlacement.Pools = parsePoolSlice("Pool", child.Children, aggErr)
        case "S3Targets":
            physicalPlacement.S3Targets = parseS3TargetSlice("S3Target", child.Children, aggErr)
        case "Tapes":
            physicalPlacement.Tapes = parseTapeSlice("Tape", child.Children, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PhysicalPlacement.", child.XMLName.Local)
        }
    }
}
type Pool struct {
    AssignedToStorageDomain bool
    AvailableCapacity int64
    BucketId *string
    Guid *string
    Health PoolHealth
    Id string
    LastAccessed *string
    LastModified *string
    LastVerified *string
    Mountpoint *string
    Name *string
    PartitionId *string
    PoweredOn bool
    Quiesced Quiesced
    ReservedCapacity int64
    State PoolState
    StorageDomainId *string
    TotalCapacity int64
    Type PoolType
    UsedCapacity int64
}
type PoolFailure struct {
    Date string
    ErrorMessage *string
    Id string
    PoolId string
    Type PoolFailureType
}
type PoolFailureList struct {
    PoolFailures []PoolFailure
}
func (poolFailureList *PoolFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "PoolFailure":
            var model PoolFailure
            model.parse(&child, aggErr)
            poolFailureList.PoolFailures = append(poolFailureList.PoolFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolFailureList.", child.XMLName.Local)
        }
    }
}
type PoolFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type PoolFailureNotificationRegistrationList struct {
    PoolFailureNotificationRegistrations []PoolFailureNotificationRegistration
}
func (poolFailureNotificationRegistrationList *PoolFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "PoolFailureNotificationRegistration":
            var model PoolFailureNotificationRegistration
            model.parse(&child, aggErr)
            poolFailureNotificationRegistrationList.PoolFailureNotificationRegistrations = append(poolFailureNotificationRegistrationList.PoolFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (poolFailureNotificationRegistration *PoolFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            poolFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &poolFailureNotificationRegistration.Format, aggErr)
        case "Id":
            poolFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            poolFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            poolFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            poolFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &poolFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            poolFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &poolFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            poolFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            poolFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (poolFailure *PoolFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            poolFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            poolFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            poolFailure.Id = parseString(child.Content)
        case "PoolId":
            poolFailure.PoolId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &poolFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolFailure.", child.XMLName.Local)
        }
    }
}
type PoolFailureType Enum

const (
    POOL_FAILURE_TYPE_BLOB_READ_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_DATA_CHECKPOINT_MISSING PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_FORMAT_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_IMPORT_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_IMPORT_INCOMPLETE PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_INSPECT_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_QUIESCED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_READ_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_VERIFY_FAILED PoolFailureType = 1 + iota
    POOL_FAILURE_TYPE_WRITE_FAILED PoolFailureType = 1 + iota
)

func (poolFailureType *PoolFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *poolFailureType = UNDEFINED
        case "BLOB_READ_FAILED": *poolFailureType = POOL_FAILURE_TYPE_BLOB_READ_FAILED
        case "DATA_CHECKPOINT_FAILURE": *poolFailureType = POOL_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE
        case "DATA_CHECKPOINT_MISSING": *poolFailureType = POOL_FAILURE_TYPE_DATA_CHECKPOINT_MISSING
        case "FORMAT_FAILED": *poolFailureType = POOL_FAILURE_TYPE_FORMAT_FAILED
        case "IMPORT_FAILED": *poolFailureType = POOL_FAILURE_TYPE_IMPORT_FAILED
        case "IMPORT_INCOMPLETE": *poolFailureType = POOL_FAILURE_TYPE_IMPORT_INCOMPLETE
        case "IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE": *poolFailureType = POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE
        case "IMPORT_FAILED_DUE_TO_DATA_INTEGRITY": *poolFailureType = POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY
        case "INSPECT_FAILED": *poolFailureType = POOL_FAILURE_TYPE_INSPECT_FAILED
        case "QUIESCED": *poolFailureType = POOL_FAILURE_TYPE_QUIESCED
        case "READ_FAILED": *poolFailureType = POOL_FAILURE_TYPE_READ_FAILED
        case "VERIFY_FAILED": *poolFailureType = POOL_FAILURE_TYPE_VERIFY_FAILED
        case "WRITE_FAILED": *poolFailureType = POOL_FAILURE_TYPE_WRITE_FAILED
        default:
            *poolFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into PoolFailureType", str))
    }
    return nil
}

func (poolFailureType PoolFailureType) String() string {
    switch poolFailureType {
        case POOL_FAILURE_TYPE_BLOB_READ_FAILED: return "BLOB_READ_FAILED"
        case POOL_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE: return "DATA_CHECKPOINT_FAILURE"
        case POOL_FAILURE_TYPE_DATA_CHECKPOINT_MISSING: return "DATA_CHECKPOINT_MISSING"
        case POOL_FAILURE_TYPE_FORMAT_FAILED: return "FORMAT_FAILED"
        case POOL_FAILURE_TYPE_IMPORT_FAILED: return "IMPORT_FAILED"
        case POOL_FAILURE_TYPE_IMPORT_INCOMPLETE: return "IMPORT_INCOMPLETE"
        case POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE: return "IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE"
        case POOL_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY: return "IMPORT_FAILED_DUE_TO_DATA_INTEGRITY"
        case POOL_FAILURE_TYPE_INSPECT_FAILED: return "INSPECT_FAILED"
        case POOL_FAILURE_TYPE_QUIESCED: return "QUIESCED"
        case POOL_FAILURE_TYPE_READ_FAILED: return "READ_FAILED"
        case POOL_FAILURE_TYPE_VERIFY_FAILED: return "VERIFY_FAILED"
        case POOL_FAILURE_TYPE_WRITE_FAILED: return "WRITE_FAILED"
        default:
            log.Printf("Error: invalid PoolFailureType represented by '%d'", poolFailureType)
            return ""
    }
}

func (poolFailureType PoolFailureType) StringPtr() *string {
    if poolFailureType == UNDEFINED {
        return nil
    }
    result := poolFailureType.String()
    return &result
}
type PoolHealth Enum

const (
    POOL_HEALTH_OK PoolHealth = 1 + iota
    POOL_HEALTH_DEGRADED PoolHealth = 1 + iota
)

func (poolHealth *PoolHealth) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *poolHealth = UNDEFINED
        case "OK": *poolHealth = POOL_HEALTH_OK
        case "DEGRADED": *poolHealth = POOL_HEALTH_DEGRADED
        default:
            *poolHealth = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into PoolHealth", str))
    }
    return nil
}

func (poolHealth PoolHealth) String() string {
    switch poolHealth {
        case POOL_HEALTH_OK: return "OK"
        case POOL_HEALTH_DEGRADED: return "DEGRADED"
        default:
            log.Printf("Error: invalid PoolHealth represented by '%d'", poolHealth)
            return ""
    }
}

func (poolHealth PoolHealth) StringPtr() *string {
    if poolHealth == UNDEFINED {
        return nil
    }
    result := poolHealth.String()
    return &result
}
type PoolList struct {
    Pools []Pool
}
func (poolList *PoolList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Pool":
            var model Pool
            model.parse(&child, aggErr)
            poolList.Pools = append(poolList.Pools, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolList.", child.XMLName.Local)
        }
    }
}
func (pool *Pool) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AssignedToStorageDomain":
            pool.AssignedToStorageDomain = parseBool(child.Content, aggErr)
        case "AvailableCapacity":
            pool.AvailableCapacity = parseInt64(child.Content, aggErr)
        case "BucketId":
            pool.BucketId = parseNullableString(child.Content)
        case "Guid":
            pool.Guid = parseNullableString(child.Content)
        case "Health":
            parseEnum(child.Content, &pool.Health, aggErr)
        case "Id":
            pool.Id = parseString(child.Content)
        case "LastAccessed":
            pool.LastAccessed = parseNullableString(child.Content)
        case "LastModified":
            pool.LastModified = parseNullableString(child.Content)
        case "LastVerified":
            pool.LastVerified = parseNullableString(child.Content)
        case "Mountpoint":
            pool.Mountpoint = parseNullableString(child.Content)
        case "Name":
            pool.Name = parseNullableString(child.Content)
        case "PartitionId":
            pool.PartitionId = parseNullableString(child.Content)
        case "PoweredOn":
            pool.PoweredOn = parseBool(child.Content, aggErr)
        case "Quiesced":
            parseEnum(child.Content, &pool.Quiesced, aggErr)
        case "ReservedCapacity":
            pool.ReservedCapacity = parseInt64(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &pool.State, aggErr)
        case "StorageDomainId":
            pool.StorageDomainId = parseNullableString(child.Content)
        case "TotalCapacity":
            pool.TotalCapacity = parseInt64(child.Content, aggErr)
        case "Type":
            parseEnum(child.Content, &pool.Type, aggErr)
        case "UsedCapacity":
            pool.UsedCapacity = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Pool.", child.XMLName.Local)
        }
    }
}

func parsePoolSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []Pool {
    var result []Pool
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult Pool
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing Pool struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type PoolPartition struct {
    Id string
    Name *string
    Type PoolType
}
type PoolPartitionList struct {
    PoolPartitions []PoolPartition
}
func (poolPartitionList *PoolPartitionList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "PoolPartition":
            var model PoolPartition
            model.parse(&child, aggErr)
            poolPartitionList.PoolPartitions = append(poolPartitionList.PoolPartitions, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolPartitionList.", child.XMLName.Local)
        }
    }
}
func (poolPartition *PoolPartition) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Id":
            poolPartition.Id = parseString(child.Content)
        case "Name":
            poolPartition.Name = parseNullableString(child.Content)
        case "Type":
            parseEnum(child.Content, &poolPartition.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing PoolPartition.", child.XMLName.Local)
        }
    }
}
type PoolState Enum

const (
    POOL_STATE_BLANK PoolState = 1 + iota
    POOL_STATE_NORMAL PoolState = 1 + iota
    POOL_STATE_LOST PoolState = 1 + iota
    POOL_STATE_FOREIGN PoolState = 1 + iota
    POOL_STATE_IMPORT_PENDING PoolState = 1 + iota
    POOL_STATE_IMPORT_IN_PROGRESS PoolState = 1 + iota
)

func (poolState *PoolState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *poolState = UNDEFINED
        case "BLANK": *poolState = POOL_STATE_BLANK
        case "NORMAL": *poolState = POOL_STATE_NORMAL
        case "LOST": *poolState = POOL_STATE_LOST
        case "FOREIGN": *poolState = POOL_STATE_FOREIGN
        case "IMPORT_PENDING": *poolState = POOL_STATE_IMPORT_PENDING
        case "IMPORT_IN_PROGRESS": *poolState = POOL_STATE_IMPORT_IN_PROGRESS
        default:
            *poolState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into PoolState", str))
    }
    return nil
}

func (poolState PoolState) String() string {
    switch poolState {
        case POOL_STATE_BLANK: return "BLANK"
        case POOL_STATE_NORMAL: return "NORMAL"
        case POOL_STATE_LOST: return "LOST"
        case POOL_STATE_FOREIGN: return "FOREIGN"
        case POOL_STATE_IMPORT_PENDING: return "IMPORT_PENDING"
        case POOL_STATE_IMPORT_IN_PROGRESS: return "IMPORT_IN_PROGRESS"
        default:
            log.Printf("Error: invalid PoolState represented by '%d'", poolState)
            return ""
    }
}

func (poolState PoolState) StringPtr() *string {
    if poolState == UNDEFINED {
        return nil
    }
    result := poolState.String()
    return &result
}
type PoolType Enum

const (
    POOL_TYPE_NEARLINE PoolType = 1 + iota
    POOL_TYPE_ONLINE PoolType = 1 + iota
)

func (poolType *PoolType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *poolType = UNDEFINED
        case "NEARLINE": *poolType = POOL_TYPE_NEARLINE
        case "ONLINE": *poolType = POOL_TYPE_ONLINE
        default:
            *poolType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into PoolType", str))
    }
    return nil
}

func (poolType PoolType) String() string {
    switch poolType {
        case POOL_TYPE_NEARLINE: return "NEARLINE"
        case POOL_TYPE_ONLINE: return "ONLINE"
        default:
            log.Printf("Error: invalid PoolType represented by '%d'", poolType)
            return ""
    }
}

func (poolType PoolType) StringPtr() *string {
    if poolType == UNDEFINED {
        return nil
    }
    result := poolType.String()
    return &result
}
type Priority Enum

const (
    PRIORITY_CRITICAL Priority = 1 + iota
    PRIORITY_URGENT Priority = 1 + iota
    PRIORITY_HIGH Priority = 1 + iota
    PRIORITY_NORMAL Priority = 1 + iota
    PRIORITY_LOW Priority = 1 + iota
    PRIORITY_BACKGROUND Priority = 1 + iota
)

func (priority *Priority) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *priority = UNDEFINED
        case "CRITICAL": *priority = PRIORITY_CRITICAL
        case "URGENT": *priority = PRIORITY_URGENT
        case "HIGH": *priority = PRIORITY_HIGH
        case "NORMAL": *priority = PRIORITY_NORMAL
        case "LOW": *priority = PRIORITY_LOW
        case "BACKGROUND": *priority = PRIORITY_BACKGROUND
        default:
            *priority = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into Priority", str))
    }
    return nil
}

func (priority Priority) String() string {
    switch priority {
        case PRIORITY_CRITICAL: return "CRITICAL"
        case PRIORITY_URGENT: return "URGENT"
        case PRIORITY_HIGH: return "HIGH"
        case PRIORITY_NORMAL: return "NORMAL"
        case PRIORITY_LOW: return "LOW"
        case PRIORITY_BACKGROUND: return "BACKGROUND"
        default:
            log.Printf("Error: invalid Priority represented by '%d'", priority)
            return ""
    }
}

func (priority Priority) StringPtr() *string {
    if priority == UNDEFINED {
        return nil
    }
    result := priority.String()
    return &result
}
type PutAzureDataReplicationRuleSpectraS3Request struct {
    DataPolicyId string
    DataReplicationRuleType DataReplicationRuleType
    MaxBlobPartSizeInBytes *int64
    ReplicateDeletes *bool
    TargetId string
}

func NewPutAzureDataReplicationRuleSpectraS3Request(dataPolicyId string, dataReplicationRuleType DataReplicationRuleType, targetId string) *PutAzureDataReplicationRuleSpectraS3Request {
    return &PutAzureDataReplicationRuleSpectraS3Request{
        DataPolicyId: dataPolicyId,
        TargetId: targetId,
        DataReplicationRuleType: dataReplicationRuleType,
    }
}

func (putAzureDataReplicationRuleSpectraS3Request *PutAzureDataReplicationRuleSpectraS3Request) WithMaxBlobPartSizeInBytes(maxBlobPartSizeInBytes int64) *PutAzureDataReplicationRuleSpectraS3Request {
    putAzureDataReplicationRuleSpectraS3Request.MaxBlobPartSizeInBytes = &maxBlobPartSizeInBytes
    return putAzureDataReplicationRuleSpectraS3Request
}

func (putAzureDataReplicationRuleSpectraS3Request *PutAzureDataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *PutAzureDataReplicationRuleSpectraS3Request {
    putAzureDataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return putAzureDataReplicationRuleSpectraS3Request
}

type PutAzureDataReplicationRuleSpectraS3Response struct {
    AzureDataReplicationRule AzureDataReplicationRule
    Headers *http.Header
}

func (putAzureDataReplicationRuleSpectraS3Response *PutAzureDataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putAzureDataReplicationRuleSpectraS3Response.AzureDataReplicationRule)
}

func NewPutAzureDataReplicationRuleSpectraS3Response(webResponse WebResponse) (*PutAzureDataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutAzureDataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutAzureTargetBucketNameSpectraS3Request struct {
    BucketId string
    Name string
    TargetId string
}

func NewPutAzureTargetBucketNameSpectraS3Request(bucketId string, name string, targetId string) *PutAzureTargetBucketNameSpectraS3Request {
    return &PutAzureTargetBucketNameSpectraS3Request{
        BucketId: bucketId,
        Name: name,
        TargetId: targetId,
    }
}

type PutAzureTargetBucketNameSpectraS3Response struct {
    AzureTargetBucketName AzureTargetBucketName
    Headers *http.Header
}

func (putAzureTargetBucketNameSpectraS3Response *PutAzureTargetBucketNameSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putAzureTargetBucketNameSpectraS3Response.AzureTargetBucketName)
}

func NewPutAzureTargetBucketNameSpectraS3Response(webResponse WebResponse) (*PutAzureTargetBucketNameSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutAzureTargetBucketNameSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutAzureTargetFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutAzureTargetFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutAzureTargetFailureNotificationRegistrationSpectraS3Request {
    return &PutAzureTargetFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putAzureTargetFailureNotificationRegistrationSpectraS3Request *PutAzureTargetFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutAzureTargetFailureNotificationRegistrationSpectraS3Request {
    putAzureTargetFailureNotificationRegistrationSpectraS3Request.Format = format
    return putAzureTargetFailureNotificationRegistrationSpectraS3Request
}

func (putAzureTargetFailureNotificationRegistrationSpectraS3Request *PutAzureTargetFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutAzureTargetFailureNotificationRegistrationSpectraS3Request {
    putAzureTargetFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putAzureTargetFailureNotificationRegistrationSpectraS3Request
}

func (putAzureTargetFailureNotificationRegistrationSpectraS3Request *PutAzureTargetFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutAzureTargetFailureNotificationRegistrationSpectraS3Request {
    putAzureTargetFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putAzureTargetFailureNotificationRegistrationSpectraS3Request
}

type PutAzureTargetFailureNotificationRegistrationSpectraS3Response struct {
    AzureTargetFailureNotificationRegistration AzureTargetFailureNotificationRegistration
    Headers *http.Header
}

func (putAzureTargetFailureNotificationRegistrationSpectraS3Response *PutAzureTargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putAzureTargetFailureNotificationRegistrationSpectraS3Response.AzureTargetFailureNotificationRegistration)
}

func NewPutAzureTargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutAzureTargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutAzureTargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutAzureTargetReadPreferenceSpectraS3Request struct {
    BucketId string
    ReadPreference TargetReadPreferenceType
    TargetId string
}

func NewPutAzureTargetReadPreferenceSpectraS3Request(bucketId string, readPreference TargetReadPreferenceType, targetId string) *PutAzureTargetReadPreferenceSpectraS3Request {
    return &PutAzureTargetReadPreferenceSpectraS3Request{
        BucketId: bucketId,
        ReadPreference: readPreference,
        TargetId: targetId,
    }
}

type PutAzureTargetReadPreferenceSpectraS3Response struct {
    AzureTargetReadPreference AzureTargetReadPreference
    Headers *http.Header
}

func (putAzureTargetReadPreferenceSpectraS3Response *PutAzureTargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putAzureTargetReadPreferenceSpectraS3Response.AzureTargetReadPreference)
}

func NewPutAzureTargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*PutAzureTargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutAzureTargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutBucketAclForGroupSpectraS3Request struct {
    BucketId string
    GroupId string
    Permission BucketAclPermission
}

func NewPutBucketAclForGroupSpectraS3Request(bucketId string, groupId string, permission BucketAclPermission) *PutBucketAclForGroupSpectraS3Request {
    return &PutBucketAclForGroupSpectraS3Request{
        BucketId: bucketId,
        GroupId: groupId,
        Permission: permission,
    }
}

type PutBucketAclForGroupSpectraS3Response struct {
    BucketAcl BucketAcl
    Headers *http.Header
}

func (putBucketAclForGroupSpectraS3Response *PutBucketAclForGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putBucketAclForGroupSpectraS3Response.BucketAcl)
}

func NewPutBucketAclForGroupSpectraS3Response(webResponse WebResponse) (*PutBucketAclForGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutBucketAclForGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutBucketAclForUserSpectraS3Request struct {
    BucketId string
    Permission BucketAclPermission
    UserId string
}

func NewPutBucketAclForUserSpectraS3Request(bucketId string, permission BucketAclPermission, userId string) *PutBucketAclForUserSpectraS3Request {
    return &PutBucketAclForUserSpectraS3Request{
        BucketId: bucketId,
        Permission: permission,
        UserId: userId,
    }
}

type PutBucketAclForUserSpectraS3Response struct {
    BucketAcl BucketAcl
    Headers *http.Header
}

func (putBucketAclForUserSpectraS3Response *PutBucketAclForUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putBucketAclForUserSpectraS3Response.BucketAcl)
}

func NewPutBucketAclForUserSpectraS3Response(webResponse WebResponse) (*PutBucketAclForUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutBucketAclForUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutBucketRequest struct {
    BucketName string
}

func NewPutBucketRequest(bucketName string) *PutBucketRequest {
    return &PutBucketRequest{
        BucketName: bucketName,
    }
}

type PutBucketResponse struct {
    
    Headers *http.Header
}



func NewPutBucketResponse(webResponse WebResponse) (*PutBucketResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &PutBucketResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutBucketSpectraS3Request struct {
    DataPolicyId *string
    Id *string
    Name string
    UserId *string
}

func NewPutBucketSpectraS3Request(name string) *PutBucketSpectraS3Request {
    return &PutBucketSpectraS3Request{
        Name: name,
    }
}

func (putBucketSpectraS3Request *PutBucketSpectraS3Request) WithDataPolicyId(dataPolicyId string) *PutBucketSpectraS3Request {
    putBucketSpectraS3Request.DataPolicyId = &dataPolicyId
    return putBucketSpectraS3Request
}

func (putBucketSpectraS3Request *PutBucketSpectraS3Request) WithId(id string) *PutBucketSpectraS3Request {
    putBucketSpectraS3Request.Id = &id
    return putBucketSpectraS3Request
}

func (putBucketSpectraS3Request *PutBucketSpectraS3Request) WithUserId(userId string) *PutBucketSpectraS3Request {
    putBucketSpectraS3Request.UserId = &userId
    return putBucketSpectraS3Request
}

type PutBucketSpectraS3Response struct {
    Bucket Bucket
    Headers *http.Header
}

func (putBucketSpectraS3Response *PutBucketSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putBucketSpectraS3Response.Bucket)
}

func NewPutBucketSpectraS3Response(webResponse WebResponse) (*PutBucketSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutBucketSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutBulkJobSpectraS3Request struct {
    BucketName string
    Aggregating *bool
    Force bool
    IgnoreNamingConflicts bool
    ImplicitJobIdResolution *bool
    MaxUploadSize *int64
    MinimizeSpanningAcrossMedia *bool
    Name *string
    Objects []Ds3PutObject
    Priority Priority
    VerifyAfterWrite *bool
}

func NewPutBulkJobSpectraS3Request(bucketName string, objects []Ds3PutObject) *PutBulkJobSpectraS3Request {
    return &PutBulkJobSpectraS3Request{
        BucketName: bucketName,
        Objects: objects,
    }
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithAggregating(aggregating bool) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.Aggregating = &aggregating
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithForce() *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.Force = true
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithIgnoreNamingConflicts() *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.IgnoreNamingConflicts = true
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithImplicitJobIdResolution(implicitJobIdResolution bool) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.ImplicitJobIdResolution = &implicitJobIdResolution
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithMaxUploadSize(maxUploadSize int64) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.MaxUploadSize = &maxUploadSize
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithMinimizeSpanningAcrossMedia(minimizeSpanningAcrossMedia bool) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.MinimizeSpanningAcrossMedia = &minimizeSpanningAcrossMedia
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithName(name string) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.Name = &name
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithPriority(priority Priority) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.Priority = priority
    return putBulkJobSpectraS3Request
}

func (putBulkJobSpectraS3Request *PutBulkJobSpectraS3Request) WithVerifyAfterWrite(verifyAfterWrite bool) *PutBulkJobSpectraS3Request {
    putBulkJobSpectraS3Request.VerifyAfterWrite = &verifyAfterWrite
    return putBulkJobSpectraS3Request
}

type PutBulkJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (putBulkJobSpectraS3Response *PutBulkJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putBulkJobSpectraS3Response.MasterObjectList)
}

func NewPutBulkJobSpectraS3Response(webResponse WebResponse) (*PutBulkJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body PutBulkJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDataPersistenceRuleSpectraS3Request struct {
    DataPersistenceRuleType DataPersistenceRuleType
    DataPolicyId string
    IsolationLevel DataIsolationLevel
    MinimumDaysToRetain *int
    StorageDomainId string
}

func NewPutDataPersistenceRuleSpectraS3Request(dataPersistenceRuleType DataPersistenceRuleType, dataPolicyId string, isolationLevel DataIsolationLevel, storageDomainId string) *PutDataPersistenceRuleSpectraS3Request {
    return &PutDataPersistenceRuleSpectraS3Request{
        DataPolicyId: dataPolicyId,
        IsolationLevel: isolationLevel,
        StorageDomainId: storageDomainId,
        DataPersistenceRuleType: dataPersistenceRuleType,
    }
}

func (putDataPersistenceRuleSpectraS3Request *PutDataPersistenceRuleSpectraS3Request) WithMinimumDaysToRetain(minimumDaysToRetain int) *PutDataPersistenceRuleSpectraS3Request {
    putDataPersistenceRuleSpectraS3Request.MinimumDaysToRetain = &minimumDaysToRetain
    return putDataPersistenceRuleSpectraS3Request
}

type PutDataPersistenceRuleSpectraS3Response struct {
    DataPersistenceRule DataPersistenceRule
    Headers *http.Header
}

func (putDataPersistenceRuleSpectraS3Response *PutDataPersistenceRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDataPersistenceRuleSpectraS3Response.DataPersistenceRule)
}

func NewPutDataPersistenceRuleSpectraS3Response(webResponse WebResponse) (*PutDataPersistenceRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDataPersistenceRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDataPolicyAclForGroupSpectraS3Request struct {
    DataPolicyId string
    GroupId string
}

func NewPutDataPolicyAclForGroupSpectraS3Request(dataPolicyId string, groupId string) *PutDataPolicyAclForGroupSpectraS3Request {
    return &PutDataPolicyAclForGroupSpectraS3Request{
        DataPolicyId: dataPolicyId,
        GroupId: groupId,
    }
}

type PutDataPolicyAclForGroupSpectraS3Response struct {
    DataPolicyAcl DataPolicyAcl
    Headers *http.Header
}

func (putDataPolicyAclForGroupSpectraS3Response *PutDataPolicyAclForGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDataPolicyAclForGroupSpectraS3Response.DataPolicyAcl)
}

func NewPutDataPolicyAclForGroupSpectraS3Response(webResponse WebResponse) (*PutDataPolicyAclForGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDataPolicyAclForGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDataPolicyAclForUserSpectraS3Request struct {
    DataPolicyId string
    UserId string
}

func NewPutDataPolicyAclForUserSpectraS3Request(dataPolicyId string, userId string) *PutDataPolicyAclForUserSpectraS3Request {
    return &PutDataPolicyAclForUserSpectraS3Request{
        DataPolicyId: dataPolicyId,
        UserId: userId,
    }
}

type PutDataPolicyAclForUserSpectraS3Response struct {
    DataPolicyAcl DataPolicyAcl
    Headers *http.Header
}

func (putDataPolicyAclForUserSpectraS3Response *PutDataPolicyAclForUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDataPolicyAclForUserSpectraS3Response.DataPolicyAcl)
}

func NewPutDataPolicyAclForUserSpectraS3Response(webResponse WebResponse) (*PutDataPolicyAclForUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDataPolicyAclForUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDataPolicySpectraS3Request struct {
    AlwaysForcePutJobCreation *bool
    AlwaysMinimizeSpanningAcrossMedia *bool
    BlobbingEnabled *bool
    ChecksumType ChecksumType
    DefaultBlobSize *int64
    DefaultGetJobPriority Priority
    DefaultPutJobPriority Priority
    DefaultVerifyAfterWrite *bool
    DefaultVerifyJobPriority Priority
    EndToEndCrcRequired *bool
    Name string
    RebuildPriority Priority
    Versioning VersioningLevel
}

func NewPutDataPolicySpectraS3Request(name string) *PutDataPolicySpectraS3Request {
    return &PutDataPolicySpectraS3Request{
        Name: name,
    }
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithAlwaysForcePutJobCreation(alwaysForcePutJobCreation bool) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.AlwaysForcePutJobCreation = &alwaysForcePutJobCreation
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithAlwaysMinimizeSpanningAcrossMedia(alwaysMinimizeSpanningAcrossMedia bool) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.AlwaysMinimizeSpanningAcrossMedia = &alwaysMinimizeSpanningAcrossMedia
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithBlobbingEnabled(blobbingEnabled bool) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.BlobbingEnabled = &blobbingEnabled
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithChecksumType(checksumType ChecksumType) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.ChecksumType = checksumType
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithDefaultBlobSize(defaultBlobSize int64) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.DefaultBlobSize = &defaultBlobSize
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithDefaultGetJobPriority(defaultGetJobPriority Priority) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.DefaultGetJobPriority = defaultGetJobPriority
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithDefaultPutJobPriority(defaultPutJobPriority Priority) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.DefaultPutJobPriority = defaultPutJobPriority
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithDefaultVerifyAfterWrite(defaultVerifyAfterWrite bool) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.DefaultVerifyAfterWrite = &defaultVerifyAfterWrite
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithDefaultVerifyJobPriority(defaultVerifyJobPriority Priority) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.DefaultVerifyJobPriority = defaultVerifyJobPriority
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithEndToEndCrcRequired(endToEndCrcRequired bool) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.EndToEndCrcRequired = &endToEndCrcRequired
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithRebuildPriority(rebuildPriority Priority) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.RebuildPriority = rebuildPriority
    return putDataPolicySpectraS3Request
}

func (putDataPolicySpectraS3Request *PutDataPolicySpectraS3Request) WithVersioning(versioning VersioningLevel) *PutDataPolicySpectraS3Request {
    putDataPolicySpectraS3Request.Versioning = versioning
    return putDataPolicySpectraS3Request
}

type PutDataPolicySpectraS3Response struct {
    DataPolicy DataPolicy
    Headers *http.Header
}

func (putDataPolicySpectraS3Response *PutDataPolicySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDataPolicySpectraS3Response.DataPolicy)
}

func NewPutDataPolicySpectraS3Response(webResponse WebResponse) (*PutDataPolicySpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDataPolicySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDs3DataReplicationRuleSpectraS3Request struct {
    DataPolicyId string
    DataReplicationRuleType DataReplicationRuleType
    ReplicateDeletes *bool
    TargetDataPolicy *string
    TargetId string
}

func NewPutDs3DataReplicationRuleSpectraS3Request(dataPolicyId string, dataReplicationRuleType DataReplicationRuleType, targetId string) *PutDs3DataReplicationRuleSpectraS3Request {
    return &PutDs3DataReplicationRuleSpectraS3Request{
        DataPolicyId: dataPolicyId,
        TargetId: targetId,
        DataReplicationRuleType: dataReplicationRuleType,
    }
}

func (putDs3DataReplicationRuleSpectraS3Request *PutDs3DataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *PutDs3DataReplicationRuleSpectraS3Request {
    putDs3DataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return putDs3DataReplicationRuleSpectraS3Request
}

func (putDs3DataReplicationRuleSpectraS3Request *PutDs3DataReplicationRuleSpectraS3Request) WithTargetDataPolicy(targetDataPolicy string) *PutDs3DataReplicationRuleSpectraS3Request {
    putDs3DataReplicationRuleSpectraS3Request.TargetDataPolicy = &targetDataPolicy
    return putDs3DataReplicationRuleSpectraS3Request
}

type PutDs3DataReplicationRuleSpectraS3Response struct {
    Ds3DataReplicationRule Ds3DataReplicationRule
    Headers *http.Header
}

func (putDs3DataReplicationRuleSpectraS3Response *PutDs3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDs3DataReplicationRuleSpectraS3Response.Ds3DataReplicationRule)
}

func NewPutDs3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*PutDs3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDs3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDs3TargetFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutDs3TargetFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutDs3TargetFailureNotificationRegistrationSpectraS3Request {
    return &PutDs3TargetFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putDs3TargetFailureNotificationRegistrationSpectraS3Request *PutDs3TargetFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutDs3TargetFailureNotificationRegistrationSpectraS3Request {
    putDs3TargetFailureNotificationRegistrationSpectraS3Request.Format = format
    return putDs3TargetFailureNotificationRegistrationSpectraS3Request
}

func (putDs3TargetFailureNotificationRegistrationSpectraS3Request *PutDs3TargetFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutDs3TargetFailureNotificationRegistrationSpectraS3Request {
    putDs3TargetFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putDs3TargetFailureNotificationRegistrationSpectraS3Request
}

func (putDs3TargetFailureNotificationRegistrationSpectraS3Request *PutDs3TargetFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutDs3TargetFailureNotificationRegistrationSpectraS3Request {
    putDs3TargetFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putDs3TargetFailureNotificationRegistrationSpectraS3Request
}

type PutDs3TargetFailureNotificationRegistrationSpectraS3Response struct {
    Ds3TargetFailureNotificationRegistration Ds3TargetFailureNotificationRegistration
    Headers *http.Header
}

func (putDs3TargetFailureNotificationRegistrationSpectraS3Response *PutDs3TargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDs3TargetFailureNotificationRegistrationSpectraS3Response.Ds3TargetFailureNotificationRegistration)
}

func NewPutDs3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutDs3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDs3TargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutDs3TargetReadPreferenceSpectraS3Request struct {
    BucketId string
    ReadPreference TargetReadPreferenceType
    TargetId string
}

func NewPutDs3TargetReadPreferenceSpectraS3Request(bucketId string, readPreference TargetReadPreferenceType, targetId string) *PutDs3TargetReadPreferenceSpectraS3Request {
    return &PutDs3TargetReadPreferenceSpectraS3Request{
        BucketId: bucketId,
        ReadPreference: readPreference,
        TargetId: targetId,
    }
}

type PutDs3TargetReadPreferenceSpectraS3Response struct {
    Ds3TargetReadPreference Ds3TargetReadPreference
    Headers *http.Header
}

func (putDs3TargetReadPreferenceSpectraS3Response *PutDs3TargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putDs3TargetReadPreferenceSpectraS3Response.Ds3TargetReadPreference)
}

func NewPutDs3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*PutDs3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutDs3TargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGlobalBucketAclForGroupSpectraS3Request struct {
    GroupId string
    Permission BucketAclPermission
}

func NewPutGlobalBucketAclForGroupSpectraS3Request(groupId string, permission BucketAclPermission) *PutGlobalBucketAclForGroupSpectraS3Request {
    return &PutGlobalBucketAclForGroupSpectraS3Request{
        GroupId: groupId,
        Permission: permission,
    }
}

type PutGlobalBucketAclForGroupSpectraS3Response struct {
    BucketAcl BucketAcl
    Headers *http.Header
}

func (putGlobalBucketAclForGroupSpectraS3Response *PutGlobalBucketAclForGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGlobalBucketAclForGroupSpectraS3Response.BucketAcl)
}

func NewPutGlobalBucketAclForGroupSpectraS3Response(webResponse WebResponse) (*PutGlobalBucketAclForGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGlobalBucketAclForGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGlobalBucketAclForUserSpectraS3Request struct {
    Permission BucketAclPermission
    UserId string
}

func NewPutGlobalBucketAclForUserSpectraS3Request(permission BucketAclPermission, userId string) *PutGlobalBucketAclForUserSpectraS3Request {
    return &PutGlobalBucketAclForUserSpectraS3Request{
        Permission: permission,
        UserId: userId,
    }
}

type PutGlobalBucketAclForUserSpectraS3Response struct {
    BucketAcl BucketAcl
    Headers *http.Header
}

func (putGlobalBucketAclForUserSpectraS3Response *PutGlobalBucketAclForUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGlobalBucketAclForUserSpectraS3Response.BucketAcl)
}

func NewPutGlobalBucketAclForUserSpectraS3Response(webResponse WebResponse) (*PutGlobalBucketAclForUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGlobalBucketAclForUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGlobalDataPolicyAclForGroupSpectraS3Request struct {
    GroupId string
}

func NewPutGlobalDataPolicyAclForGroupSpectraS3Request(groupId string) *PutGlobalDataPolicyAclForGroupSpectraS3Request {
    return &PutGlobalDataPolicyAclForGroupSpectraS3Request{
        GroupId: groupId,
    }
}

type PutGlobalDataPolicyAclForGroupSpectraS3Response struct {
    DataPolicyAcl DataPolicyAcl
    Headers *http.Header
}

func (putGlobalDataPolicyAclForGroupSpectraS3Response *PutGlobalDataPolicyAclForGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGlobalDataPolicyAclForGroupSpectraS3Response.DataPolicyAcl)
}

func NewPutGlobalDataPolicyAclForGroupSpectraS3Response(webResponse WebResponse) (*PutGlobalDataPolicyAclForGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGlobalDataPolicyAclForGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGlobalDataPolicyAclForUserSpectraS3Request struct {
    UserId string
}

func NewPutGlobalDataPolicyAclForUserSpectraS3Request(userId string) *PutGlobalDataPolicyAclForUserSpectraS3Request {
    return &PutGlobalDataPolicyAclForUserSpectraS3Request{
        UserId: userId,
    }
}

type PutGlobalDataPolicyAclForUserSpectraS3Response struct {
    DataPolicyAcl DataPolicyAcl
    Headers *http.Header
}

func (putGlobalDataPolicyAclForUserSpectraS3Response *PutGlobalDataPolicyAclForUserSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGlobalDataPolicyAclForUserSpectraS3Response.DataPolicyAcl)
}

func NewPutGlobalDataPolicyAclForUserSpectraS3Response(webResponse WebResponse) (*PutGlobalDataPolicyAclForUserSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGlobalDataPolicyAclForUserSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGroupGroupMemberSpectraS3Request struct {
    GroupId string
    MemberGroupId string
}

func NewPutGroupGroupMemberSpectraS3Request(groupId string, memberGroupId string) *PutGroupGroupMemberSpectraS3Request {
    return &PutGroupGroupMemberSpectraS3Request{
        GroupId: groupId,
        MemberGroupId: memberGroupId,
    }
}

type PutGroupGroupMemberSpectraS3Response struct {
    GroupMember GroupMember
    Headers *http.Header
}

func (putGroupGroupMemberSpectraS3Response *PutGroupGroupMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGroupGroupMemberSpectraS3Response.GroupMember)
}

func NewPutGroupGroupMemberSpectraS3Response(webResponse WebResponse) (*PutGroupGroupMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGroupGroupMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutGroupSpectraS3Request struct {
    Name string
}

func NewPutGroupSpectraS3Request(name string) *PutGroupSpectraS3Request {
    return &PutGroupSpectraS3Request{
        Name: name,
    }
}

type PutGroupSpectraS3Response struct {
    Group Group
    Headers *http.Header
}

func (putGroupSpectraS3Response *PutGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putGroupSpectraS3Response.Group)
}

func NewPutGroupSpectraS3Response(webResponse WebResponse) (*PutGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutJobCompletedNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    JobId *string
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutJobCompletedNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutJobCompletedNotificationRegistrationSpectraS3Request {
    return &PutJobCompletedNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putJobCompletedNotificationRegistrationSpectraS3Request *PutJobCompletedNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutJobCompletedNotificationRegistrationSpectraS3Request {
    putJobCompletedNotificationRegistrationSpectraS3Request.Format = format
    return putJobCompletedNotificationRegistrationSpectraS3Request
}

func (putJobCompletedNotificationRegistrationSpectraS3Request *PutJobCompletedNotificationRegistrationSpectraS3Request) WithJobId(jobId string) *PutJobCompletedNotificationRegistrationSpectraS3Request {
    putJobCompletedNotificationRegistrationSpectraS3Request.JobId = &jobId
    return putJobCompletedNotificationRegistrationSpectraS3Request
}

func (putJobCompletedNotificationRegistrationSpectraS3Request *PutJobCompletedNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutJobCompletedNotificationRegistrationSpectraS3Request {
    putJobCompletedNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putJobCompletedNotificationRegistrationSpectraS3Request
}

func (putJobCompletedNotificationRegistrationSpectraS3Request *PutJobCompletedNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutJobCompletedNotificationRegistrationSpectraS3Request {
    putJobCompletedNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putJobCompletedNotificationRegistrationSpectraS3Request
}

type PutJobCompletedNotificationRegistrationSpectraS3Response struct {
    JobCompletedNotificationRegistration JobCompletedNotificationRegistration
    Headers *http.Header
}

func (putJobCompletedNotificationRegistrationSpectraS3Response *PutJobCompletedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putJobCompletedNotificationRegistrationSpectraS3Response.JobCompletedNotificationRegistration)
}

func NewPutJobCompletedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutJobCompletedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutJobCompletedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutJobCreatedNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutJobCreatedNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutJobCreatedNotificationRegistrationSpectraS3Request {
    return &PutJobCreatedNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putJobCreatedNotificationRegistrationSpectraS3Request *PutJobCreatedNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutJobCreatedNotificationRegistrationSpectraS3Request {
    putJobCreatedNotificationRegistrationSpectraS3Request.Format = format
    return putJobCreatedNotificationRegistrationSpectraS3Request
}

func (putJobCreatedNotificationRegistrationSpectraS3Request *PutJobCreatedNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutJobCreatedNotificationRegistrationSpectraS3Request {
    putJobCreatedNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putJobCreatedNotificationRegistrationSpectraS3Request
}

func (putJobCreatedNotificationRegistrationSpectraS3Request *PutJobCreatedNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutJobCreatedNotificationRegistrationSpectraS3Request {
    putJobCreatedNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putJobCreatedNotificationRegistrationSpectraS3Request
}

type PutJobCreatedNotificationRegistrationSpectraS3Response struct {
    JobCreatedNotificationRegistration JobCreatedNotificationRegistration
    Headers *http.Header
}

func (putJobCreatedNotificationRegistrationSpectraS3Response *PutJobCreatedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putJobCreatedNotificationRegistrationSpectraS3Response.JobCreatedNotificationRegistration)
}

func NewPutJobCreatedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutJobCreatedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutJobCreatedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutJobCreationFailedNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutJobCreationFailedNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutJobCreationFailedNotificationRegistrationSpectraS3Request {
    return &PutJobCreationFailedNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putJobCreationFailedNotificationRegistrationSpectraS3Request *PutJobCreationFailedNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutJobCreationFailedNotificationRegistrationSpectraS3Request {
    putJobCreationFailedNotificationRegistrationSpectraS3Request.Format = format
    return putJobCreationFailedNotificationRegistrationSpectraS3Request
}

func (putJobCreationFailedNotificationRegistrationSpectraS3Request *PutJobCreationFailedNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutJobCreationFailedNotificationRegistrationSpectraS3Request {
    putJobCreationFailedNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putJobCreationFailedNotificationRegistrationSpectraS3Request
}

func (putJobCreationFailedNotificationRegistrationSpectraS3Request *PutJobCreationFailedNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutJobCreationFailedNotificationRegistrationSpectraS3Request {
    putJobCreationFailedNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putJobCreationFailedNotificationRegistrationSpectraS3Request
}

type PutJobCreationFailedNotificationRegistrationSpectraS3Response struct {
    JobCreationFailedNotificationRegistration JobCreationFailedNotificationRegistration
    Headers *http.Header
}

func (putJobCreationFailedNotificationRegistrationSpectraS3Response *PutJobCreationFailedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putJobCreationFailedNotificationRegistrationSpectraS3Response.JobCreationFailedNotificationRegistration)
}

func NewPutJobCreationFailedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutJobCreationFailedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutJobCreationFailedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutMultiPartUploadPartRequest struct {
    BucketName string
    ObjectName string
    Content ReaderWithSizeDecorator
    PartNumber int
    UploadId string
}

func NewPutMultiPartUploadPartRequest(bucketName string, objectName string, content ReaderWithSizeDecorator, partNumber int, uploadId string) *PutMultiPartUploadPartRequest {
    return &PutMultiPartUploadPartRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        PartNumber: partNumber,
        UploadId: uploadId,
        Content: content,
    }
}

type PutMultiPartUploadPartResponse struct {
    
    Headers *http.Header
}



func NewPutMultiPartUploadPartResponse(webResponse WebResponse) (*PutMultiPartUploadPartResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &PutMultiPartUploadPartResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutObjectCachedNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    JobId *string
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutObjectCachedNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutObjectCachedNotificationRegistrationSpectraS3Request {
    return &PutObjectCachedNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putObjectCachedNotificationRegistrationSpectraS3Request *PutObjectCachedNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutObjectCachedNotificationRegistrationSpectraS3Request {
    putObjectCachedNotificationRegistrationSpectraS3Request.Format = format
    return putObjectCachedNotificationRegistrationSpectraS3Request
}

func (putObjectCachedNotificationRegistrationSpectraS3Request *PutObjectCachedNotificationRegistrationSpectraS3Request) WithJobId(jobId string) *PutObjectCachedNotificationRegistrationSpectraS3Request {
    putObjectCachedNotificationRegistrationSpectraS3Request.JobId = &jobId
    return putObjectCachedNotificationRegistrationSpectraS3Request
}

func (putObjectCachedNotificationRegistrationSpectraS3Request *PutObjectCachedNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutObjectCachedNotificationRegistrationSpectraS3Request {
    putObjectCachedNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putObjectCachedNotificationRegistrationSpectraS3Request
}

func (putObjectCachedNotificationRegistrationSpectraS3Request *PutObjectCachedNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutObjectCachedNotificationRegistrationSpectraS3Request {
    putObjectCachedNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putObjectCachedNotificationRegistrationSpectraS3Request
}

type PutObjectCachedNotificationRegistrationSpectraS3Response struct {
    S3ObjectCachedNotificationRegistration S3ObjectCachedNotificationRegistration
    Headers *http.Header
}

func (putObjectCachedNotificationRegistrationSpectraS3Response *PutObjectCachedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putObjectCachedNotificationRegistrationSpectraS3Response.S3ObjectCachedNotificationRegistration)
}

func NewPutObjectCachedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutObjectCachedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutObjectCachedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutObjectLostNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutObjectLostNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutObjectLostNotificationRegistrationSpectraS3Request {
    return &PutObjectLostNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putObjectLostNotificationRegistrationSpectraS3Request *PutObjectLostNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutObjectLostNotificationRegistrationSpectraS3Request {
    putObjectLostNotificationRegistrationSpectraS3Request.Format = format
    return putObjectLostNotificationRegistrationSpectraS3Request
}

func (putObjectLostNotificationRegistrationSpectraS3Request *PutObjectLostNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutObjectLostNotificationRegistrationSpectraS3Request {
    putObjectLostNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putObjectLostNotificationRegistrationSpectraS3Request
}

func (putObjectLostNotificationRegistrationSpectraS3Request *PutObjectLostNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutObjectLostNotificationRegistrationSpectraS3Request {
    putObjectLostNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putObjectLostNotificationRegistrationSpectraS3Request
}

type PutObjectLostNotificationRegistrationSpectraS3Response struct {
    S3ObjectLostNotificationRegistration S3ObjectLostNotificationRegistration
    Headers *http.Header
}

func (putObjectLostNotificationRegistrationSpectraS3Response *PutObjectLostNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putObjectLostNotificationRegistrationSpectraS3Response.S3ObjectLostNotificationRegistration)
}

func NewPutObjectLostNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutObjectLostNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutObjectLostNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutObjectPersistedNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    JobId *string
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutObjectPersistedNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutObjectPersistedNotificationRegistrationSpectraS3Request {
    return &PutObjectPersistedNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putObjectPersistedNotificationRegistrationSpectraS3Request *PutObjectPersistedNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutObjectPersistedNotificationRegistrationSpectraS3Request {
    putObjectPersistedNotificationRegistrationSpectraS3Request.Format = format
    return putObjectPersistedNotificationRegistrationSpectraS3Request
}

func (putObjectPersistedNotificationRegistrationSpectraS3Request *PutObjectPersistedNotificationRegistrationSpectraS3Request) WithJobId(jobId string) *PutObjectPersistedNotificationRegistrationSpectraS3Request {
    putObjectPersistedNotificationRegistrationSpectraS3Request.JobId = &jobId
    return putObjectPersistedNotificationRegistrationSpectraS3Request
}

func (putObjectPersistedNotificationRegistrationSpectraS3Request *PutObjectPersistedNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutObjectPersistedNotificationRegistrationSpectraS3Request {
    putObjectPersistedNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putObjectPersistedNotificationRegistrationSpectraS3Request
}

func (putObjectPersistedNotificationRegistrationSpectraS3Request *PutObjectPersistedNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutObjectPersistedNotificationRegistrationSpectraS3Request {
    putObjectPersistedNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putObjectPersistedNotificationRegistrationSpectraS3Request
}

type PutObjectPersistedNotificationRegistrationSpectraS3Response struct {
    S3ObjectPersistedNotificationRegistration S3ObjectPersistedNotificationRegistration
    Headers *http.Header
}

func (putObjectPersistedNotificationRegistrationSpectraS3Response *PutObjectPersistedNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putObjectPersistedNotificationRegistrationSpectraS3Response.S3ObjectPersistedNotificationRegistration)
}

func NewPutObjectPersistedNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutObjectPersistedNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutObjectPersistedNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
const ( AMZ_META_HEADER = "x-amz-meta-" )

type PutObjectRequest struct {
    BucketName string
    ObjectName string
    Checksum Checksum
    Content ReaderWithSizeDecorator
    Job *string
    Metadata map[string]string
    Offset *int64
}

func NewPutObjectRequest(bucketName string, objectName string, content ReaderWithSizeDecorator) *PutObjectRequest {
    return &PutObjectRequest{
        BucketName: bucketName,
        ObjectName: objectName,
        Content: content,
        Checksum: NewNoneChecksum(),
        Metadata: make(map[string]string),
    }
}

func (putObjectRequest *PutObjectRequest) WithJob(job string) *PutObjectRequest {
    putObjectRequest.Job = &job
    return putObjectRequest
}

func (putObjectRequest *PutObjectRequest) WithOffset(offset int64) *PutObjectRequest {
    putObjectRequest.Offset = &offset
    return putObjectRequest
}


func (putObjectRequest *PutObjectRequest) WithChecksum(contentHash string, checksumType ChecksumType) *PutObjectRequest {
    putObjectRequest.Checksum.ContentHash = contentHash
    putObjectRequest.Checksum.Type = checksumType
    return putObjectRequest
}

func (putObjectRequest *PutObjectRequest) WithMetaData(key string, values ...string) *PutObjectRequest {
    if strings.HasPrefix(strings.ToLower(key), AMZ_META_HEADER) {
        putObjectRequest.Metadata[key] = strings.Join(values, ",")
    } else {
        putObjectRequest.Metadata[strings.ToLower(AMZ_META_HEADER + key)] = strings.Join(values, ",")
    }
    return putObjectRequest
}
type PutObjectResponse struct {
    
    Headers *http.Header
}



func NewPutObjectResponse(webResponse WebResponse) (*PutObjectResponse, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &PutObjectResponse{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutPoolFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutPoolFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutPoolFailureNotificationRegistrationSpectraS3Request {
    return &PutPoolFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putPoolFailureNotificationRegistrationSpectraS3Request *PutPoolFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutPoolFailureNotificationRegistrationSpectraS3Request {
    putPoolFailureNotificationRegistrationSpectraS3Request.Format = format
    return putPoolFailureNotificationRegistrationSpectraS3Request
}

func (putPoolFailureNotificationRegistrationSpectraS3Request *PutPoolFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutPoolFailureNotificationRegistrationSpectraS3Request {
    putPoolFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putPoolFailureNotificationRegistrationSpectraS3Request
}

func (putPoolFailureNotificationRegistrationSpectraS3Request *PutPoolFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutPoolFailureNotificationRegistrationSpectraS3Request {
    putPoolFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putPoolFailureNotificationRegistrationSpectraS3Request
}

type PutPoolFailureNotificationRegistrationSpectraS3Response struct {
    PoolFailureNotificationRegistration PoolFailureNotificationRegistration
    Headers *http.Header
}

func (putPoolFailureNotificationRegistrationSpectraS3Response *PutPoolFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putPoolFailureNotificationRegistrationSpectraS3Response.PoolFailureNotificationRegistration)
}

func NewPutPoolFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutPoolFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutPoolFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutPoolPartitionSpectraS3Request struct {
    Name string
    PoolType PoolType
}

func NewPutPoolPartitionSpectraS3Request(name string, poolType PoolType) *PutPoolPartitionSpectraS3Request {
    return &PutPoolPartitionSpectraS3Request{
        Name: name,
        PoolType: poolType,
    }
}

type PutPoolPartitionSpectraS3Response struct {
    PoolPartition PoolPartition
    Headers *http.Header
}

func (putPoolPartitionSpectraS3Response *PutPoolPartitionSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putPoolPartitionSpectraS3Response.PoolPartition)
}

func NewPutPoolPartitionSpectraS3Response(webResponse WebResponse) (*PutPoolPartitionSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutPoolPartitionSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutPoolStorageDomainMemberSpectraS3Request struct {
    PoolPartitionId string
    StorageDomainId string
    WritePreference WritePreferenceLevel
}

func NewPutPoolStorageDomainMemberSpectraS3Request(poolPartitionId string, storageDomainId string) *PutPoolStorageDomainMemberSpectraS3Request {
    return &PutPoolStorageDomainMemberSpectraS3Request{
        PoolPartitionId: poolPartitionId,
        StorageDomainId: storageDomainId,
    }
}

func (putPoolStorageDomainMemberSpectraS3Request *PutPoolStorageDomainMemberSpectraS3Request) WithWritePreference(writePreference WritePreferenceLevel) *PutPoolStorageDomainMemberSpectraS3Request {
    putPoolStorageDomainMemberSpectraS3Request.WritePreference = writePreference
    return putPoolStorageDomainMemberSpectraS3Request
}

type PutPoolStorageDomainMemberSpectraS3Response struct {
    StorageDomainMember StorageDomainMember
    Headers *http.Header
}

func (putPoolStorageDomainMemberSpectraS3Response *PutPoolStorageDomainMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putPoolStorageDomainMemberSpectraS3Response.StorageDomainMember)
}

func NewPutPoolStorageDomainMemberSpectraS3Response(webResponse WebResponse) (*PutPoolStorageDomainMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutPoolStorageDomainMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutS3DataReplicationRuleSpectraS3Request struct {
    DataPolicyId string
    DataReplicationRuleType DataReplicationRuleType
    InitialDataPlacement S3InitialDataPlacementPolicy
    MaxBlobPartSizeInBytes *int64
    ReplicateDeletes *bool
    TargetId string
}

func NewPutS3DataReplicationRuleSpectraS3Request(dataPolicyId string, dataReplicationRuleType DataReplicationRuleType, targetId string) *PutS3DataReplicationRuleSpectraS3Request {
    return &PutS3DataReplicationRuleSpectraS3Request{
        DataPolicyId: dataPolicyId,
        TargetId: targetId,
        DataReplicationRuleType: dataReplicationRuleType,
    }
}

func (putS3DataReplicationRuleSpectraS3Request *PutS3DataReplicationRuleSpectraS3Request) WithInitialDataPlacement(initialDataPlacement S3InitialDataPlacementPolicy) *PutS3DataReplicationRuleSpectraS3Request {
    putS3DataReplicationRuleSpectraS3Request.InitialDataPlacement = initialDataPlacement
    return putS3DataReplicationRuleSpectraS3Request
}

func (putS3DataReplicationRuleSpectraS3Request *PutS3DataReplicationRuleSpectraS3Request) WithMaxBlobPartSizeInBytes(maxBlobPartSizeInBytes int64) *PutS3DataReplicationRuleSpectraS3Request {
    putS3DataReplicationRuleSpectraS3Request.MaxBlobPartSizeInBytes = &maxBlobPartSizeInBytes
    return putS3DataReplicationRuleSpectraS3Request
}

func (putS3DataReplicationRuleSpectraS3Request *PutS3DataReplicationRuleSpectraS3Request) WithReplicateDeletes(replicateDeletes bool) *PutS3DataReplicationRuleSpectraS3Request {
    putS3DataReplicationRuleSpectraS3Request.ReplicateDeletes = &replicateDeletes
    return putS3DataReplicationRuleSpectraS3Request
}

type PutS3DataReplicationRuleSpectraS3Response struct {
    S3DataReplicationRule S3DataReplicationRule
    Headers *http.Header
}

func (putS3DataReplicationRuleSpectraS3Response *PutS3DataReplicationRuleSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putS3DataReplicationRuleSpectraS3Response.S3DataReplicationRule)
}

func NewPutS3DataReplicationRuleSpectraS3Response(webResponse WebResponse) (*PutS3DataReplicationRuleSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutS3DataReplicationRuleSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutS3TargetBucketNameSpectraS3Request struct {
    BucketId string
    Name string
    TargetId string
}

func NewPutS3TargetBucketNameSpectraS3Request(bucketId string, name string, targetId string) *PutS3TargetBucketNameSpectraS3Request {
    return &PutS3TargetBucketNameSpectraS3Request{
        BucketId: bucketId,
        Name: name,
        TargetId: targetId,
    }
}

type PutS3TargetBucketNameSpectraS3Response struct {
    S3TargetBucketName S3TargetBucketName
    Headers *http.Header
}

func (putS3TargetBucketNameSpectraS3Response *PutS3TargetBucketNameSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putS3TargetBucketNameSpectraS3Response.S3TargetBucketName)
}

func NewPutS3TargetBucketNameSpectraS3Response(webResponse WebResponse) (*PutS3TargetBucketNameSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutS3TargetBucketNameSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutS3TargetFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutS3TargetFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutS3TargetFailureNotificationRegistrationSpectraS3Request {
    return &PutS3TargetFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putS3TargetFailureNotificationRegistrationSpectraS3Request *PutS3TargetFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutS3TargetFailureNotificationRegistrationSpectraS3Request {
    putS3TargetFailureNotificationRegistrationSpectraS3Request.Format = format
    return putS3TargetFailureNotificationRegistrationSpectraS3Request
}

func (putS3TargetFailureNotificationRegistrationSpectraS3Request *PutS3TargetFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutS3TargetFailureNotificationRegistrationSpectraS3Request {
    putS3TargetFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putS3TargetFailureNotificationRegistrationSpectraS3Request
}

func (putS3TargetFailureNotificationRegistrationSpectraS3Request *PutS3TargetFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutS3TargetFailureNotificationRegistrationSpectraS3Request {
    putS3TargetFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putS3TargetFailureNotificationRegistrationSpectraS3Request
}

type PutS3TargetFailureNotificationRegistrationSpectraS3Response struct {
    S3TargetFailureNotificationRegistration S3TargetFailureNotificationRegistration
    Headers *http.Header
}

func (putS3TargetFailureNotificationRegistrationSpectraS3Response *PutS3TargetFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putS3TargetFailureNotificationRegistrationSpectraS3Response.S3TargetFailureNotificationRegistration)
}

func NewPutS3TargetFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutS3TargetFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutS3TargetFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutS3TargetReadPreferenceSpectraS3Request struct {
    BucketId string
    ReadPreference TargetReadPreferenceType
    TargetId string
}

func NewPutS3TargetReadPreferenceSpectraS3Request(bucketId string, readPreference TargetReadPreferenceType, targetId string) *PutS3TargetReadPreferenceSpectraS3Request {
    return &PutS3TargetReadPreferenceSpectraS3Request{
        BucketId: bucketId,
        ReadPreference: readPreference,
        TargetId: targetId,
    }
}

type PutS3TargetReadPreferenceSpectraS3Response struct {
    S3TargetReadPreference S3TargetReadPreference
    Headers *http.Header
}

func (putS3TargetReadPreferenceSpectraS3Response *PutS3TargetReadPreferenceSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putS3TargetReadPreferenceSpectraS3Response.S3TargetReadPreference)
}

func NewPutS3TargetReadPreferenceSpectraS3Response(webResponse WebResponse) (*PutS3TargetReadPreferenceSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutS3TargetReadPreferenceSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutStorageDomainFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutStorageDomainFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutStorageDomainFailureNotificationRegistrationSpectraS3Request {
    return &PutStorageDomainFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putStorageDomainFailureNotificationRegistrationSpectraS3Request *PutStorageDomainFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutStorageDomainFailureNotificationRegistrationSpectraS3Request {
    putStorageDomainFailureNotificationRegistrationSpectraS3Request.Format = format
    return putStorageDomainFailureNotificationRegistrationSpectraS3Request
}

func (putStorageDomainFailureNotificationRegistrationSpectraS3Request *PutStorageDomainFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutStorageDomainFailureNotificationRegistrationSpectraS3Request {
    putStorageDomainFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putStorageDomainFailureNotificationRegistrationSpectraS3Request
}

func (putStorageDomainFailureNotificationRegistrationSpectraS3Request *PutStorageDomainFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutStorageDomainFailureNotificationRegistrationSpectraS3Request {
    putStorageDomainFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putStorageDomainFailureNotificationRegistrationSpectraS3Request
}

type PutStorageDomainFailureNotificationRegistrationSpectraS3Response struct {
    StorageDomainFailureNotificationRegistration StorageDomainFailureNotificationRegistration
    Headers *http.Header
}

func (putStorageDomainFailureNotificationRegistrationSpectraS3Response *PutStorageDomainFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putStorageDomainFailureNotificationRegistrationSpectraS3Response.StorageDomainFailureNotificationRegistration)
}

func NewPutStorageDomainFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutStorageDomainFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutStorageDomainFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutStorageDomainSpectraS3Request struct {
    AutoEjectMediaFullThreshold *int64
    AutoEjectUponCron *string
    AutoEjectUponJobCancellation *bool
    AutoEjectUponJobCompletion *bool
    AutoEjectUponMediaFull *bool
    LtfsFileNaming LtfsFileNamingMode
    MaximumAutoVerificationFrequencyInDays *int
    MaxTapeFragmentationPercent *int
    MediaEjectionAllowed *bool
    Name string
    SecureMediaAllocation *bool
    VerifyPriorToAutoEject Priority
    WriteOptimization WriteOptimization
}

func NewPutStorageDomainSpectraS3Request(name string) *PutStorageDomainSpectraS3Request {
    return &PutStorageDomainSpectraS3Request{
        Name: name,
    }
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithAutoEjectMediaFullThreshold(autoEjectMediaFullThreshold int64) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.AutoEjectMediaFullThreshold = &autoEjectMediaFullThreshold
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithAutoEjectUponCron(autoEjectUponCron string) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.AutoEjectUponCron = &autoEjectUponCron
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithAutoEjectUponJobCancellation(autoEjectUponJobCancellation bool) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.AutoEjectUponJobCancellation = &autoEjectUponJobCancellation
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithAutoEjectUponJobCompletion(autoEjectUponJobCompletion bool) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.AutoEjectUponJobCompletion = &autoEjectUponJobCompletion
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithAutoEjectUponMediaFull(autoEjectUponMediaFull bool) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.AutoEjectUponMediaFull = &autoEjectUponMediaFull
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithLtfsFileNaming(ltfsFileNaming LtfsFileNamingMode) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.LtfsFileNaming = ltfsFileNaming
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithMaxTapeFragmentationPercent(maxTapeFragmentationPercent int) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.MaxTapeFragmentationPercent = &maxTapeFragmentationPercent
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithMaximumAutoVerificationFrequencyInDays(maximumAutoVerificationFrequencyInDays int) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.MaximumAutoVerificationFrequencyInDays = &maximumAutoVerificationFrequencyInDays
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithMediaEjectionAllowed(mediaEjectionAllowed bool) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.MediaEjectionAllowed = &mediaEjectionAllowed
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithSecureMediaAllocation(secureMediaAllocation bool) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.SecureMediaAllocation = &secureMediaAllocation
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithVerifyPriorToAutoEject(verifyPriorToAutoEject Priority) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.VerifyPriorToAutoEject = verifyPriorToAutoEject
    return putStorageDomainSpectraS3Request
}

func (putStorageDomainSpectraS3Request *PutStorageDomainSpectraS3Request) WithWriteOptimization(writeOptimization WriteOptimization) *PutStorageDomainSpectraS3Request {
    putStorageDomainSpectraS3Request.WriteOptimization = writeOptimization
    return putStorageDomainSpectraS3Request
}

type PutStorageDomainSpectraS3Response struct {
    StorageDomain StorageDomain
    Headers *http.Header
}

func (putStorageDomainSpectraS3Response *PutStorageDomainSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putStorageDomainSpectraS3Response.StorageDomain)
}

func NewPutStorageDomainSpectraS3Response(webResponse WebResponse) (*PutStorageDomainSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutStorageDomainSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutSystemFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutSystemFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutSystemFailureNotificationRegistrationSpectraS3Request {
    return &PutSystemFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putSystemFailureNotificationRegistrationSpectraS3Request *PutSystemFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutSystemFailureNotificationRegistrationSpectraS3Request {
    putSystemFailureNotificationRegistrationSpectraS3Request.Format = format
    return putSystemFailureNotificationRegistrationSpectraS3Request
}

func (putSystemFailureNotificationRegistrationSpectraS3Request *PutSystemFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutSystemFailureNotificationRegistrationSpectraS3Request {
    putSystemFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putSystemFailureNotificationRegistrationSpectraS3Request
}

func (putSystemFailureNotificationRegistrationSpectraS3Request *PutSystemFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutSystemFailureNotificationRegistrationSpectraS3Request {
    putSystemFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putSystemFailureNotificationRegistrationSpectraS3Request
}

type PutSystemFailureNotificationRegistrationSpectraS3Response struct {
    SystemFailureNotificationRegistration SystemFailureNotificationRegistration
    Headers *http.Header
}

func (putSystemFailureNotificationRegistrationSpectraS3Response *PutSystemFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putSystemFailureNotificationRegistrationSpectraS3Response.SystemFailureNotificationRegistration)
}

func NewPutSystemFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutSystemFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutSystemFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutTapeDensityDirectiveSpectraS3Request struct {
    Density TapeDriveType
    PartitionId string
    TapeType string
}

func NewPutTapeDensityDirectiveSpectraS3Request(density TapeDriveType, partitionId string, tapeType string) *PutTapeDensityDirectiveSpectraS3Request {
    return &PutTapeDensityDirectiveSpectraS3Request{
        Density: density,
        PartitionId: partitionId,
        TapeType: tapeType,
    }
}

type PutTapeDensityDirectiveSpectraS3Response struct {
    TapeDensityDirective TapeDensityDirective
    Headers *http.Header
}

func (putTapeDensityDirectiveSpectraS3Response *PutTapeDensityDirectiveSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putTapeDensityDirectiveSpectraS3Response.TapeDensityDirective)
}

func NewPutTapeDensityDirectiveSpectraS3Response(webResponse WebResponse) (*PutTapeDensityDirectiveSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutTapeDensityDirectiveSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutTapeFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutTapeFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutTapeFailureNotificationRegistrationSpectraS3Request {
    return &PutTapeFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putTapeFailureNotificationRegistrationSpectraS3Request *PutTapeFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutTapeFailureNotificationRegistrationSpectraS3Request {
    putTapeFailureNotificationRegistrationSpectraS3Request.Format = format
    return putTapeFailureNotificationRegistrationSpectraS3Request
}

func (putTapeFailureNotificationRegistrationSpectraS3Request *PutTapeFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutTapeFailureNotificationRegistrationSpectraS3Request {
    putTapeFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putTapeFailureNotificationRegistrationSpectraS3Request
}

func (putTapeFailureNotificationRegistrationSpectraS3Request *PutTapeFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutTapeFailureNotificationRegistrationSpectraS3Request {
    putTapeFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putTapeFailureNotificationRegistrationSpectraS3Request
}

type PutTapeFailureNotificationRegistrationSpectraS3Response struct {
    TapeFailureNotificationRegistration TapeFailureNotificationRegistration
    Headers *http.Header
}

func (putTapeFailureNotificationRegistrationSpectraS3Response *PutTapeFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putTapeFailureNotificationRegistrationSpectraS3Response.TapeFailureNotificationRegistration)
}

func NewPutTapeFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutTapeFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutTapeFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutTapePartitionFailureNotificationRegistrationSpectraS3Request struct {
    Format HttpResponseFormatType
    NamingConvention NamingConventionType
    NotificationEndPoint string
    NotificationHttpMethod RequestType
}

func NewPutTapePartitionFailureNotificationRegistrationSpectraS3Request(notificationEndPoint string) *PutTapePartitionFailureNotificationRegistrationSpectraS3Request {
    return &PutTapePartitionFailureNotificationRegistrationSpectraS3Request{
        NotificationEndPoint: notificationEndPoint,
    }
}

func (putTapePartitionFailureNotificationRegistrationSpectraS3Request *PutTapePartitionFailureNotificationRegistrationSpectraS3Request) WithFormat(format HttpResponseFormatType) *PutTapePartitionFailureNotificationRegistrationSpectraS3Request {
    putTapePartitionFailureNotificationRegistrationSpectraS3Request.Format = format
    return putTapePartitionFailureNotificationRegistrationSpectraS3Request
}

func (putTapePartitionFailureNotificationRegistrationSpectraS3Request *PutTapePartitionFailureNotificationRegistrationSpectraS3Request) WithNamingConvention(namingConvention NamingConventionType) *PutTapePartitionFailureNotificationRegistrationSpectraS3Request {
    putTapePartitionFailureNotificationRegistrationSpectraS3Request.NamingConvention = namingConvention
    return putTapePartitionFailureNotificationRegistrationSpectraS3Request
}

func (putTapePartitionFailureNotificationRegistrationSpectraS3Request *PutTapePartitionFailureNotificationRegistrationSpectraS3Request) WithNotificationHttpMethod(notificationHttpMethod RequestType) *PutTapePartitionFailureNotificationRegistrationSpectraS3Request {
    putTapePartitionFailureNotificationRegistrationSpectraS3Request.NotificationHttpMethod = notificationHttpMethod
    return putTapePartitionFailureNotificationRegistrationSpectraS3Request
}

type PutTapePartitionFailureNotificationRegistrationSpectraS3Response struct {
    TapePartitionFailureNotificationRegistration TapePartitionFailureNotificationRegistration
    Headers *http.Header
}

func (putTapePartitionFailureNotificationRegistrationSpectraS3Response *PutTapePartitionFailureNotificationRegistrationSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putTapePartitionFailureNotificationRegistrationSpectraS3Response.TapePartitionFailureNotificationRegistration)
}

func NewPutTapePartitionFailureNotificationRegistrationSpectraS3Response(webResponse WebResponse) (*PutTapePartitionFailureNotificationRegistrationSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutTapePartitionFailureNotificationRegistrationSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutTapeStorageDomainMemberSpectraS3Request struct {
    StorageDomainId string
    TapePartitionId string
    TapeType string
    WritePreference WritePreferenceLevel
}

func NewPutTapeStorageDomainMemberSpectraS3Request(storageDomainId string, tapePartitionId string, tapeType string) *PutTapeStorageDomainMemberSpectraS3Request {
    return &PutTapeStorageDomainMemberSpectraS3Request{
        StorageDomainId: storageDomainId,
        TapePartitionId: tapePartitionId,
        TapeType: tapeType,
    }
}

func (putTapeStorageDomainMemberSpectraS3Request *PutTapeStorageDomainMemberSpectraS3Request) WithWritePreference(writePreference WritePreferenceLevel) *PutTapeStorageDomainMemberSpectraS3Request {
    putTapeStorageDomainMemberSpectraS3Request.WritePreference = writePreference
    return putTapeStorageDomainMemberSpectraS3Request
}

type PutTapeStorageDomainMemberSpectraS3Response struct {
    StorageDomainMember StorageDomainMember
    Headers *http.Header
}

func (putTapeStorageDomainMemberSpectraS3Response *PutTapeStorageDomainMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putTapeStorageDomainMemberSpectraS3Response.StorageDomainMember)
}

func NewPutTapeStorageDomainMemberSpectraS3Response(webResponse WebResponse) (*PutTapeStorageDomainMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutTapeStorageDomainMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type PutUserGroupMemberSpectraS3Request struct {
    GroupId string
    MemberUserId string
}

func NewPutUserGroupMemberSpectraS3Request(groupId string, memberUserId string) *PutUserGroupMemberSpectraS3Request {
    return &PutUserGroupMemberSpectraS3Request{
        GroupId: groupId,
        MemberUserId: memberUserId,
    }
}

type PutUserGroupMemberSpectraS3Response struct {
    GroupMember GroupMember
    Headers *http.Header
}

func (putUserGroupMemberSpectraS3Response *PutUserGroupMemberSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &putUserGroupMemberSpectraS3Response.GroupMember)
}

func NewPutUserGroupMemberSpectraS3Response(webResponse WebResponse) (*PutUserGroupMemberSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body PutUserGroupMemberSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type Quiesced Enum

const (
    QUIESCED_NO Quiesced = 1 + iota
    QUIESCED_PENDING Quiesced = 1 + iota
    QUIESCED_YES Quiesced = 1 + iota
)

func (quiesced *Quiesced) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *quiesced = UNDEFINED
        case "NO": *quiesced = QUIESCED_NO
        case "PENDING": *quiesced = QUIESCED_PENDING
        case "YES": *quiesced = QUIESCED_YES
        default:
            *quiesced = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into Quiesced", str))
    }
    return nil
}

func (quiesced Quiesced) String() string {
    switch quiesced {
        case QUIESCED_NO: return "NO"
        case QUIESCED_PENDING: return "PENDING"
        case QUIESCED_YES: return "YES"
        default:
            log.Printf("Error: invalid Quiesced represented by '%d'", quiesced)
            return ""
    }
}

func (quiesced Quiesced) StringPtr() *string {
    if quiesced == UNDEFINED {
        return nil
    }
    result := quiesced.String()
    return &result
}
type RawImportAllTapesSpectraS3Request struct {
    BucketId string
    StorageDomainId *string
    TaskPriority Priority
}

func NewRawImportAllTapesSpectraS3Request(bucketId string) *RawImportAllTapesSpectraS3Request {
    return &RawImportAllTapesSpectraS3Request{
        BucketId: bucketId,
    }
}

func (rawImportAllTapesSpectraS3Request *RawImportAllTapesSpectraS3Request) WithStorageDomainId(storageDomainId string) *RawImportAllTapesSpectraS3Request {
    rawImportAllTapesSpectraS3Request.StorageDomainId = &storageDomainId
    return rawImportAllTapesSpectraS3Request
}

func (rawImportAllTapesSpectraS3Request *RawImportAllTapesSpectraS3Request) WithTaskPriority(taskPriority Priority) *RawImportAllTapesSpectraS3Request {
    rawImportAllTapesSpectraS3Request.TaskPriority = taskPriority
    return rawImportAllTapesSpectraS3Request
}

type RawImportAllTapesSpectraS3Response struct {
    
    Headers *http.Header
}



func NewRawImportAllTapesSpectraS3Response(webResponse WebResponse) (*RawImportAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &RawImportAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type RawImportTapeSpectraS3Request struct {
    BucketId string
    StorageDomainId *string
    TapeId string
    TaskPriority Priority
}

func NewRawImportTapeSpectraS3Request(bucketId string, tapeId string) *RawImportTapeSpectraS3Request {
    return &RawImportTapeSpectraS3Request{
        TapeId: tapeId,
        BucketId: bucketId,
    }
}

func (rawImportTapeSpectraS3Request *RawImportTapeSpectraS3Request) WithStorageDomainId(storageDomainId string) *RawImportTapeSpectraS3Request {
    rawImportTapeSpectraS3Request.StorageDomainId = &storageDomainId
    return rawImportTapeSpectraS3Request
}

func (rawImportTapeSpectraS3Request *RawImportTapeSpectraS3Request) WithTaskPriority(taskPriority Priority) *RawImportTapeSpectraS3Request {
    rawImportTapeSpectraS3Request.TaskPriority = taskPriority
    return rawImportTapeSpectraS3Request
}

type RawImportTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (rawImportTapeSpectraS3Response *RawImportTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &rawImportTapeSpectraS3Response.Tape)
}

func NewRawImportTapeSpectraS3Response(webResponse WebResponse) (*RawImportTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body RawImportTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ReaderWithSizeDecorator interface {
    io.Reader
    Size() (int64, error)
}

// ReadCloser with size knowledge. Networking layer will automatically close
// the reader when finished transmitting request.
type ReadCloserWithSizeDecorator interface {
    io.ReadCloser
    Size() (int64, error)
}
type RegenerateUserSecretKeySpectraS3Request struct {
    UserId string
}

func NewRegenerateUserSecretKeySpectraS3Request(userId string) *RegenerateUserSecretKeySpectraS3Request {
    return &RegenerateUserSecretKeySpectraS3Request{
        UserId: userId,
    }
}

type RegenerateUserSecretKeySpectraS3Response struct {
    SpectraUser SpectraUser
    Headers *http.Header
}

func (regenerateUserSecretKeySpectraS3Response *RegenerateUserSecretKeySpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &regenerateUserSecretKeySpectraS3Response.SpectraUser)
}

func NewRegenerateUserSecretKeySpectraS3Response(webResponse WebResponse) (*RegenerateUserSecretKeySpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body RegenerateUserSecretKeySpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type RegisterAzureTargetSpectraS3Request struct {
    AccountKey string
    AccountName string
    AutoVerifyFrequencyInDays *int
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    Name string
    PermitGoingOutOfSync *bool
}

func NewRegisterAzureTargetSpectraS3Request(accountKey string, accountName string, name string) *RegisterAzureTargetSpectraS3Request {
    return &RegisterAzureTargetSpectraS3Request{
        AccountKey: accountKey,
        AccountName: accountName,
        Name: name,
    }
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithAutoVerifyFrequencyInDays(autoVerifyFrequencyInDays int) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.AutoVerifyFrequencyInDays = &autoVerifyFrequencyInDays
    return registerAzureTargetSpectraS3Request
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithCloudBucketPrefix(cloudBucketPrefix string) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.CloudBucketPrefix = &cloudBucketPrefix
    return registerAzureTargetSpectraS3Request
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithCloudBucketSuffix(cloudBucketSuffix string) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.CloudBucketSuffix = &cloudBucketSuffix
    return registerAzureTargetSpectraS3Request
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return registerAzureTargetSpectraS3Request
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithHttps(https bool) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.Https = &https
    return registerAzureTargetSpectraS3Request
}

func (registerAzureTargetSpectraS3Request *RegisterAzureTargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *RegisterAzureTargetSpectraS3Request {
    registerAzureTargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return registerAzureTargetSpectraS3Request
}

type RegisterAzureTargetSpectraS3Response struct {
    AzureTarget AzureTarget
    Headers *http.Header
}

func (registerAzureTargetSpectraS3Response *RegisterAzureTargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &registerAzureTargetSpectraS3Response.AzureTarget)
}

func NewRegisterAzureTargetSpectraS3Response(webResponse WebResponse) (*RegisterAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body RegisterAzureTargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type RegisterDs3TargetSpectraS3Request struct {
    AccessControlReplication Ds3TargetAccessControlReplication
    AdminAuthId string
    AdminSecretKey string
    DataPathEndPoint string
    DataPathHttps *bool
    DataPathPort *int
    DataPathProxy *string
    DataPathVerifyCertificate *bool
    DefaultReadPreference TargetReadPreferenceType
    Name string
    PermitGoingOutOfSync *bool
    ReplicatedUserDefaultDataPolicy *string
}

func NewRegisterDs3TargetSpectraS3Request(adminAuthId string, adminSecretKey string, dataPathEndPoint string, name string) *RegisterDs3TargetSpectraS3Request {
    return &RegisterDs3TargetSpectraS3Request{
        AdminAuthId: adminAuthId,
        AdminSecretKey: adminSecretKey,
        DataPathEndPoint: dataPathEndPoint,
        Name: name,
    }
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithAccessControlReplication(accessControlReplication Ds3TargetAccessControlReplication) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.AccessControlReplication = accessControlReplication
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithDataPathHttps(dataPathHttps bool) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.DataPathHttps = &dataPathHttps
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithDataPathPort(dataPathPort int) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.DataPathPort = &dataPathPort
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithDataPathProxy(dataPathProxy string) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.DataPathProxy = &dataPathProxy
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithDataPathVerifyCertificate(dataPathVerifyCertificate bool) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.DataPathVerifyCertificate = &dataPathVerifyCertificate
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return registerDs3TargetSpectraS3Request
}

func (registerDs3TargetSpectraS3Request *RegisterDs3TargetSpectraS3Request) WithReplicatedUserDefaultDataPolicy(replicatedUserDefaultDataPolicy string) *RegisterDs3TargetSpectraS3Request {
    registerDs3TargetSpectraS3Request.ReplicatedUserDefaultDataPolicy = &replicatedUserDefaultDataPolicy
    return registerDs3TargetSpectraS3Request
}

type RegisterDs3TargetSpectraS3Response struct {
    Ds3Target Ds3Target
    Headers *http.Header
}

func (registerDs3TargetSpectraS3Response *RegisterDs3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &registerDs3TargetSpectraS3Response.Ds3Target)
}

func NewRegisterDs3TargetSpectraS3Response(webResponse WebResponse) (*RegisterDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body RegisterDs3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type RegisterS3TargetSpectraS3Request struct {
    AccessKey string
    AutoVerifyFrequencyInDays *int
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DataPathEndPoint *string
    DefaultReadPreference TargetReadPreferenceType
    Https *bool
    Name string
    OfflineDataStagingWindowInTb *int
    PermitGoingOutOfSync *bool
    ProxyDomain *string
    ProxyHost *string
    ProxyPassword *string
    ProxyPort *int
    ProxyUsername *string
    Region S3Region
    SecretKey string
    StagedDataExpirationInDays *int
}

func NewRegisterS3TargetSpectraS3Request(accessKey string, name string, secretKey string) *RegisterS3TargetSpectraS3Request {
    return &RegisterS3TargetSpectraS3Request{
        AccessKey: accessKey,
        Name: name,
        SecretKey: secretKey,
    }
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithAutoVerifyFrequencyInDays(autoVerifyFrequencyInDays int) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.AutoVerifyFrequencyInDays = &autoVerifyFrequencyInDays
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithCloudBucketPrefix(cloudBucketPrefix string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.CloudBucketPrefix = &cloudBucketPrefix
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithCloudBucketSuffix(cloudBucketSuffix string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.CloudBucketSuffix = &cloudBucketSuffix
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithDataPathEndPoint(dataPathEndPoint string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.DataPathEndPoint = &dataPathEndPoint
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithDefaultReadPreference(defaultReadPreference TargetReadPreferenceType) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.DefaultReadPreference = defaultReadPreference
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithHttps(https bool) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.Https = &https
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithOfflineDataStagingWindowInTb(offlineDataStagingWindowInTb int) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.OfflineDataStagingWindowInTb = &offlineDataStagingWindowInTb
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithPermitGoingOutOfSync(permitGoingOutOfSync bool) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.PermitGoingOutOfSync = &permitGoingOutOfSync
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithProxyDomain(proxyDomain string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.ProxyDomain = &proxyDomain
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithProxyHost(proxyHost string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.ProxyHost = &proxyHost
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithProxyPassword(proxyPassword string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.ProxyPassword = &proxyPassword
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithProxyPort(proxyPort int) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.ProxyPort = &proxyPort
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithProxyUsername(proxyUsername string) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.ProxyUsername = &proxyUsername
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithRegion(region S3Region) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.Region = region
    return registerS3TargetSpectraS3Request
}

func (registerS3TargetSpectraS3Request *RegisterS3TargetSpectraS3Request) WithStagedDataExpirationInDays(stagedDataExpirationInDays int) *RegisterS3TargetSpectraS3Request {
    registerS3TargetSpectraS3Request.StagedDataExpirationInDays = &stagedDataExpirationInDays
    return registerS3TargetSpectraS3Request
}

type RegisterS3TargetSpectraS3Response struct {
    S3Target S3Target
    Headers *http.Header
}

func (registerS3TargetSpectraS3Response *RegisterS3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &registerS3TargetSpectraS3Response.S3Target)
}

func NewRegisterS3TargetSpectraS3Response(webResponse WebResponse) (*RegisterS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 201 }

    switch code := webResponse.StatusCode(); code {
    case 201:
        var body RegisterS3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type ReplicatePutJobSpectraS3Request struct {
    BucketName string
    Priority Priority
    RequestPayload string
}

func NewReplicatePutJobSpectraS3Request(bucketName string, requestPayload string) *ReplicatePutJobSpectraS3Request {
    return &ReplicatePutJobSpectraS3Request{
        BucketName: bucketName,
        RequestPayload: requestPayload,
    }
}

func (replicatePutJobSpectraS3Request *ReplicatePutJobSpectraS3Request) WithPriority(priority Priority) *ReplicatePutJobSpectraS3Request {
    replicatePutJobSpectraS3Request.Priority = priority
    return replicatePutJobSpectraS3Request
}

type ReplicatePutJobSpectraS3Response struct {
    MasterObjectList *MasterObjectList
    Headers *http.Header
}

func (replicatePutJobSpectraS3Response *ReplicatePutJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, replicatePutJobSpectraS3Response.MasterObjectList)
}

func NewReplicatePutJobSpectraS3Response(webResponse WebResponse) (*ReplicatePutJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200, 204 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ReplicatePutJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    case 204:
        return &ReplicatePutJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type CompleteMultipartUpload struct {
    Parts []Part `xml:"Part"`
}

type Part struct {
    PartNumber int
    ETag string
}

type Ds3PutObject struct {
    Name string `xml:"Name,attr"`
    Size int64 `xml:"Size,attr"`
}

type Ds3GetObject struct {
    Name string `xml:"Name,attr"`
    Length *int64 `xml:"Length,attr,omitempty"`
    Offset *int64 `xml:"Offset,attr,omitempty"`
}

func NewDs3GetObject(name string) Ds3GetObject {
    return Ds3GetObject{Name:name}
}

// Creates a Ds3GetObject used for partial objects
func NewPartialDs3GetObject(name string, length int64, offset int64) Ds3GetObject {
    return Ds3GetObject{
        Name:name,
        Length:&length,
        Offset:&offset,
    }
}

// Converts a list of names into a list of Ds3GetObjects
func buildDs3GetObjectSliceFromNames(objectNames []string) []Ds3GetObject {
    // Build the ds3 get object list entity.
    var objects []Ds3GetObject
    for _, name := range objectNames {
        objects = append(objects, NewDs3GetObject(name))
    }
    return objects
}
type RequestType Enum

const (
    REQUEST_TYPE_DELETE RequestType = 1 + iota
    REQUEST_TYPE_GET RequestType = 1 + iota
    REQUEST_TYPE_HEAD RequestType = 1 + iota
    REQUEST_TYPE_POST RequestType = 1 + iota
    REQUEST_TYPE_PUT RequestType = 1 + iota
)

func (requestType *RequestType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *requestType = UNDEFINED
        case "DELETE": *requestType = REQUEST_TYPE_DELETE
        case "GET": *requestType = REQUEST_TYPE_GET
        case "HEAD": *requestType = REQUEST_TYPE_HEAD
        case "POST": *requestType = REQUEST_TYPE_POST
        case "PUT": *requestType = REQUEST_TYPE_PUT
        default:
            *requestType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into RequestType", str))
    }
    return nil
}

func (requestType RequestType) String() string {
    switch requestType {
        case REQUEST_TYPE_DELETE: return "DELETE"
        case REQUEST_TYPE_GET: return "GET"
        case REQUEST_TYPE_HEAD: return "HEAD"
        case REQUEST_TYPE_POST: return "POST"
        case REQUEST_TYPE_PUT: return "PUT"
        default:
            log.Printf("Error: invalid RequestType represented by '%d'", requestType)
            return ""
    }
}

func (requestType RequestType) StringPtr() *string {
    if requestType == UNDEFINED {
        return nil
    }
    result := requestType.String()
    return &result
}
type ResetInstanceIdentifierSpectraS3Request struct {
}

func NewResetInstanceIdentifierSpectraS3Request() *ResetInstanceIdentifierSpectraS3Request {
    return &ResetInstanceIdentifierSpectraS3Request{
    }
}

type ResetInstanceIdentifierSpectraS3Response struct {
    DataPathBackend DataPathBackend
    Headers *http.Header
}

func (resetInstanceIdentifierSpectraS3Response *ResetInstanceIdentifierSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &resetInstanceIdentifierSpectraS3Response.DataPathBackend)
}

func NewResetInstanceIdentifierSpectraS3Response(webResponse WebResponse) (*ResetInstanceIdentifierSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body ResetInstanceIdentifierSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type modelParser interface {
    parse(node *XmlNode, aggErr *AggregateError)
}

// Parses a response payload into the specified model parser. A best effort parsing
// is performed, and all errors that occur during parsing are captured within an aggregate error.
func parseResponsePayload(webResponse WebResponse, parsedBody modelParser) error {
    // Clean up the response body.
    body := webResponse.Body()
    defer body.Close()

    // Create the xml tree
    root, err := parseXmlTree(body)
    if err != nil {
        return err
    }

    // Parse the response
    var aggErr AggregateError
    parsedBody.parse(root, &aggErr)
    return aggErr.GetErrors()
}

// Converts the contents of the reader into an xml node tree
func parseXmlTree(reader io.ReadCloser) (*XmlNode, error) {

    var xmlNode XmlNode
    dec := xml.NewDecoder(reader)
    xmlTreeErr := dec.Decode(&xmlNode)
    if xmlTreeErr != nil {
        return nil, xmlTreeErr
    }

    return &xmlNode, nil
}

func getResponseBodyAsString(webResponse WebResponse) (string, error) {
    // Clean up the response body.
    body := webResponse.Body()
    defer body.Close()

    // Get the bytes or forward the error
    bytes, err := ioutil.ReadAll(body)
    if err != nil {
        return "", err
    }

    // Convert the bytes into a string
    return string(bytes), nil
}
type Ds3Enum interface {
    UnmarshalText(text []byte) error
}

// Parses a byte slice into an enum value. Assumes that a valid enum value is
// contained within the byte slice.
// Used in response payload parsing to convert xml node content into expected types.
func parseEnum(content []byte, param Ds3Enum, aggErr *AggregateError) {
    err := param.UnmarshalText(content)
    if err != nil {
        aggErr.Append(err)
    }
}

// Parses a byte slice into an enum value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableEnum(content []byte, param Ds3Enum, aggErr *AggregateError) {
    if len(content) > 0 {
        parseEnum(content, param, aggErr)
    }
}

// Converts a byte slice into a string value.
// Used in response payload parsing to convert xml node content into expected types.
func parseString(content []byte) string {
    return string(content)
}

// Converts a byte slice into a string value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableString(content []byte) *string {
    if len(content) == 0 {
        return nil
    }
    result := parseString(content)
    return &result
}

// Converts a byte slice into an int value. Assumes that a valid int value is
// contained within the byte slice.
// Used in response payload parsing to convert xml node content into expected types.
func parseInt(content []byte, aggErr *AggregateError) int {
    result, err :=  strconv.Atoi(string(content))
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Converts a byte slice into an int value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableInt(content []byte, aggErr *AggregateError) *int {
    if len(content) == 0 {
        return nil
    }
    result := parseInt(content, aggErr)
    return &result
}

// Converts a byte slice into an int64 value. Assumes that a valid int64 value is
// contained within the byte slice.
// Used in response payload parsing to convert xml node content into expected types.
func parseInt64(content []byte, aggErr *AggregateError) int64 {
    result, err := strconv.ParseInt(string(content), 10, 64)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Converts a byte slice into an int64 value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableInt64(content []byte, aggErr *AggregateError) *int64 {
    if len(content) == 0 {
        return nil
    }
    result := parseInt64(content, aggErr)
    return &result
}

// Converts a byte slice into an float64 value. Assumes that a valid float64 value is
// contained within the byte slice.
// Used in response payload parsing to convert xml node content into expected types.
func parseFloat64(content []byte, aggErr *AggregateError) float64 {
    result, err := strconv.ParseFloat(string(content), 64)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Converts a byte slice into an float64 value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableFloat64(content []byte, aggErr *AggregateError) *float64 {
    if len(content) == 0 {
        return nil
    }
    result := parseFloat64(content, aggErr)
    return &result
}

// Converts a byte slice into a boolean value. Assumes that a valid boolean value is
// contained within the byte slice.
// Used in response payload parsing to convert xml node content into expected types.
func parseBool(content []byte, aggErr *AggregateError) bool {
    result, err := strconv.ParseBool(string(content))
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Converts a byte slice into a boolean value. An empty slice is converted into a nil value.
// Used in response payload parsing to convert xml node content into expected types.
func parseNullableBool(content []byte, aggErr *AggregateError) *bool {
    if len(content) == 0 {
        return nil
    }
    result := parseBool(content, aggErr)
    return &result
}

// Parses an enum value from a string and expects a valid value to exist.
// Used for parsing response payload attributes into expected types.
func parseEnumFromString(content string, param Ds3Enum, aggErr *AggregateError) {
    err := param.UnmarshalText([]byte(content))
    if err != nil {
        aggErr.Append(err)
    }
}

// Parse nullable enum from string, where empty content represents a nil enum result.
// Used for parsing response payload attributes into expected types.
func parseNullableEnumFromString(content string, param Ds3Enum, aggErr *AggregateError) {
    if len(content) > 0 {
        parseEnumFromString(content, param, aggErr)
    }
}

// Parses a nullable string, where empty content represents a nil string result.
// Used for parsing response payload attributes into expected types.
func parseNullableStringFromString(content string) *string {
    if len(content) == 0 {
        return nil
    }
    result := content
    return &result
}

// Parses an int value from a string and expects a value to exist.
// Used for parsing response payload attributes into expected types.
func parseIntFromString(content string, aggErr *AggregateError) int {
    result, err :=  strconv.Atoi(content)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Parses a nullable int from string, where empty content represents a nil int result.
// Used for parsing response payload attributes into expected types.
func parseNullableIntFromString(content string, aggErr *AggregateError) *int {
    if len(content) == 0 {
        return nil
    }
    result := parseIntFromString(content, aggErr)
    return &result
}

// Parses an int64 value from a string and expects a value to exist.
// Used for parsing response payload attributes into expected types.
func parseInt64FromString(content string, aggErr *AggregateError) int64 {
    result, err := strconv.ParseInt(content, 10, 64)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Parses a nullable int64 from string, where an empty string represents a nil int64 result.
// Used for parsing response payload attributes into expected types.
func parseNullableInt64FromString(content string, aggErr *AggregateError) *int64 {
    if len(content) == 0 {
        return nil
    }
    result := parseInt64FromString(content, aggErr)
    return &result
}

// Parses an float64 value from a string and expects a value to exist.
// Used for parsing response payload attributes into expected types.
func parseFloat64FromString(content string, aggErr *AggregateError) float64 {
    result, err := strconv.ParseFloat(content, 64)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Parses a nullable float64 from string, where an empty string represents a nil float64 result.
// Used for parsing response payload attributes into expected types.
func parseNullableFloat64FromString(content string, aggErr *AggregateError) *float64 {
    if len(content) == 0 {
        return nil
    }
    result := parseFloat64FromString(content, aggErr)
    return &result
}

// Parses a boolean value from a string and expects a valid boolean value to exist.
// Used for parsing response payload attributes into expected types.
func parseBoolFromString(content string, aggErr *AggregateError) bool {
    result, err := strconv.ParseBool(content)
    if err != nil {
        aggErr.Append(err)
    }
    return result
}

// Parses a nullable boolean value from a string, where an empty string represents a nil boolean result.
// Used for parsing response payload attributes into expected types.
func parseNullableBoolFromString(content string, aggErr *AggregateError) *bool {
    if len(content) == 0 {
        return nil
    }
    result := parseBoolFromString(content, aggErr)
    return &result
}

func parseStringSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []string {
    var result []string
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult string = string(curXmlNode.Content)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing string slice.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type RestOperationType Enum

const (
    REST_OPERATION_TYPE_ALLOCATE RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CANCEL_EJECT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CANCEL_FORMAT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CANCEL_IMPORT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CANCEL_ONLINE RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CANCEL_VERIFY RestOperationType = 1 + iota
    REST_OPERATION_TYPE_CLEAN RestOperationType = 1 + iota
    REST_OPERATION_TYPE_COMPACT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_DEALLOCATE RestOperationType = 1 + iota
    REST_OPERATION_TYPE_EJECT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_FORMAT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_GET_PHYSICAL_PLACEMENT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_IMPORT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_INSPECT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_ONLINE RestOperationType = 1 + iota
    REST_OPERATION_TYPE_PAIR_BACK RestOperationType = 1 + iota
    REST_OPERATION_TYPE_REGENERATE_SECRET_KEY RestOperationType = 1 + iota
    REST_OPERATION_TYPE_START_BULK_GET RestOperationType = 1 + iota
    REST_OPERATION_TYPE_START_BULK_PUT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_START_BULK_VERIFY RestOperationType = 1 + iota
    REST_OPERATION_TYPE_VERIFY RestOperationType = 1 + iota
    REST_OPERATION_TYPE_VERIFY_SAFE_TO_START_BULK_PUT RestOperationType = 1 + iota
    REST_OPERATION_TYPE_VERIFY_PHYSICAL_PLACEMENT RestOperationType = 1 + iota
)

func (restOperationType *RestOperationType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *restOperationType = UNDEFINED
        case "ALLOCATE": *restOperationType = REST_OPERATION_TYPE_ALLOCATE
        case "CANCEL_EJECT": *restOperationType = REST_OPERATION_TYPE_CANCEL_EJECT
        case "CANCEL_FORMAT": *restOperationType = REST_OPERATION_TYPE_CANCEL_FORMAT
        case "CANCEL_IMPORT": *restOperationType = REST_OPERATION_TYPE_CANCEL_IMPORT
        case "CANCEL_ONLINE": *restOperationType = REST_OPERATION_TYPE_CANCEL_ONLINE
        case "CANCEL_VERIFY": *restOperationType = REST_OPERATION_TYPE_CANCEL_VERIFY
        case "CLEAN": *restOperationType = REST_OPERATION_TYPE_CLEAN
        case "COMPACT": *restOperationType = REST_OPERATION_TYPE_COMPACT
        case "DEALLOCATE": *restOperationType = REST_OPERATION_TYPE_DEALLOCATE
        case "EJECT": *restOperationType = REST_OPERATION_TYPE_EJECT
        case "FORMAT": *restOperationType = REST_OPERATION_TYPE_FORMAT
        case "GET_PHYSICAL_PLACEMENT": *restOperationType = REST_OPERATION_TYPE_GET_PHYSICAL_PLACEMENT
        case "IMPORT": *restOperationType = REST_OPERATION_TYPE_IMPORT
        case "INSPECT": *restOperationType = REST_OPERATION_TYPE_INSPECT
        case "ONLINE": *restOperationType = REST_OPERATION_TYPE_ONLINE
        case "PAIR_BACK": *restOperationType = REST_OPERATION_TYPE_PAIR_BACK
        case "REGENERATE_SECRET_KEY": *restOperationType = REST_OPERATION_TYPE_REGENERATE_SECRET_KEY
        case "START_BULK_GET": *restOperationType = REST_OPERATION_TYPE_START_BULK_GET
        case "START_BULK_PUT": *restOperationType = REST_OPERATION_TYPE_START_BULK_PUT
        case "START_BULK_VERIFY": *restOperationType = REST_OPERATION_TYPE_START_BULK_VERIFY
        case "VERIFY": *restOperationType = REST_OPERATION_TYPE_VERIFY
        case "VERIFY_SAFE_TO_START_BULK_PUT": *restOperationType = REST_OPERATION_TYPE_VERIFY_SAFE_TO_START_BULK_PUT
        case "VERIFY_PHYSICAL_PLACEMENT": *restOperationType = REST_OPERATION_TYPE_VERIFY_PHYSICAL_PLACEMENT
        default:
            *restOperationType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into RestOperationType", str))
    }
    return nil
}

func (restOperationType RestOperationType) String() string {
    switch restOperationType {
        case REST_OPERATION_TYPE_ALLOCATE: return "ALLOCATE"
        case REST_OPERATION_TYPE_CANCEL_EJECT: return "CANCEL_EJECT"
        case REST_OPERATION_TYPE_CANCEL_FORMAT: return "CANCEL_FORMAT"
        case REST_OPERATION_TYPE_CANCEL_IMPORT: return "CANCEL_IMPORT"
        case REST_OPERATION_TYPE_CANCEL_ONLINE: return "CANCEL_ONLINE"
        case REST_OPERATION_TYPE_CANCEL_VERIFY: return "CANCEL_VERIFY"
        case REST_OPERATION_TYPE_CLEAN: return "CLEAN"
        case REST_OPERATION_TYPE_COMPACT: return "COMPACT"
        case REST_OPERATION_TYPE_DEALLOCATE: return "DEALLOCATE"
        case REST_OPERATION_TYPE_EJECT: return "EJECT"
        case REST_OPERATION_TYPE_FORMAT: return "FORMAT"
        case REST_OPERATION_TYPE_GET_PHYSICAL_PLACEMENT: return "GET_PHYSICAL_PLACEMENT"
        case REST_OPERATION_TYPE_IMPORT: return "IMPORT"
        case REST_OPERATION_TYPE_INSPECT: return "INSPECT"
        case REST_OPERATION_TYPE_ONLINE: return "ONLINE"
        case REST_OPERATION_TYPE_PAIR_BACK: return "PAIR_BACK"
        case REST_OPERATION_TYPE_REGENERATE_SECRET_KEY: return "REGENERATE_SECRET_KEY"
        case REST_OPERATION_TYPE_START_BULK_GET: return "START_BULK_GET"
        case REST_OPERATION_TYPE_START_BULK_PUT: return "START_BULK_PUT"
        case REST_OPERATION_TYPE_START_BULK_VERIFY: return "START_BULK_VERIFY"
        case REST_OPERATION_TYPE_VERIFY: return "VERIFY"
        case REST_OPERATION_TYPE_VERIFY_SAFE_TO_START_BULK_PUT: return "VERIFY_SAFE_TO_START_BULK_PUT"
        case REST_OPERATION_TYPE_VERIFY_PHYSICAL_PLACEMENT: return "VERIFY_PHYSICAL_PLACEMENT"
        default:
            log.Printf("Error: invalid RestOperationType represented by '%d'", restOperationType)
            return ""
    }
}

func (restOperationType RestOperationType) StringPtr() *string {
    if restOperationType == UNDEFINED {
        return nil
    }
    result := restOperationType.String()
    return &result
}
type S3DataReplicationRule struct {
    DataPolicyId string
    Id string
    InitialDataPlacement S3InitialDataPlacementPolicy
    MaxBlobPartSizeInBytes int64
    ReplicateDeletes bool
    State DataPlacementRuleState
    TargetId string
    Type DataReplicationRuleType
}
type S3DataReplicationRuleList struct {
    S3DataReplicationRules []S3DataReplicationRule
}
func (s3DataReplicationRuleList *S3DataReplicationRuleList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3DataReplicationRule":
            var model S3DataReplicationRule
            model.parse(&child, aggErr)
            s3DataReplicationRuleList.S3DataReplicationRules = append(s3DataReplicationRuleList.S3DataReplicationRules, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3DataReplicationRuleList.", child.XMLName.Local)
        }
    }
}
func (s3DataReplicationRule *S3DataReplicationRule) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DataPolicyId":
            s3DataReplicationRule.DataPolicyId = parseString(child.Content)
        case "Id":
            s3DataReplicationRule.Id = parseString(child.Content)
        case "InitialDataPlacement":
            parseEnum(child.Content, &s3DataReplicationRule.InitialDataPlacement, aggErr)
        case "MaxBlobPartSizeInBytes":
            s3DataReplicationRule.MaxBlobPartSizeInBytes = parseInt64(child.Content, aggErr)
        case "ReplicateDeletes":
            s3DataReplicationRule.ReplicateDeletes = parseBool(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &s3DataReplicationRule.State, aggErr)
        case "TargetId":
            s3DataReplicationRule.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &s3DataReplicationRule.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3DataReplicationRule.", child.XMLName.Local)
        }
    }
}
type S3InitialDataPlacementPolicy Enum

const (
    S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD S3InitialDataPlacementPolicy = 1 + iota
    S3_INITIAL_DATA_PLACEMENT_POLICY_REDUCED_REDUNDANCY S3InitialDataPlacementPolicy = 1 + iota
    S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD_IA S3InitialDataPlacementPolicy = 1 + iota
    S3_INITIAL_DATA_PLACEMENT_POLICY_GLACIER S3InitialDataPlacementPolicy = 1 + iota
)

func (s3InitialDataPlacementPolicy *S3InitialDataPlacementPolicy) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *s3InitialDataPlacementPolicy = UNDEFINED
        case "STANDARD": *s3InitialDataPlacementPolicy = S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD
        case "REDUCED_REDUNDANCY": *s3InitialDataPlacementPolicy = S3_INITIAL_DATA_PLACEMENT_POLICY_REDUCED_REDUNDANCY
        case "STANDARD_IA": *s3InitialDataPlacementPolicy = S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD_IA
        case "GLACIER": *s3InitialDataPlacementPolicy = S3_INITIAL_DATA_PLACEMENT_POLICY_GLACIER
        default:
            *s3InitialDataPlacementPolicy = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into S3InitialDataPlacementPolicy", str))
    }
    return nil
}

func (s3InitialDataPlacementPolicy S3InitialDataPlacementPolicy) String() string {
    switch s3InitialDataPlacementPolicy {
        case S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD: return "STANDARD"
        case S3_INITIAL_DATA_PLACEMENT_POLICY_REDUCED_REDUNDANCY: return "REDUCED_REDUNDANCY"
        case S3_INITIAL_DATA_PLACEMENT_POLICY_STANDARD_IA: return "STANDARD_IA"
        case S3_INITIAL_DATA_PLACEMENT_POLICY_GLACIER: return "GLACIER"
        default:
            log.Printf("Error: invalid S3InitialDataPlacementPolicy represented by '%d'", s3InitialDataPlacementPolicy)
            return ""
    }
}

func (s3InitialDataPlacementPolicy S3InitialDataPlacementPolicy) StringPtr() *string {
    if s3InitialDataPlacementPolicy == UNDEFINED {
        return nil
    }
    result := s3InitialDataPlacementPolicy.String()
    return &result
}
type S3Object struct {
    BucketId string
    CreationDate *string
    Id string
    Latest bool
    Name *string
    Type S3ObjectType
    Version int64
}
type S3ObjectCachedNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    JobId *string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type S3ObjectCachedNotificationRegistrationList struct {
    S3ObjectCachedNotificationRegistrations []S3ObjectCachedNotificationRegistration
}
func (s3ObjectCachedNotificationRegistrationList *S3ObjectCachedNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3ObjectCachedNotificationRegistration":
            var model S3ObjectCachedNotificationRegistration
            model.parse(&child, aggErr)
            s3ObjectCachedNotificationRegistrationList.S3ObjectCachedNotificationRegistrations = append(s3ObjectCachedNotificationRegistrationList.S3ObjectCachedNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectCachedNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (s3ObjectCachedNotificationRegistration *S3ObjectCachedNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            s3ObjectCachedNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &s3ObjectCachedNotificationRegistration.Format, aggErr)
        case "Id":
            s3ObjectCachedNotificationRegistration.Id = parseString(child.Content)
        case "JobId":
            s3ObjectCachedNotificationRegistration.JobId = parseNullableString(child.Content)
        case "LastFailure":
            s3ObjectCachedNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            s3ObjectCachedNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            s3ObjectCachedNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &s3ObjectCachedNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            s3ObjectCachedNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &s3ObjectCachedNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            s3ObjectCachedNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            s3ObjectCachedNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectCachedNotificationRegistration.", child.XMLName.Local)
        }
    }
}
type S3ObjectList struct {
    S3Objects []S3Object
}
func (s3ObjectList *S3ObjectList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3Object":
            var model S3Object
            model.parse(&child, aggErr)
            s3ObjectList.S3Objects = append(s3ObjectList.S3Objects, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectList.", child.XMLName.Local)
        }
    }
}
type S3ObjectLostNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type S3ObjectLostNotificationRegistrationList struct {
    S3ObjectLostNotificationRegistrations []S3ObjectLostNotificationRegistration
}
func (s3ObjectLostNotificationRegistrationList *S3ObjectLostNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3ObjectLostNotificationRegistration":
            var model S3ObjectLostNotificationRegistration
            model.parse(&child, aggErr)
            s3ObjectLostNotificationRegistrationList.S3ObjectLostNotificationRegistrations = append(s3ObjectLostNotificationRegistrationList.S3ObjectLostNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectLostNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (s3ObjectLostNotificationRegistration *S3ObjectLostNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            s3ObjectLostNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &s3ObjectLostNotificationRegistration.Format, aggErr)
        case "Id":
            s3ObjectLostNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            s3ObjectLostNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            s3ObjectLostNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            s3ObjectLostNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &s3ObjectLostNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            s3ObjectLostNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &s3ObjectLostNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            s3ObjectLostNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            s3ObjectLostNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectLostNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (s3Object *S3Object) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            s3Object.BucketId = parseString(child.Content)
        case "CreationDate":
            s3Object.CreationDate = parseNullableString(child.Content)
        case "Id":
            s3Object.Id = parseString(child.Content)
        case "Latest":
            s3Object.Latest = parseBool(child.Content, aggErr)
        case "Name":
            s3Object.Name = parseNullableString(child.Content)
        case "Type":
            parseEnum(child.Content, &s3Object.Type, aggErr)
        case "Version":
            s3Object.Version = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3Object.", child.XMLName.Local)
        }
    }
}
type S3ObjectPersistedNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    JobId *string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type S3ObjectPersistedNotificationRegistrationList struct {
    S3ObjectPersistedNotificationRegistrations []S3ObjectPersistedNotificationRegistration
}
func (s3ObjectPersistedNotificationRegistrationList *S3ObjectPersistedNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3ObjectPersistedNotificationRegistration":
            var model S3ObjectPersistedNotificationRegistration
            model.parse(&child, aggErr)
            s3ObjectPersistedNotificationRegistrationList.S3ObjectPersistedNotificationRegistrations = append(s3ObjectPersistedNotificationRegistrationList.S3ObjectPersistedNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectPersistedNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (s3ObjectPersistedNotificationRegistration *S3ObjectPersistedNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            s3ObjectPersistedNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &s3ObjectPersistedNotificationRegistration.Format, aggErr)
        case "Id":
            s3ObjectPersistedNotificationRegistration.Id = parseString(child.Content)
        case "JobId":
            s3ObjectPersistedNotificationRegistration.JobId = parseNullableString(child.Content)
        case "LastFailure":
            s3ObjectPersistedNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            s3ObjectPersistedNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            s3ObjectPersistedNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &s3ObjectPersistedNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            s3ObjectPersistedNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &s3ObjectPersistedNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            s3ObjectPersistedNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            s3ObjectPersistedNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectPersistedNotificationRegistration.", child.XMLName.Local)
        }
    }
}
type S3ObjectToDelete struct {
    Key *string
}
func (s3ObjectToDelete *S3ObjectToDelete) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Key":
            s3ObjectToDelete.Key = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3ObjectToDelete.", child.XMLName.Local)
        }
    }
}
type S3ObjectType Enum

const (
    S3_OBJECT_TYPE_DATA S3ObjectType = 1 + iota
    S3_OBJECT_TYPE_FOLDER S3ObjectType = 1 + iota
)

func (s3ObjectType *S3ObjectType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *s3ObjectType = UNDEFINED
        case "DATA": *s3ObjectType = S3_OBJECT_TYPE_DATA
        case "FOLDER": *s3ObjectType = S3_OBJECT_TYPE_FOLDER
        default:
            *s3ObjectType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into S3ObjectType", str))
    }
    return nil
}

func (s3ObjectType S3ObjectType) String() string {
    switch s3ObjectType {
        case S3_OBJECT_TYPE_DATA: return "DATA"
        case S3_OBJECT_TYPE_FOLDER: return "FOLDER"
        default:
            log.Printf("Error: invalid S3ObjectType represented by '%d'", s3ObjectType)
            return ""
    }
}

func (s3ObjectType S3ObjectType) StringPtr() *string {
    if s3ObjectType == UNDEFINED {
        return nil
    }
    result := s3ObjectType.String()
    return &result
}
type S3Region Enum

const (
    S3_REGION_GOV_CLOUD S3Region = 1 + iota
    S3_REGION_US_EAST_1 S3Region = 1 + iota
    S3_REGION_US_WEST_1 S3Region = 1 + iota
    S3_REGION_US_WEST_2 S3Region = 1 + iota
    S3_REGION_EU_WEST_1 S3Region = 1 + iota
    S3_REGION_EU_CENTRAL_1 S3Region = 1 + iota
    S3_REGION_AP_SOUTH_1 S3Region = 1 + iota
    S3_REGION_AP_SOUTHEAST_1 S3Region = 1 + iota
    S3_REGION_AP_SOUTHEAST_2 S3Region = 1 + iota
    S3_REGION_AP_NORTHEAST_1 S3Region = 1 + iota
    S3_REGION_AP_NORTHEAST_2 S3Region = 1 + iota
    S3_REGION_SA_EAST_1 S3Region = 1 + iota
    S3_REGION_CN_NORTH_1 S3Region = 1 + iota
)

func (s3Region *S3Region) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *s3Region = UNDEFINED
        case "GOV_CLOUD": *s3Region = S3_REGION_GOV_CLOUD
        case "US_EAST_1": *s3Region = S3_REGION_US_EAST_1
        case "US_WEST_1": *s3Region = S3_REGION_US_WEST_1
        case "US_WEST_2": *s3Region = S3_REGION_US_WEST_2
        case "EU_WEST_1": *s3Region = S3_REGION_EU_WEST_1
        case "EU_CENTRAL_1": *s3Region = S3_REGION_EU_CENTRAL_1
        case "AP_SOUTH_1": *s3Region = S3_REGION_AP_SOUTH_1
        case "AP_SOUTHEAST_1": *s3Region = S3_REGION_AP_SOUTHEAST_1
        case "AP_SOUTHEAST_2": *s3Region = S3_REGION_AP_SOUTHEAST_2
        case "AP_NORTHEAST_1": *s3Region = S3_REGION_AP_NORTHEAST_1
        case "AP_NORTHEAST_2": *s3Region = S3_REGION_AP_NORTHEAST_2
        case "SA_EAST_1": *s3Region = S3_REGION_SA_EAST_1
        case "CN_NORTH_1": *s3Region = S3_REGION_CN_NORTH_1
        default:
            *s3Region = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into S3Region", str))
    }
    return nil
}

func (s3Region S3Region) String() string {
    switch s3Region {
        case S3_REGION_GOV_CLOUD: return "GOV_CLOUD"
        case S3_REGION_US_EAST_1: return "US_EAST_1"
        case S3_REGION_US_WEST_1: return "US_WEST_1"
        case S3_REGION_US_WEST_2: return "US_WEST_2"
        case S3_REGION_EU_WEST_1: return "EU_WEST_1"
        case S3_REGION_EU_CENTRAL_1: return "EU_CENTRAL_1"
        case S3_REGION_AP_SOUTH_1: return "AP_SOUTH_1"
        case S3_REGION_AP_SOUTHEAST_1: return "AP_SOUTHEAST_1"
        case S3_REGION_AP_SOUTHEAST_2: return "AP_SOUTHEAST_2"
        case S3_REGION_AP_NORTHEAST_1: return "AP_NORTHEAST_1"
        case S3_REGION_AP_NORTHEAST_2: return "AP_NORTHEAST_2"
        case S3_REGION_SA_EAST_1: return "SA_EAST_1"
        case S3_REGION_CN_NORTH_1: return "CN_NORTH_1"
        default:
            log.Printf("Error: invalid S3Region represented by '%d'", s3Region)
            return ""
    }
}

func (s3Region S3Region) StringPtr() *string {
    if s3Region == UNDEFINED {
        return nil
    }
    result := s3Region.String()
    return &result
}
type S3Target struct {
    AccessKey *string
    AutoVerifyFrequencyInDays *int
    CloudBucketPrefix *string
    CloudBucketSuffix *string
    DataPathEndPoint *string
    DefaultReadPreference TargetReadPreferenceType
    Https bool
    Id string
    LastFullyVerified *string
    Name *string
    OfflineDataStagingWindowInTb int
    PermitGoingOutOfSync bool
    ProxyDomain *string
    ProxyHost *string
    ProxyPassword *string
    ProxyPort *int
    ProxyUsername *string
    Quiesced Quiesced
    Region S3Region
    SecretKey *string
    StagedDataExpirationInDays int
    State TargetState
}
type S3TargetBucketName struct {
    BucketId string
    Id string
    Name *string
    TargetId string
}
type S3TargetBucketNameList struct {
    S3TargetBucketNames []S3TargetBucketName
}
func (s3TargetBucketNameList *S3TargetBucketNameList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3TargetBucketName":
            var model S3TargetBucketName
            model.parse(&child, aggErr)
            s3TargetBucketNameList.S3TargetBucketNames = append(s3TargetBucketNameList.S3TargetBucketNames, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetBucketNameList.", child.XMLName.Local)
        }
    }
}
func (s3TargetBucketName *S3TargetBucketName) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            s3TargetBucketName.BucketId = parseString(child.Content)
        case "Id":
            s3TargetBucketName.Id = parseString(child.Content)
        case "Name":
            s3TargetBucketName.Name = parseNullableString(child.Content)
        case "TargetId":
            s3TargetBucketName.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetBucketName.", child.XMLName.Local)
        }
    }
}
type S3TargetFailure struct {
    Date string
    ErrorMessage *string
    Id string
    TargetId string
    Type TargetFailureType
}
type S3TargetFailureList struct {
    S3TargetFailures []S3TargetFailure
}
func (s3TargetFailureList *S3TargetFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3TargetFailure":
            var model S3TargetFailure
            model.parse(&child, aggErr)
            s3TargetFailureList.S3TargetFailures = append(s3TargetFailureList.S3TargetFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetFailureList.", child.XMLName.Local)
        }
    }
}
type S3TargetFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type S3TargetFailureNotificationRegistrationList struct {
    S3TargetFailureNotificationRegistrations []S3TargetFailureNotificationRegistration
}
func (s3TargetFailureNotificationRegistrationList *S3TargetFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3TargetFailureNotificationRegistration":
            var model S3TargetFailureNotificationRegistration
            model.parse(&child, aggErr)
            s3TargetFailureNotificationRegistrationList.S3TargetFailureNotificationRegistrations = append(s3TargetFailureNotificationRegistrationList.S3TargetFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (s3TargetFailureNotificationRegistration *S3TargetFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            s3TargetFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &s3TargetFailureNotificationRegistration.Format, aggErr)
        case "Id":
            s3TargetFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            s3TargetFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            s3TargetFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            s3TargetFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &s3TargetFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            s3TargetFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &s3TargetFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            s3TargetFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            s3TargetFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (s3TargetFailure *S3TargetFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            s3TargetFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            s3TargetFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            s3TargetFailure.Id = parseString(child.Content)
        case "TargetId":
            s3TargetFailure.TargetId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &s3TargetFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetFailure.", child.XMLName.Local)
        }
    }
}
type S3TargetList struct {
    S3Targets []S3Target
}
func (s3TargetList *S3TargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3Target":
            var model S3Target
            model.parse(&child, aggErr)
            s3TargetList.S3Targets = append(s3TargetList.S3Targets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetList.", child.XMLName.Local)
        }
    }
}
func (s3Target *S3Target) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AccessKey":
            s3Target.AccessKey = parseNullableString(child.Content)
        case "AutoVerifyFrequencyInDays":
            s3Target.AutoVerifyFrequencyInDays = parseNullableInt(child.Content, aggErr)
        case "CloudBucketPrefix":
            s3Target.CloudBucketPrefix = parseNullableString(child.Content)
        case "CloudBucketSuffix":
            s3Target.CloudBucketSuffix = parseNullableString(child.Content)
        case "DataPathEndPoint":
            s3Target.DataPathEndPoint = parseNullableString(child.Content)
        case "DefaultReadPreference":
            parseEnum(child.Content, &s3Target.DefaultReadPreference, aggErr)
        case "Https":
            s3Target.Https = parseBool(child.Content, aggErr)
        case "Id":
            s3Target.Id = parseString(child.Content)
        case "LastFullyVerified":
            s3Target.LastFullyVerified = parseNullableString(child.Content)
        case "Name":
            s3Target.Name = parseNullableString(child.Content)
        case "OfflineDataStagingWindowInTb":
            s3Target.OfflineDataStagingWindowInTb = parseInt(child.Content, aggErr)
        case "PermitGoingOutOfSync":
            s3Target.PermitGoingOutOfSync = parseBool(child.Content, aggErr)
        case "ProxyDomain":
            s3Target.ProxyDomain = parseNullableString(child.Content)
        case "ProxyHost":
            s3Target.ProxyHost = parseNullableString(child.Content)
        case "ProxyPassword":
            s3Target.ProxyPassword = parseNullableString(child.Content)
        case "ProxyPort":
            s3Target.ProxyPort = parseNullableInt(child.Content, aggErr)
        case "ProxyUsername":
            s3Target.ProxyUsername = parseNullableString(child.Content)
        case "Quiesced":
            parseEnum(child.Content, &s3Target.Quiesced, aggErr)
        case "Region":
            parseEnum(child.Content, &s3Target.Region, aggErr)
        case "SecretKey":
            s3Target.SecretKey = parseNullableString(child.Content)
        case "StagedDataExpirationInDays":
            s3Target.StagedDataExpirationInDays = parseInt(child.Content, aggErr)
        case "State":
            parseEnum(child.Content, &s3Target.State, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3Target.", child.XMLName.Local)
        }
    }
}

func parseS3TargetSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []S3Target {
    var result []S3Target
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult S3Target
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing S3Target struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type S3TargetReadPreference struct {
    BucketId string
    Id string
    ReadPreference TargetReadPreferenceType
    TargetId string
}
type S3TargetReadPreferenceList struct {
    S3TargetReadPreferences []S3TargetReadPreference
}
func (s3TargetReadPreferenceList *S3TargetReadPreferenceList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "S3TargetReadPreference":
            var model S3TargetReadPreference
            model.parse(&child, aggErr)
            s3TargetReadPreferenceList.S3TargetReadPreferences = append(s3TargetReadPreferenceList.S3TargetReadPreferences, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetReadPreferenceList.", child.XMLName.Local)
        }
    }
}
func (s3TargetReadPreference *S3TargetReadPreference) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BucketId":
            s3TargetReadPreference.BucketId = parseString(child.Content)
        case "Id":
            s3TargetReadPreference.Id = parseString(child.Content)
        case "ReadPreference":
            parseEnum(child.Content, &s3TargetReadPreference.ReadPreference, aggErr)
        case "TargetId":
            s3TargetReadPreference.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing S3TargetReadPreference.", child.XMLName.Local)
        }
    }
}
type SpectraUser struct {
    AuthId *string
    DefaultDataPolicyId *string
    Id string
    Name *string
    SecretKey *string
}
type SpectraUserList struct {
    SpectraUsers []SpectraUser
}
func (spectraUserList *SpectraUserList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "User":
            var model SpectraUser
            model.parse(&child, aggErr)
            spectraUserList.SpectraUsers = append(spectraUserList.SpectraUsers, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SpectraUserList.", child.XMLName.Local)
        }
    }
}
func (spectraUser *SpectraUser) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AuthId":
            spectraUser.AuthId = parseNullableString(child.Content)
        case "DefaultDataPolicyId":
            spectraUser.DefaultDataPolicyId = parseNullableString(child.Content)
        case "Id":
            spectraUser.Id = parseString(child.Content)
        case "Name":
            spectraUser.Name = parseNullableString(child.Content)
        case "SecretKey":
            spectraUser.SecretKey = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SpectraUser.", child.XMLName.Local)
        }
    }
}
type StorageDomain struct {
    AutoEjectMediaFullThreshold *int64
    AutoEjectUponCron *string
    AutoEjectUponJobCancellation bool
    AutoEjectUponJobCompletion bool
    AutoEjectUponMediaFull bool
    Id string
    LtfsFileNaming LtfsFileNamingMode
    MaxTapeFragmentationPercent int
    MaximumAutoVerificationFrequencyInDays *int
    MediaEjectionAllowed bool
    Name *string
    SecureMediaAllocation bool
    VerifyPriorToAutoEject *Priority
    WriteOptimization WriteOptimization
}
type StorageDomainCapacitySummary struct {
    PhysicalAllocated int64
    PhysicalFree int64
    PhysicalUsed int64
}
func (storageDomainCapacitySummary *StorageDomainCapacitySummary) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "PhysicalAllocated":
            storageDomainCapacitySummary.PhysicalAllocated = parseInt64(child.Content, aggErr)
        case "PhysicalFree":
            storageDomainCapacitySummary.PhysicalFree = parseInt64(child.Content, aggErr)
        case "PhysicalUsed":
            storageDomainCapacitySummary.PhysicalUsed = parseInt64(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainCapacitySummary.", child.XMLName.Local)
        }
    }
}
type StorageDomainFailure struct {
    Date string
    ErrorMessage *string
    Id string
    StorageDomainId string
    Type StorageDomainFailureType
}
type StorageDomainFailureList struct {
    StorageDomainFailures []StorageDomainFailure
}
func (storageDomainFailureList *StorageDomainFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "StorageDomainFailure":
            var model StorageDomainFailure
            model.parse(&child, aggErr)
            storageDomainFailureList.StorageDomainFailures = append(storageDomainFailureList.StorageDomainFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainFailureList.", child.XMLName.Local)
        }
    }
}
type StorageDomainFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type StorageDomainFailureNotificationRegistrationList struct {
    StorageDomainFailureNotificationRegistrations []StorageDomainFailureNotificationRegistration
}
func (storageDomainFailureNotificationRegistrationList *StorageDomainFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "StorageDomainFailureNotificationRegistration":
            var model StorageDomainFailureNotificationRegistration
            model.parse(&child, aggErr)
            storageDomainFailureNotificationRegistrationList.StorageDomainFailureNotificationRegistrations = append(storageDomainFailureNotificationRegistrationList.StorageDomainFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (storageDomainFailureNotificationRegistration *StorageDomainFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            storageDomainFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &storageDomainFailureNotificationRegistration.Format, aggErr)
        case "Id":
            storageDomainFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            storageDomainFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            storageDomainFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            storageDomainFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &storageDomainFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            storageDomainFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &storageDomainFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            storageDomainFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            storageDomainFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (storageDomainFailure *StorageDomainFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            storageDomainFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            storageDomainFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            storageDomainFailure.Id = parseString(child.Content)
        case "StorageDomainId":
            storageDomainFailure.StorageDomainId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &storageDomainFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainFailure.", child.XMLName.Local)
        }
    }
}
type StorageDomainFailureType Enum

const (
    STORAGE_DOMAIN_FAILURE_TYPE_ILLEGAL_EJECTION_OCCURRED StorageDomainFailureType = 1 + iota
    STORAGE_DOMAIN_FAILURE_TYPE_MEMBER_BECAME_READ_ONLY StorageDomainFailureType = 1 + iota
    STORAGE_DOMAIN_FAILURE_TYPE_WRITES_STALLED_DUE_TO_NO_FREE_MEDIA_REMAINING StorageDomainFailureType = 1 + iota
)

func (storageDomainFailureType *StorageDomainFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *storageDomainFailureType = UNDEFINED
        case "ILLEGAL_EJECTION_OCCURRED": *storageDomainFailureType = STORAGE_DOMAIN_FAILURE_TYPE_ILLEGAL_EJECTION_OCCURRED
        case "MEMBER_BECAME_READ_ONLY": *storageDomainFailureType = STORAGE_DOMAIN_FAILURE_TYPE_MEMBER_BECAME_READ_ONLY
        case "WRITES_STALLED_DUE_TO_NO_FREE_MEDIA_REMAINING": *storageDomainFailureType = STORAGE_DOMAIN_FAILURE_TYPE_WRITES_STALLED_DUE_TO_NO_FREE_MEDIA_REMAINING
        default:
            *storageDomainFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into StorageDomainFailureType", str))
    }
    return nil
}

func (storageDomainFailureType StorageDomainFailureType) String() string {
    switch storageDomainFailureType {
        case STORAGE_DOMAIN_FAILURE_TYPE_ILLEGAL_EJECTION_OCCURRED: return "ILLEGAL_EJECTION_OCCURRED"
        case STORAGE_DOMAIN_FAILURE_TYPE_MEMBER_BECAME_READ_ONLY: return "MEMBER_BECAME_READ_ONLY"
        case STORAGE_DOMAIN_FAILURE_TYPE_WRITES_STALLED_DUE_TO_NO_FREE_MEDIA_REMAINING: return "WRITES_STALLED_DUE_TO_NO_FREE_MEDIA_REMAINING"
        default:
            log.Printf("Error: invalid StorageDomainFailureType represented by '%d'", storageDomainFailureType)
            return ""
    }
}

func (storageDomainFailureType StorageDomainFailureType) StringPtr() *string {
    if storageDomainFailureType == UNDEFINED {
        return nil
    }
    result := storageDomainFailureType.String()
    return &result
}
type StorageDomainList struct {
    StorageDomains []StorageDomain
}
func (storageDomainList *StorageDomainList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "StorageDomain":
            var model StorageDomain
            model.parse(&child, aggErr)
            storageDomainList.StorageDomains = append(storageDomainList.StorageDomains, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainList.", child.XMLName.Local)
        }
    }
}
type StorageDomainMember struct {
    Id string
    PoolPartitionId *string
    State StorageDomainMemberState
    StorageDomainId string
    TapePartitionId *string
    TapeType *string
    WritePreference WritePreferenceLevel
}
type StorageDomainMemberList struct {
    StorageDomainMembers []StorageDomainMember
}
func (storageDomainMemberList *StorageDomainMemberList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "StorageDomainMember":
            var model StorageDomainMember
            model.parse(&child, aggErr)
            storageDomainMemberList.StorageDomainMembers = append(storageDomainMemberList.StorageDomainMembers, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainMemberList.", child.XMLName.Local)
        }
    }
}
func (storageDomainMember *StorageDomainMember) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Id":
            storageDomainMember.Id = parseString(child.Content)
        case "PoolPartitionId":
            storageDomainMember.PoolPartitionId = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &storageDomainMember.State, aggErr)
        case "StorageDomainId":
            storageDomainMember.StorageDomainId = parseString(child.Content)
        case "TapePartitionId":
            storageDomainMember.TapePartitionId = parseNullableString(child.Content)
        case "TapeType":
            storageDomainMember.TapeType = parseNullableString(child.Content)
        case "WritePreference":
            parseEnum(child.Content, &storageDomainMember.WritePreference, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomainMember.", child.XMLName.Local)
        }
    }
}
type StorageDomainMemberState Enum

const (
    STORAGE_DOMAIN_MEMBER_STATE_NORMAL StorageDomainMemberState = 1 + iota
    STORAGE_DOMAIN_MEMBER_STATE_EXCLUSION_IN_PROGRESS StorageDomainMemberState = 1 + iota
)

func (storageDomainMemberState *StorageDomainMemberState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *storageDomainMemberState = UNDEFINED
        case "NORMAL": *storageDomainMemberState = STORAGE_DOMAIN_MEMBER_STATE_NORMAL
        case "EXCLUSION_IN_PROGRESS": *storageDomainMemberState = STORAGE_DOMAIN_MEMBER_STATE_EXCLUSION_IN_PROGRESS
        default:
            *storageDomainMemberState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into StorageDomainMemberState", str))
    }
    return nil
}

func (storageDomainMemberState StorageDomainMemberState) String() string {
    switch storageDomainMemberState {
        case STORAGE_DOMAIN_MEMBER_STATE_NORMAL: return "NORMAL"
        case STORAGE_DOMAIN_MEMBER_STATE_EXCLUSION_IN_PROGRESS: return "EXCLUSION_IN_PROGRESS"
        default:
            log.Printf("Error: invalid StorageDomainMemberState represented by '%d'", storageDomainMemberState)
            return ""
    }
}

func (storageDomainMemberState StorageDomainMemberState) StringPtr() *string {
    if storageDomainMemberState == UNDEFINED {
        return nil
    }
    result := storageDomainMemberState.String()
    return &result
}
func (storageDomain *StorageDomain) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AutoEjectMediaFullThreshold":
            storageDomain.AutoEjectMediaFullThreshold = parseNullableInt64(child.Content, aggErr)
        case "AutoEjectUponCron":
            storageDomain.AutoEjectUponCron = parseNullableString(child.Content)
        case "AutoEjectUponJobCancellation":
            storageDomain.AutoEjectUponJobCancellation = parseBool(child.Content, aggErr)
        case "AutoEjectUponJobCompletion":
            storageDomain.AutoEjectUponJobCompletion = parseBool(child.Content, aggErr)
        case "AutoEjectUponMediaFull":
            storageDomain.AutoEjectUponMediaFull = parseBool(child.Content, aggErr)
        case "Id":
            storageDomain.Id = parseString(child.Content)
        case "LtfsFileNaming":
            parseEnum(child.Content, &storageDomain.LtfsFileNaming, aggErr)
        case "MaxTapeFragmentationPercent":
            storageDomain.MaxTapeFragmentationPercent = parseInt(child.Content, aggErr)
        case "MaximumAutoVerificationFrequencyInDays":
            storageDomain.MaximumAutoVerificationFrequencyInDays = parseNullableInt(child.Content, aggErr)
        case "MediaEjectionAllowed":
            storageDomain.MediaEjectionAllowed = parseBool(child.Content, aggErr)
        case "Name":
            storageDomain.Name = parseNullableString(child.Content)
        case "SecureMediaAllocation":
            storageDomain.SecureMediaAllocation = parseBool(child.Content, aggErr)
        case "VerifyPriorToAutoEject":
            parseNullableEnum(child.Content, storageDomain.VerifyPriorToAutoEject, aggErr)
        case "WriteOptimization":
            parseEnum(child.Content, &storageDomain.WriteOptimization, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing StorageDomain.", child.XMLName.Local)
        }
    }
}
type SuspectBlobAzureTarget struct {
    BlobId string
    Id string
    TargetId string
}
type SuspectBlobAzureTargetList struct {
    SuspectBlobAzureTargets []SuspectBlobAzureTarget
}
func (suspectBlobAzureTargetList *SuspectBlobAzureTargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SuspectBlobAzureTarget":
            var model SuspectBlobAzureTarget
            model.parse(&child, aggErr)
            suspectBlobAzureTargetList.SuspectBlobAzureTargets = append(suspectBlobAzureTargetList.SuspectBlobAzureTargets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobAzureTargetList.", child.XMLName.Local)
        }
    }
}
func (suspectBlobAzureTarget *SuspectBlobAzureTarget) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobId":
            suspectBlobAzureTarget.BlobId = parseString(child.Content)
        case "Id":
            suspectBlobAzureTarget.Id = parseString(child.Content)
        case "TargetId":
            suspectBlobAzureTarget.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobAzureTarget.", child.XMLName.Local)
        }
    }
}
type SuspectBlobDs3Target struct {
    BlobId string
    Id string
    TargetId string
}
type SuspectBlobDs3TargetList struct {
    SuspectBlobDs3Targets []SuspectBlobDs3Target
}
func (suspectBlobDs3TargetList *SuspectBlobDs3TargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SuspectBlobDs3Target":
            var model SuspectBlobDs3Target
            model.parse(&child, aggErr)
            suspectBlobDs3TargetList.SuspectBlobDs3Targets = append(suspectBlobDs3TargetList.SuspectBlobDs3Targets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobDs3TargetList.", child.XMLName.Local)
        }
    }
}
func (suspectBlobDs3Target *SuspectBlobDs3Target) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobId":
            suspectBlobDs3Target.BlobId = parseString(child.Content)
        case "Id":
            suspectBlobDs3Target.Id = parseString(child.Content)
        case "TargetId":
            suspectBlobDs3Target.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobDs3Target.", child.XMLName.Local)
        }
    }
}
type SuspectBlobPool struct {
    BlobId string
    BucketId string
    DateWritten string
    Id string
    LastAccessed string
    PoolId string
}
type SuspectBlobPoolList struct {
    SuspectBlobPools []SuspectBlobPool
}
func (suspectBlobPoolList *SuspectBlobPoolList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SuspectBlobPool":
            var model SuspectBlobPool
            model.parse(&child, aggErr)
            suspectBlobPoolList.SuspectBlobPools = append(suspectBlobPoolList.SuspectBlobPools, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobPoolList.", child.XMLName.Local)
        }
    }
}
func (suspectBlobPool *SuspectBlobPool) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobId":
            suspectBlobPool.BlobId = parseString(child.Content)
        case "BucketId":
            suspectBlobPool.BucketId = parseString(child.Content)
        case "DateWritten":
            suspectBlobPool.DateWritten = parseString(child.Content)
        case "Id":
            suspectBlobPool.Id = parseString(child.Content)
        case "LastAccessed":
            suspectBlobPool.LastAccessed = parseString(child.Content)
        case "PoolId":
            suspectBlobPool.PoolId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobPool.", child.XMLName.Local)
        }
    }
}
type SuspectBlobS3Target struct {
    BlobId string
    Id string
    TargetId string
}
type SuspectBlobS3TargetList struct {
    SuspectBlobS3Targets []SuspectBlobS3Target
}
func (suspectBlobS3TargetList *SuspectBlobS3TargetList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SuspectBlobS3Target":
            var model SuspectBlobS3Target
            model.parse(&child, aggErr)
            suspectBlobS3TargetList.SuspectBlobS3Targets = append(suspectBlobS3TargetList.SuspectBlobS3Targets, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobS3TargetList.", child.XMLName.Local)
        }
    }
}
func (suspectBlobS3Target *SuspectBlobS3Target) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobId":
            suspectBlobS3Target.BlobId = parseString(child.Content)
        case "Id":
            suspectBlobS3Target.Id = parseString(child.Content)
        case "TargetId":
            suspectBlobS3Target.TargetId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobS3Target.", child.XMLName.Local)
        }
    }
}
type SuspectBlobTape struct {
    BlobId string
    Id string
    OrderIndex int
    TapeId string
}
type SuspectBlobTapeList struct {
    SuspectBlobTapes []SuspectBlobTape
}
func (suspectBlobTapeList *SuspectBlobTapeList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SuspectBlobTape":
            var model SuspectBlobTape
            model.parse(&child, aggErr)
            suspectBlobTapeList.SuspectBlobTapes = append(suspectBlobTapeList.SuspectBlobTapes, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobTapeList.", child.XMLName.Local)
        }
    }
}
func (suspectBlobTape *SuspectBlobTape) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "BlobId":
            suspectBlobTape.BlobId = parseString(child.Content)
        case "Id":
            suspectBlobTape.Id = parseString(child.Content)
        case "OrderIndex":
            suspectBlobTape.OrderIndex = parseInt(child.Content, aggErr)
        case "TapeId":
            suspectBlobTape.TapeId = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SuspectBlobTape.", child.XMLName.Local)
        }
    }
}
type SystemFailure struct {
    Date string
    ErrorMessage *string
    Id string
    Type SystemFailureType
}
type SystemFailureList struct {
    SystemFailures []SystemFailure
}
func (systemFailureList *SystemFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SystemFailure":
            var model SystemFailure
            model.parse(&child, aggErr)
            systemFailureList.SystemFailures = append(systemFailureList.SystemFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SystemFailureList.", child.XMLName.Local)
        }
    }
}
type SystemFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type SystemFailureNotificationRegistrationList struct {
    SystemFailureNotificationRegistrations []SystemFailureNotificationRegistration
}
func (systemFailureNotificationRegistrationList *SystemFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "SystemFailureNotificationRegistration":
            var model SystemFailureNotificationRegistration
            model.parse(&child, aggErr)
            systemFailureNotificationRegistrationList.SystemFailureNotificationRegistrations = append(systemFailureNotificationRegistrationList.SystemFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SystemFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (systemFailureNotificationRegistration *SystemFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            systemFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &systemFailureNotificationRegistration.Format, aggErr)
        case "Id":
            systemFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            systemFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            systemFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            systemFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &systemFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            systemFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &systemFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            systemFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            systemFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SystemFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (systemFailure *SystemFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            systemFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            systemFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            systemFailure.Id = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &systemFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SystemFailure.", child.XMLName.Local)
        }
    }
}
type SystemFailureType Enum

const (
    SYSTEM_FAILURE_TYPE_RECONCILE_TAPE_ENVIRONMENT_FAILED SystemFailureType = 1 + iota
    SYSTEM_FAILURE_TYPE_RECONCILE_POOL_ENVIRONMENT_FAILED SystemFailureType = 1 + iota
    SYSTEM_FAILURE_TYPE_CRITICAL_DATA_VERIFICATION_ERROR_REQUIRES_USER_CONFIRMATION SystemFailureType = 1 + iota
    SYSTEM_FAILURE_TYPE_MICROSOFT_AZURE_WRITES_REQUIRE_FEATURE_LICENSE SystemFailureType = 1 + iota
    SYSTEM_FAILURE_TYPE_AWS_S3_WRITES_REQUIRE_FEATURE_LICENSE SystemFailureType = 1 + iota
    SYSTEM_FAILURE_TYPE_DATABASE_RUNNING_OUT_OF_SPACE SystemFailureType = 1 + iota
)

func (systemFailureType *SystemFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *systemFailureType = UNDEFINED
        case "RECONCILE_TAPE_ENVIRONMENT_FAILED": *systemFailureType = SYSTEM_FAILURE_TYPE_RECONCILE_TAPE_ENVIRONMENT_FAILED
        case "RECONCILE_POOL_ENVIRONMENT_FAILED": *systemFailureType = SYSTEM_FAILURE_TYPE_RECONCILE_POOL_ENVIRONMENT_FAILED
        case "CRITICAL_DATA_VERIFICATION_ERROR_REQUIRES_USER_CONFIRMATION": *systemFailureType = SYSTEM_FAILURE_TYPE_CRITICAL_DATA_VERIFICATION_ERROR_REQUIRES_USER_CONFIRMATION
        case "MICROSOFT_AZURE_WRITES_REQUIRE_FEATURE_LICENSE": *systemFailureType = SYSTEM_FAILURE_TYPE_MICROSOFT_AZURE_WRITES_REQUIRE_FEATURE_LICENSE
        case "AWS_S3_WRITES_REQUIRE_FEATURE_LICENSE": *systemFailureType = SYSTEM_FAILURE_TYPE_AWS_S3_WRITES_REQUIRE_FEATURE_LICENSE
        case "DATABASE_RUNNING_OUT_OF_SPACE": *systemFailureType = SYSTEM_FAILURE_TYPE_DATABASE_RUNNING_OUT_OF_SPACE
        default:
            *systemFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into SystemFailureType", str))
    }
    return nil
}

func (systemFailureType SystemFailureType) String() string {
    switch systemFailureType {
        case SYSTEM_FAILURE_TYPE_RECONCILE_TAPE_ENVIRONMENT_FAILED: return "RECONCILE_TAPE_ENVIRONMENT_FAILED"
        case SYSTEM_FAILURE_TYPE_RECONCILE_POOL_ENVIRONMENT_FAILED: return "RECONCILE_POOL_ENVIRONMENT_FAILED"
        case SYSTEM_FAILURE_TYPE_CRITICAL_DATA_VERIFICATION_ERROR_REQUIRES_USER_CONFIRMATION: return "CRITICAL_DATA_VERIFICATION_ERROR_REQUIRES_USER_CONFIRMATION"
        case SYSTEM_FAILURE_TYPE_MICROSOFT_AZURE_WRITES_REQUIRE_FEATURE_LICENSE: return "MICROSOFT_AZURE_WRITES_REQUIRE_FEATURE_LICENSE"
        case SYSTEM_FAILURE_TYPE_AWS_S3_WRITES_REQUIRE_FEATURE_LICENSE: return "AWS_S3_WRITES_REQUIRE_FEATURE_LICENSE"
        case SYSTEM_FAILURE_TYPE_DATABASE_RUNNING_OUT_OF_SPACE: return "DATABASE_RUNNING_OUT_OF_SPACE"
        default:
            log.Printf("Error: invalid SystemFailureType represented by '%d'", systemFailureType)
            return ""
    }
}

func (systemFailureType SystemFailureType) StringPtr() *string {
    if systemFailureType == UNDEFINED {
        return nil
    }
    result := systemFailureType.String()
    return &result
}
type SystemInformation struct {
    ApiVersion *string
    BackendActivated bool
    BuildInformation BuildInformation
    InstanceId string
    Now int64
    SerialNumber *string
}
func (systemInformation *SystemInformation) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "ApiVersion":
            systemInformation.ApiVersion = parseNullableString(child.Content)
        case "BackendActivated":
            systemInformation.BackendActivated = parseBool(child.Content, aggErr)
        case "BuildInformation":
            systemInformation.BuildInformation.parse(&child, aggErr)
        case "InstanceId":
            systemInformation.InstanceId = parseString(child.Content)
        case "Now":
            systemInformation.Now = parseInt64(child.Content, aggErr)
        case "SerialNumber":
            systemInformation.SerialNumber = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing SystemInformation.", child.XMLName.Local)
        }
    }
}
type Tape struct {
    AssignedToStorageDomain bool
    AvailableRawCapacity *int64
    BarCode *string
    BucketId *string
    DescriptionForIdentification *string
    EjectDate *string
    EjectLabel *string
    EjectLocation *string
    EjectPending *string
    FullOfData bool
    Id string
    LastAccessed *string
    LastCheckpoint *string
    LastModified *string
    LastVerified *string
    PartiallyVerifiedEndOfTape *string
    PartitionId *string
    PreviousState *TapeState
    SerialNumber *string
    State TapeState
    StorageDomainId *string
    TakeOwnershipPending bool
    TotalRawCapacity *int64
    Type string
    VerifyPending *Priority
    WriteProtected bool
}
type TapeDensityDirective struct {
    Density TapeDriveType
    Id string
    PartitionId string
    TapeType string
}
type TapeDensityDirectiveList struct {
    TapeDensityDirectives []TapeDensityDirective
}
func (tapeDensityDirectiveList *TapeDensityDirectiveList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapeDensityDirective":
            var model TapeDensityDirective
            model.parse(&child, aggErr)
            tapeDensityDirectiveList.TapeDensityDirectives = append(tapeDensityDirectiveList.TapeDensityDirectives, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeDensityDirectiveList.", child.XMLName.Local)
        }
    }
}
func (tapeDensityDirective *TapeDensityDirective) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Density":
            parseEnum(child.Content, &tapeDensityDirective.Density, aggErr)
        case "Id":
            tapeDensityDirective.Id = parseString(child.Content)
        case "PartitionId":
            tapeDensityDirective.PartitionId = parseString(child.Content)
        case "TapeType":
            tapeDensityDirective.TapeType = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeDensityDirective.", child.XMLName.Local)
        }
    }
}
type TapeDrive struct {
    CleaningRequired bool
    ErrorMessage *string
    ForceTapeRemoval bool
    Id string
    LastCleaned *string
    MfgSerialNumber *string
    PartitionId string
    Quiesced Quiesced
    SerialNumber *string
    State TapeDriveState
    TapeId *string
    Type TapeDriveType
}
type TapeDriveList struct {
    TapeDrives []TapeDrive
}
func (tapeDriveList *TapeDriveList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapeDrive":
            var model TapeDrive
            model.parse(&child, aggErr)
            tapeDriveList.TapeDrives = append(tapeDriveList.TapeDrives, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeDriveList.", child.XMLName.Local)
        }
    }
}
func (tapeDrive *TapeDrive) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CleaningRequired":
            tapeDrive.CleaningRequired = parseBool(child.Content, aggErr)
        case "ErrorMessage":
            tapeDrive.ErrorMessage = parseNullableString(child.Content)
        case "ForceTapeRemoval":
            tapeDrive.ForceTapeRemoval = parseBool(child.Content, aggErr)
        case "Id":
            tapeDrive.Id = parseString(child.Content)
        case "LastCleaned":
            tapeDrive.LastCleaned = parseNullableString(child.Content)
        case "MfgSerialNumber":
            tapeDrive.MfgSerialNumber = parseNullableString(child.Content)
        case "PartitionId":
            tapeDrive.PartitionId = parseString(child.Content)
        case "Quiesced":
            parseEnum(child.Content, &tapeDrive.Quiesced, aggErr)
        case "SerialNumber":
            tapeDrive.SerialNumber = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &tapeDrive.State, aggErr)
        case "TapeId":
            tapeDrive.TapeId = parseNullableString(child.Content)
        case "Type":
            parseEnum(child.Content, &tapeDrive.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeDrive.", child.XMLName.Local)
        }
    }
}
type TapeDriveState Enum

const (
    TAPE_DRIVE_STATE_OFFLINE TapeDriveState = 1 + iota
    TAPE_DRIVE_STATE_NORMAL TapeDriveState = 1 + iota
    TAPE_DRIVE_STATE_ERROR TapeDriveState = 1 + iota
    TAPE_DRIVE_STATE_NOT_COMPATIBLE_IN_PARTITION_DUE_TO_NEWER_TAPE_DRIVES TapeDriveState = 1 + iota
)

func (tapeDriveState *TapeDriveState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapeDriveState = UNDEFINED
        case "OFFLINE": *tapeDriveState = TAPE_DRIVE_STATE_OFFLINE
        case "NORMAL": *tapeDriveState = TAPE_DRIVE_STATE_NORMAL
        case "ERROR": *tapeDriveState = TAPE_DRIVE_STATE_ERROR
        case "NOT_COMPATIBLE_IN_PARTITION_DUE_TO_NEWER_TAPE_DRIVES": *tapeDriveState = TAPE_DRIVE_STATE_NOT_COMPATIBLE_IN_PARTITION_DUE_TO_NEWER_TAPE_DRIVES
        default:
            *tapeDriveState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapeDriveState", str))
    }
    return nil
}

func (tapeDriveState TapeDriveState) String() string {
    switch tapeDriveState {
        case TAPE_DRIVE_STATE_OFFLINE: return "OFFLINE"
        case TAPE_DRIVE_STATE_NORMAL: return "NORMAL"
        case TAPE_DRIVE_STATE_ERROR: return "ERROR"
        case TAPE_DRIVE_STATE_NOT_COMPATIBLE_IN_PARTITION_DUE_TO_NEWER_TAPE_DRIVES: return "NOT_COMPATIBLE_IN_PARTITION_DUE_TO_NEWER_TAPE_DRIVES"
        default:
            log.Printf("Error: invalid TapeDriveState represented by '%d'", tapeDriveState)
            return ""
    }
}

func (tapeDriveState TapeDriveState) StringPtr() *string {
    if tapeDriveState == UNDEFINED {
        return nil
    }
    result := tapeDriveState.String()
    return &result
}
type TapeDriveType Enum

const (
    TAPE_DRIVE_TYPE_UNKNOWN TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_LTO5 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_LTO6 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_LTO7 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_LTO8 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_TS1140 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_TS1150 TapeDriveType = 1 + iota
    TAPE_DRIVE_TYPE_TS1155 TapeDriveType = 1 + iota
)

func (tapeDriveType *TapeDriveType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapeDriveType = UNDEFINED
        case "UNKNOWN": *tapeDriveType = TAPE_DRIVE_TYPE_UNKNOWN
        case "LTO5": *tapeDriveType = TAPE_DRIVE_TYPE_LTO5
        case "LTO6": *tapeDriveType = TAPE_DRIVE_TYPE_LTO6
        case "LTO7": *tapeDriveType = TAPE_DRIVE_TYPE_LTO7
        case "LTO8": *tapeDriveType = TAPE_DRIVE_TYPE_LTO8
        case "TS1140": *tapeDriveType = TAPE_DRIVE_TYPE_TS1140
        case "TS1150": *tapeDriveType = TAPE_DRIVE_TYPE_TS1150
        case "TS1155": *tapeDriveType = TAPE_DRIVE_TYPE_TS1155
        default:
            *tapeDriveType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapeDriveType", str))
    }
    return nil
}

func (tapeDriveType TapeDriveType) String() string {
    switch tapeDriveType {
        case TAPE_DRIVE_TYPE_UNKNOWN: return "UNKNOWN"
        case TAPE_DRIVE_TYPE_LTO5: return "LTO5"
        case TAPE_DRIVE_TYPE_LTO6: return "LTO6"
        case TAPE_DRIVE_TYPE_LTO7: return "LTO7"
        case TAPE_DRIVE_TYPE_LTO8: return "LTO8"
        case TAPE_DRIVE_TYPE_TS1140: return "TS1140"
        case TAPE_DRIVE_TYPE_TS1150: return "TS1150"
        case TAPE_DRIVE_TYPE_TS1155: return "TS1155"
        default:
            log.Printf("Error: invalid TapeDriveType represented by '%d'", tapeDriveType)
            return ""
    }
}

func (tapeDriveType TapeDriveType) StringPtr() *string {
    if tapeDriveType == UNDEFINED {
        return nil
    }
    result := tapeDriveType.String()
    return &result
}
type TapeFailure struct {
    Cause *string
    Tape Tape
}
type TapeFailureList struct {
    Failures []TapeFailure
}
func (tapeFailureList *TapeFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Failure":
            var model TapeFailure
            model.parse(&child, aggErr)
            tapeFailureList.Failures = append(tapeFailureList.Failures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeFailureList.", child.XMLName.Local)
        }
    }
}
type TapeFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type TapeFailureNotificationRegistrationList struct {
    TapeFailureNotificationRegistrations []TapeFailureNotificationRegistration
}
func (tapeFailureNotificationRegistrationList *TapeFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapeFailureNotificationRegistration":
            var model TapeFailureNotificationRegistration
            model.parse(&child, aggErr)
            tapeFailureNotificationRegistrationList.TapeFailureNotificationRegistrations = append(tapeFailureNotificationRegistrationList.TapeFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (tapeFailureNotificationRegistration *TapeFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            tapeFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &tapeFailureNotificationRegistration.Format, aggErr)
        case "Id":
            tapeFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            tapeFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            tapeFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            tapeFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &tapeFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            tapeFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &tapeFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            tapeFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            tapeFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (tapeFailure *TapeFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Cause":
            tapeFailure.Cause = parseNullableString(child.Content)
        case "Tape":
            tapeFailure.Tape.parse(&child, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeFailure.", child.XMLName.Local)
        }
    }
}
type TapeFailureType Enum

const (
    TAPE_FAILURE_TYPE_BAR_CODE_CHANGED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_BAR_CODE_DUPLICATE TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_BLOB_READ_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DATA_CHECKPOINT_MISSING TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DELAYED_OWNERSHIP_FAILURE TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DRIVE_CLEAN_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_DRIVE_CLEANED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_FORMAT_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_GET_TAPE_INFORMATION_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_IMPORT_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_IMPORT_INCOMPLETE TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_INSPECT_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_READ_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_REIMPORT_REQUIRED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_SERIAL_NUMBER_MISMATCH TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_VERIFY_FAILED TapeFailureType = 1 + iota
    TAPE_FAILURE_TYPE_WRITE_FAILED TapeFailureType = 1 + iota
)

func (tapeFailureType *TapeFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapeFailureType = UNDEFINED
        case "BAR_CODE_CHANGED": *tapeFailureType = TAPE_FAILURE_TYPE_BAR_CODE_CHANGED
        case "BAR_CODE_DUPLICATE": *tapeFailureType = TAPE_FAILURE_TYPE_BAR_CODE_DUPLICATE
        case "BLOB_READ_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_BLOB_READ_FAILED
        case "DATA_CHECKPOINT_FAILURE": *tapeFailureType = TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE
        case "DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY": *tapeFailureType = TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY
        case "DATA_CHECKPOINT_MISSING": *tapeFailureType = TAPE_FAILURE_TYPE_DATA_CHECKPOINT_MISSING
        case "DELAYED_OWNERSHIP_FAILURE": *tapeFailureType = TAPE_FAILURE_TYPE_DELAYED_OWNERSHIP_FAILURE
        case "DRIVE_CLEAN_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_DRIVE_CLEAN_FAILED
        case "DRIVE_CLEANED": *tapeFailureType = TAPE_FAILURE_TYPE_DRIVE_CLEANED
        case "FORMAT_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_FORMAT_FAILED
        case "GET_TAPE_INFORMATION_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_GET_TAPE_INFORMATION_FAILED
        case "IMPORT_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_IMPORT_FAILED
        case "IMPORT_INCOMPLETE": *tapeFailureType = TAPE_FAILURE_TYPE_IMPORT_INCOMPLETE
        case "IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE": *tapeFailureType = TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE
        case "IMPORT_FAILED_DUE_TO_DATA_INTEGRITY": *tapeFailureType = TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY
        case "INSPECT_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_INSPECT_FAILED
        case "READ_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_READ_FAILED
        case "REIMPORT_REQUIRED": *tapeFailureType = TAPE_FAILURE_TYPE_REIMPORT_REQUIRED
        case "SERIAL_NUMBER_MISMATCH": *tapeFailureType = TAPE_FAILURE_TYPE_SERIAL_NUMBER_MISMATCH
        case "VERIFY_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_VERIFY_FAILED
        case "WRITE_FAILED": *tapeFailureType = TAPE_FAILURE_TYPE_WRITE_FAILED
        default:
            *tapeFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapeFailureType", str))
    }
    return nil
}

func (tapeFailureType TapeFailureType) String() string {
    switch tapeFailureType {
        case TAPE_FAILURE_TYPE_BAR_CODE_CHANGED: return "BAR_CODE_CHANGED"
        case TAPE_FAILURE_TYPE_BAR_CODE_DUPLICATE: return "BAR_CODE_DUPLICATE"
        case TAPE_FAILURE_TYPE_BLOB_READ_FAILED: return "BLOB_READ_FAILED"
        case TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE: return "DATA_CHECKPOINT_FAILURE"
        case TAPE_FAILURE_TYPE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY: return "DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY"
        case TAPE_FAILURE_TYPE_DATA_CHECKPOINT_MISSING: return "DATA_CHECKPOINT_MISSING"
        case TAPE_FAILURE_TYPE_DELAYED_OWNERSHIP_FAILURE: return "DELAYED_OWNERSHIP_FAILURE"
        case TAPE_FAILURE_TYPE_DRIVE_CLEAN_FAILED: return "DRIVE_CLEAN_FAILED"
        case TAPE_FAILURE_TYPE_DRIVE_CLEANED: return "DRIVE_CLEANED"
        case TAPE_FAILURE_TYPE_FORMAT_FAILED: return "FORMAT_FAILED"
        case TAPE_FAILURE_TYPE_GET_TAPE_INFORMATION_FAILED: return "GET_TAPE_INFORMATION_FAILED"
        case TAPE_FAILURE_TYPE_IMPORT_FAILED: return "IMPORT_FAILED"
        case TAPE_FAILURE_TYPE_IMPORT_INCOMPLETE: return "IMPORT_INCOMPLETE"
        case TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE: return "IMPORT_FAILED_DUE_TO_TAKE_OWNERSHIP_FAILURE"
        case TAPE_FAILURE_TYPE_IMPORT_FAILED_DUE_TO_DATA_INTEGRITY: return "IMPORT_FAILED_DUE_TO_DATA_INTEGRITY"
        case TAPE_FAILURE_TYPE_INSPECT_FAILED: return "INSPECT_FAILED"
        case TAPE_FAILURE_TYPE_READ_FAILED: return "READ_FAILED"
        case TAPE_FAILURE_TYPE_REIMPORT_REQUIRED: return "REIMPORT_REQUIRED"
        case TAPE_FAILURE_TYPE_SERIAL_NUMBER_MISMATCH: return "SERIAL_NUMBER_MISMATCH"
        case TAPE_FAILURE_TYPE_VERIFY_FAILED: return "VERIFY_FAILED"
        case TAPE_FAILURE_TYPE_WRITE_FAILED: return "WRITE_FAILED"
        default:
            log.Printf("Error: invalid TapeFailureType represented by '%d'", tapeFailureType)
            return ""
    }
}

func (tapeFailureType TapeFailureType) StringPtr() *string {
    if tapeFailureType == UNDEFINED {
        return nil
    }
    result := tapeFailureType.String()
    return &result
}
type TapeLibrary struct {
    Id string
    ManagementUrl *string
    Name *string
    SerialNumber *string
}
type TapeLibraryList struct {
    TapeLibraries []TapeLibrary
}
func (tapeLibraryList *TapeLibraryList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapeLibrary":
            var model TapeLibrary
            model.parse(&child, aggErr)
            tapeLibraryList.TapeLibraries = append(tapeLibraryList.TapeLibraries, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeLibraryList.", child.XMLName.Local)
        }
    }
}
func (tapeLibrary *TapeLibrary) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Id":
            tapeLibrary.Id = parseString(child.Content)
        case "ManagementUrl":
            tapeLibrary.ManagementUrl = parseNullableString(child.Content)
        case "Name":
            tapeLibrary.Name = parseNullableString(child.Content)
        case "SerialNumber":
            tapeLibrary.SerialNumber = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeLibrary.", child.XMLName.Local)
        }
    }
}
type TapeList struct {
    Tapes []Tape
}
func (tapeList *TapeList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Tape":
            var model Tape
            model.parse(&child, aggErr)
            tapeList.Tapes = append(tapeList.Tapes, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapeList.", child.XMLName.Local)
        }
    }
}
func (tape *Tape) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "AssignedToStorageDomain":
            tape.AssignedToStorageDomain = parseBool(child.Content, aggErr)
        case "AvailableRawCapacity":
            tape.AvailableRawCapacity = parseNullableInt64(child.Content, aggErr)
        case "BarCode":
            tape.BarCode = parseNullableString(child.Content)
        case "BucketId":
            tape.BucketId = parseNullableString(child.Content)
        case "DescriptionForIdentification":
            tape.DescriptionForIdentification = parseNullableString(child.Content)
        case "EjectDate":
            tape.EjectDate = parseNullableString(child.Content)
        case "EjectLabel":
            tape.EjectLabel = parseNullableString(child.Content)
        case "EjectLocation":
            tape.EjectLocation = parseNullableString(child.Content)
        case "EjectPending":
            tape.EjectPending = parseNullableString(child.Content)
        case "FullOfData":
            tape.FullOfData = parseBool(child.Content, aggErr)
        case "Id":
            tape.Id = parseString(child.Content)
        case "LastAccessed":
            tape.LastAccessed = parseNullableString(child.Content)
        case "LastCheckpoint":
            tape.LastCheckpoint = parseNullableString(child.Content)
        case "LastModified":
            tape.LastModified = parseNullableString(child.Content)
        case "LastVerified":
            tape.LastVerified = parseNullableString(child.Content)
        case "PartiallyVerifiedEndOfTape":
            tape.PartiallyVerifiedEndOfTape = parseNullableString(child.Content)
        case "PartitionId":
            tape.PartitionId = parseNullableString(child.Content)
        case "PreviousState":
            parseNullableEnum(child.Content, tape.PreviousState, aggErr)
        case "SerialNumber":
            tape.SerialNumber = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &tape.State, aggErr)
        case "StorageDomainId":
            tape.StorageDomainId = parseNullableString(child.Content)
        case "TakeOwnershipPending":
            tape.TakeOwnershipPending = parseBool(child.Content, aggErr)
        case "TotalRawCapacity":
            tape.TotalRawCapacity = parseNullableInt64(child.Content, aggErr)
        case "Type":
            tape.Type = parseString(child.Content)
        case "VerifyPending":
            parseNullableEnum(child.Content, tape.VerifyPending, aggErr)
        case "WriteProtected":
            tape.WriteProtected = parseBool(child.Content, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing Tape.", child.XMLName.Local)
        }
    }
}

func parseTapeSlice(tagName string, xmlNodes []XmlNode, aggErr *AggregateError) []Tape {
    var result []Tape
    for _, curXmlNode := range xmlNodes {
        if curXmlNode.XMLName.Local == tagName {
            var curResult Tape
            curResult.parse(&curXmlNode, aggErr)
            result = append(result, curResult)
        } else {
            log.Printf("WARNING: Discovered unexpected xml tag '%s' when expected tag '%s' when parsing Tape struct.\n", curXmlNode.XMLName.Local, tagName)
        }
    }
    return result
}
type TapePartition struct {
    DriveType *TapeDriveType
    ErrorMessage *string
    Id string
    ImportExportConfiguration ImportExportConfiguration
    LibraryId string
    Name *string
    Quiesced Quiesced
    SerialId *string
    SerialNumber *string
    State TapePartitionState
}
type TapePartitionFailure struct {
    Date string
    ErrorMessage *string
    Id string
    PartitionId string
    Type TapePartitionFailureType
}
type TapePartitionFailureList struct {
    TapePartitionFailures []TapePartitionFailure
}
func (tapePartitionFailureList *TapePartitionFailureList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapePartitionFailure":
            var model TapePartitionFailure
            model.parse(&child, aggErr)
            tapePartitionFailureList.TapePartitionFailures = append(tapePartitionFailureList.TapePartitionFailures, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartitionFailureList.", child.XMLName.Local)
        }
    }
}
type TapePartitionFailureNotificationRegistration struct {
    CreationDate string
    Format HttpResponseFormatType
    Id string
    LastFailure *string
    LastHttpResponseCode *int
    LastNotification *string
    NamingConvention NamingConventionType
    NotificationEndPoint *string
    NotificationHttpMethod RequestType
    NumberOfFailuresSinceLastSuccess int
    UserId *string
}
type TapePartitionFailureNotificationRegistrationList struct {
    TapePartitionFailureNotificationRegistrations []TapePartitionFailureNotificationRegistration
}
func (tapePartitionFailureNotificationRegistrationList *TapePartitionFailureNotificationRegistrationList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapePartitionFailureNotificationRegistration":
            var model TapePartitionFailureNotificationRegistration
            model.parse(&child, aggErr)
            tapePartitionFailureNotificationRegistrationList.TapePartitionFailureNotificationRegistrations = append(tapePartitionFailureNotificationRegistrationList.TapePartitionFailureNotificationRegistrations, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartitionFailureNotificationRegistrationList.", child.XMLName.Local)
        }
    }
}
func (tapePartitionFailureNotificationRegistration *TapePartitionFailureNotificationRegistration) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "CreationDate":
            tapePartitionFailureNotificationRegistration.CreationDate = parseString(child.Content)
        case "Format":
            parseEnum(child.Content, &tapePartitionFailureNotificationRegistration.Format, aggErr)
        case "Id":
            tapePartitionFailureNotificationRegistration.Id = parseString(child.Content)
        case "LastFailure":
            tapePartitionFailureNotificationRegistration.LastFailure = parseNullableString(child.Content)
        case "LastHttpResponseCode":
            tapePartitionFailureNotificationRegistration.LastHttpResponseCode = parseNullableInt(child.Content, aggErr)
        case "LastNotification":
            tapePartitionFailureNotificationRegistration.LastNotification = parseNullableString(child.Content)
        case "NamingConvention":
            parseEnum(child.Content, &tapePartitionFailureNotificationRegistration.NamingConvention, aggErr)
        case "NotificationEndPoint":
            tapePartitionFailureNotificationRegistration.NotificationEndPoint = parseNullableString(child.Content)
        case "NotificationHttpMethod":
            parseEnum(child.Content, &tapePartitionFailureNotificationRegistration.NotificationHttpMethod, aggErr)
        case "NumberOfFailuresSinceLastSuccess":
            tapePartitionFailureNotificationRegistration.NumberOfFailuresSinceLastSuccess = parseInt(child.Content, aggErr)
        case "UserId":
            tapePartitionFailureNotificationRegistration.UserId = parseNullableString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartitionFailureNotificationRegistration.", child.XMLName.Local)
        }
    }
}
func (tapePartitionFailure *TapePartitionFailure) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "Date":
            tapePartitionFailure.Date = parseString(child.Content)
        case "ErrorMessage":
            tapePartitionFailure.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            tapePartitionFailure.Id = parseString(child.Content)
        case "PartitionId":
            tapePartitionFailure.PartitionId = parseString(child.Content)
        case "Type":
            parseEnum(child.Content, &tapePartitionFailure.Type, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartitionFailure.", child.XMLName.Local)
        }
    }
}
type TapePartitionFailureType Enum

const (
    TAPE_PARTITION_FAILURE_TYPE_CLEANING_TAPE_REQUIRED TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_DUPLICATE_TAPE_BAR_CODES_DETECTED TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_EJECT_STALLED_DUE_TO_OFFLINE_TAPES TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_MINIMUM_DRIVE_COUNT_NOT_MET TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED_DUE_TO_PREPARE_TAPE_FOR_REMOVAL_FAILURE TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_NO_USABLE_DRIVES TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_ONLINE_STALLED_DUE_TO_NO_STORAGE_SLOTS TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_IN_ERROR TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_MISSING TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_QUIESCED TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_TYPE_MISMATCH TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_EJECTION_BY_OPERATOR_REQUIRED TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_MEDIA_TYPE_INCOMPATIBLE TapePartitionFailureType = 1 + iota
    TAPE_PARTITION_FAILURE_TYPE_TAPE_REMOVAL_UNEXPECTED TapePartitionFailureType = 1 + iota
)

func (tapePartitionFailureType *TapePartitionFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapePartitionFailureType = UNDEFINED
        case "CLEANING_TAPE_REQUIRED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_CLEANING_TAPE_REQUIRED
        case "DUPLICATE_TAPE_BAR_CODES_DETECTED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_DUPLICATE_TAPE_BAR_CODES_DETECTED
        case "EJECT_STALLED_DUE_TO_OFFLINE_TAPES": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_EJECT_STALLED_DUE_TO_OFFLINE_TAPES
        case "MINIMUM_DRIVE_COUNT_NOT_MET": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_MINIMUM_DRIVE_COUNT_NOT_MET
        case "MOVE_FAILED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED
        case "MOVE_FAILED_DUE_TO_PREPARE_TAPE_FOR_REMOVAL_FAILURE": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED_DUE_TO_PREPARE_TAPE_FOR_REMOVAL_FAILURE
        case "NO_USABLE_DRIVES": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_NO_USABLE_DRIVES
        case "ONLINE_STALLED_DUE_TO_NO_STORAGE_SLOTS": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_ONLINE_STALLED_DUE_TO_NO_STORAGE_SLOTS
        case "TAPE_DRIVE_IN_ERROR": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_IN_ERROR
        case "TAPE_DRIVE_MISSING": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_MISSING
        case "TAPE_DRIVE_QUIESCED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_QUIESCED
        case "TAPE_DRIVE_TYPE_MISMATCH": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_TYPE_MISMATCH
        case "TAPE_EJECTION_BY_OPERATOR_REQUIRED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_EJECTION_BY_OPERATOR_REQUIRED
        case "TAPE_MEDIA_TYPE_INCOMPATIBLE": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_MEDIA_TYPE_INCOMPATIBLE
        case "TAPE_REMOVAL_UNEXPECTED": *tapePartitionFailureType = TAPE_PARTITION_FAILURE_TYPE_TAPE_REMOVAL_UNEXPECTED
        default:
            *tapePartitionFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapePartitionFailureType", str))
    }
    return nil
}

func (tapePartitionFailureType TapePartitionFailureType) String() string {
    switch tapePartitionFailureType {
        case TAPE_PARTITION_FAILURE_TYPE_CLEANING_TAPE_REQUIRED: return "CLEANING_TAPE_REQUIRED"
        case TAPE_PARTITION_FAILURE_TYPE_DUPLICATE_TAPE_BAR_CODES_DETECTED: return "DUPLICATE_TAPE_BAR_CODES_DETECTED"
        case TAPE_PARTITION_FAILURE_TYPE_EJECT_STALLED_DUE_TO_OFFLINE_TAPES: return "EJECT_STALLED_DUE_TO_OFFLINE_TAPES"
        case TAPE_PARTITION_FAILURE_TYPE_MINIMUM_DRIVE_COUNT_NOT_MET: return "MINIMUM_DRIVE_COUNT_NOT_MET"
        case TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED: return "MOVE_FAILED"
        case TAPE_PARTITION_FAILURE_TYPE_MOVE_FAILED_DUE_TO_PREPARE_TAPE_FOR_REMOVAL_FAILURE: return "MOVE_FAILED_DUE_TO_PREPARE_TAPE_FOR_REMOVAL_FAILURE"
        case TAPE_PARTITION_FAILURE_TYPE_NO_USABLE_DRIVES: return "NO_USABLE_DRIVES"
        case TAPE_PARTITION_FAILURE_TYPE_ONLINE_STALLED_DUE_TO_NO_STORAGE_SLOTS: return "ONLINE_STALLED_DUE_TO_NO_STORAGE_SLOTS"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_IN_ERROR: return "TAPE_DRIVE_IN_ERROR"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_MISSING: return "TAPE_DRIVE_MISSING"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_QUIESCED: return "TAPE_DRIVE_QUIESCED"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_DRIVE_TYPE_MISMATCH: return "TAPE_DRIVE_TYPE_MISMATCH"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_EJECTION_BY_OPERATOR_REQUIRED: return "TAPE_EJECTION_BY_OPERATOR_REQUIRED"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_MEDIA_TYPE_INCOMPATIBLE: return "TAPE_MEDIA_TYPE_INCOMPATIBLE"
        case TAPE_PARTITION_FAILURE_TYPE_TAPE_REMOVAL_UNEXPECTED: return "TAPE_REMOVAL_UNEXPECTED"
        default:
            log.Printf("Error: invalid TapePartitionFailureType represented by '%d'", tapePartitionFailureType)
            return ""
    }
}

func (tapePartitionFailureType TapePartitionFailureType) StringPtr() *string {
    if tapePartitionFailureType == UNDEFINED {
        return nil
    }
    result := tapePartitionFailureType.String()
    return &result
}
type TapePartitionList struct {
    TapePartitions []TapePartition
}
func (tapePartitionList *TapePartitionList) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "TapePartition":
            var model TapePartition
            model.parse(&child, aggErr)
            tapePartitionList.TapePartitions = append(tapePartitionList.TapePartitions, model)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartitionList.", child.XMLName.Local)
        }
    }
}
func (tapePartition *TapePartition) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DriveType":
            parseNullableEnum(child.Content, tapePartition.DriveType, aggErr)
        case "ErrorMessage":
            tapePartition.ErrorMessage = parseNullableString(child.Content)
        case "Id":
            tapePartition.Id = parseString(child.Content)
        case "ImportExportConfiguration":
            parseEnum(child.Content, &tapePartition.ImportExportConfiguration, aggErr)
        case "LibraryId":
            tapePartition.LibraryId = parseString(child.Content)
        case "Name":
            tapePartition.Name = parseNullableString(child.Content)
        case "Quiesced":
            parseEnum(child.Content, &tapePartition.Quiesced, aggErr)
        case "SerialId":
            tapePartition.SerialId = parseNullableString(child.Content)
        case "SerialNumber":
            tapePartition.SerialNumber = parseNullableString(child.Content)
        case "State":
            parseEnum(child.Content, &tapePartition.State, aggErr)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing TapePartition.", child.XMLName.Local)
        }
    }
}
type TapePartitionState Enum

const (
    TAPE_PARTITION_STATE_ONLINE TapePartitionState = 1 + iota
    TAPE_PARTITION_STATE_OFFLINE TapePartitionState = 1 + iota
    TAPE_PARTITION_STATE_ERROR TapePartitionState = 1 + iota
)

func (tapePartitionState *TapePartitionState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapePartitionState = UNDEFINED
        case "ONLINE": *tapePartitionState = TAPE_PARTITION_STATE_ONLINE
        case "OFFLINE": *tapePartitionState = TAPE_PARTITION_STATE_OFFLINE
        case "ERROR": *tapePartitionState = TAPE_PARTITION_STATE_ERROR
        default:
            *tapePartitionState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapePartitionState", str))
    }
    return nil
}

func (tapePartitionState TapePartitionState) String() string {
    switch tapePartitionState {
        case TAPE_PARTITION_STATE_ONLINE: return "ONLINE"
        case TAPE_PARTITION_STATE_OFFLINE: return "OFFLINE"
        case TAPE_PARTITION_STATE_ERROR: return "ERROR"
        default:
            log.Printf("Error: invalid TapePartitionState represented by '%d'", tapePartitionState)
            return ""
    }
}

func (tapePartitionState TapePartitionState) StringPtr() *string {
    if tapePartitionState == UNDEFINED {
        return nil
    }
    result := tapePartitionState.String()
    return &result
}
type TapeState Enum

const (
    TAPE_STATE_NORMAL TapeState = 1 + iota
    TAPE_STATE_OFFLINE TapeState = 1 + iota
    TAPE_STATE_ONLINE_PENDING TapeState = 1 + iota
    TAPE_STATE_ONLINE_IN_PROGRESS TapeState = 1 + iota
    TAPE_STATE_PENDING_INSPECTION TapeState = 1 + iota
    TAPE_STATE_UNKNOWN TapeState = 1 + iota
    TAPE_STATE_DATA_CHECKPOINT_FAILURE TapeState = 1 + iota
    TAPE_STATE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY TapeState = 1 + iota
    TAPE_STATE_DATA_CHECKPOINT_MISSING TapeState = 1 + iota
    TAPE_STATE_LTFS_WITH_FOREIGN_DATA TapeState = 1 + iota
    TAPE_STATE_RAW_IMPORT_PENDING TapeState = 1 + iota
    TAPE_STATE_RAW_IMPORT_IN_PROGRESS TapeState = 1 + iota
    TAPE_STATE_FOREIGN TapeState = 1 + iota
    TAPE_STATE_IMPORT_PENDING TapeState = 1 + iota
    TAPE_STATE_IMPORT_IN_PROGRESS TapeState = 1 + iota
    TAPE_STATE_INCOMPATIBLE TapeState = 1 + iota
    TAPE_STATE_LOST TapeState = 1 + iota
    TAPE_STATE_BAD TapeState = 1 + iota
    TAPE_STATE_CANNOT_FORMAT_DUE_TO_WRITE_PROTECTION TapeState = 1 + iota
    TAPE_STATE_SERIAL_NUMBER_MISMATCH TapeState = 1 + iota
    TAPE_STATE_BAR_CODE_MISSING TapeState = 1 + iota
    TAPE_STATE_FORMAT_PENDING TapeState = 1 + iota
    TAPE_STATE_FORMAT_IN_PROGRESS TapeState = 1 + iota
    TAPE_STATE_EJECT_TO_EE_IN_PROGRESS TapeState = 1 + iota
    TAPE_STATE_EJECT_FROM_EE_PENDING TapeState = 1 + iota
    TAPE_STATE_EJECTED TapeState = 1 + iota
)

func (tapeState *TapeState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *tapeState = UNDEFINED
        case "NORMAL": *tapeState = TAPE_STATE_NORMAL
        case "OFFLINE": *tapeState = TAPE_STATE_OFFLINE
        case "ONLINE_PENDING": *tapeState = TAPE_STATE_ONLINE_PENDING
        case "ONLINE_IN_PROGRESS": *tapeState = TAPE_STATE_ONLINE_IN_PROGRESS
        case "PENDING_INSPECTION": *tapeState = TAPE_STATE_PENDING_INSPECTION
        case "UNKNOWN": *tapeState = TAPE_STATE_UNKNOWN
        case "DATA_CHECKPOINT_FAILURE": *tapeState = TAPE_STATE_DATA_CHECKPOINT_FAILURE
        case "DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY": *tapeState = TAPE_STATE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY
        case "DATA_CHECKPOINT_MISSING": *tapeState = TAPE_STATE_DATA_CHECKPOINT_MISSING
        case "LTFS_WITH_FOREIGN_DATA": *tapeState = TAPE_STATE_LTFS_WITH_FOREIGN_DATA
        case "RAW_IMPORT_PENDING": *tapeState = TAPE_STATE_RAW_IMPORT_PENDING
        case "RAW_IMPORT_IN_PROGRESS": *tapeState = TAPE_STATE_RAW_IMPORT_IN_PROGRESS
        case "FOREIGN": *tapeState = TAPE_STATE_FOREIGN
        case "IMPORT_PENDING": *tapeState = TAPE_STATE_IMPORT_PENDING
        case "IMPORT_IN_PROGRESS": *tapeState = TAPE_STATE_IMPORT_IN_PROGRESS
        case "INCOMPATIBLE": *tapeState = TAPE_STATE_INCOMPATIBLE
        case "LOST": *tapeState = TAPE_STATE_LOST
        case "BAD": *tapeState = TAPE_STATE_BAD
        case "CANNOT_FORMAT_DUE_TO_WRITE_PROTECTION": *tapeState = TAPE_STATE_CANNOT_FORMAT_DUE_TO_WRITE_PROTECTION
        case "SERIAL_NUMBER_MISMATCH": *tapeState = TAPE_STATE_SERIAL_NUMBER_MISMATCH
        case "BAR_CODE_MISSING": *tapeState = TAPE_STATE_BAR_CODE_MISSING
        case "FORMAT_PENDING": *tapeState = TAPE_STATE_FORMAT_PENDING
        case "FORMAT_IN_PROGRESS": *tapeState = TAPE_STATE_FORMAT_IN_PROGRESS
        case "EJECT_TO_EE_IN_PROGRESS": *tapeState = TAPE_STATE_EJECT_TO_EE_IN_PROGRESS
        case "EJECT_FROM_EE_PENDING": *tapeState = TAPE_STATE_EJECT_FROM_EE_PENDING
        case "EJECTED": *tapeState = TAPE_STATE_EJECTED
        default:
            *tapeState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TapeState", str))
    }
    return nil
}

func (tapeState TapeState) String() string {
    switch tapeState {
        case TAPE_STATE_NORMAL: return "NORMAL"
        case TAPE_STATE_OFFLINE: return "OFFLINE"
        case TAPE_STATE_ONLINE_PENDING: return "ONLINE_PENDING"
        case TAPE_STATE_ONLINE_IN_PROGRESS: return "ONLINE_IN_PROGRESS"
        case TAPE_STATE_PENDING_INSPECTION: return "PENDING_INSPECTION"
        case TAPE_STATE_UNKNOWN: return "UNKNOWN"
        case TAPE_STATE_DATA_CHECKPOINT_FAILURE: return "DATA_CHECKPOINT_FAILURE"
        case TAPE_STATE_DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY: return "DATA_CHECKPOINT_FAILURE_DUE_TO_READ_ONLY"
        case TAPE_STATE_DATA_CHECKPOINT_MISSING: return "DATA_CHECKPOINT_MISSING"
        case TAPE_STATE_LTFS_WITH_FOREIGN_DATA: return "LTFS_WITH_FOREIGN_DATA"
        case TAPE_STATE_RAW_IMPORT_PENDING: return "RAW_IMPORT_PENDING"
        case TAPE_STATE_RAW_IMPORT_IN_PROGRESS: return "RAW_IMPORT_IN_PROGRESS"
        case TAPE_STATE_FOREIGN: return "FOREIGN"
        case TAPE_STATE_IMPORT_PENDING: return "IMPORT_PENDING"
        case TAPE_STATE_IMPORT_IN_PROGRESS: return "IMPORT_IN_PROGRESS"
        case TAPE_STATE_INCOMPATIBLE: return "INCOMPATIBLE"
        case TAPE_STATE_LOST: return "LOST"
        case TAPE_STATE_BAD: return "BAD"
        case TAPE_STATE_CANNOT_FORMAT_DUE_TO_WRITE_PROTECTION: return "CANNOT_FORMAT_DUE_TO_WRITE_PROTECTION"
        case TAPE_STATE_SERIAL_NUMBER_MISMATCH: return "SERIAL_NUMBER_MISMATCH"
        case TAPE_STATE_BAR_CODE_MISSING: return "BAR_CODE_MISSING"
        case TAPE_STATE_FORMAT_PENDING: return "FORMAT_PENDING"
        case TAPE_STATE_FORMAT_IN_PROGRESS: return "FORMAT_IN_PROGRESS"
        case TAPE_STATE_EJECT_TO_EE_IN_PROGRESS: return "EJECT_TO_EE_IN_PROGRESS"
        case TAPE_STATE_EJECT_FROM_EE_PENDING: return "EJECT_FROM_EE_PENDING"
        case TAPE_STATE_EJECTED: return "EJECTED"
        default:
            log.Printf("Error: invalid TapeState represented by '%d'", tapeState)
            return ""
    }
}

func (tapeState TapeState) StringPtr() *string {
    if tapeState == UNDEFINED {
        return nil
    }
    result := tapeState.String()
    return &result
}
type TargetFailureType Enum

const (
    TARGET_FAILURE_TYPE_IMPORT_FAILED TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_IMPORT_INCOMPLETE TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_NOT_ONLINE TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_WRITE_FAILED TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_WRITE_INITIATE_FAILED TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_READ_FAILED TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_READ_INITIATE_FAILED TargetFailureType = 1 + iota
    TARGET_FAILURE_TYPE_VERIFY_FAILED TargetFailureType = 1 + iota
)

func (targetFailureType *TargetFailureType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *targetFailureType = UNDEFINED
        case "IMPORT_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_IMPORT_FAILED
        case "IMPORT_INCOMPLETE": *targetFailureType = TARGET_FAILURE_TYPE_IMPORT_INCOMPLETE
        case "NOT_ONLINE": *targetFailureType = TARGET_FAILURE_TYPE_NOT_ONLINE
        case "WRITE_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_WRITE_FAILED
        case "WRITE_INITIATE_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_WRITE_INITIATE_FAILED
        case "READ_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_READ_FAILED
        case "READ_INITIATE_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_READ_INITIATE_FAILED
        case "VERIFY_FAILED": *targetFailureType = TARGET_FAILURE_TYPE_VERIFY_FAILED
        default:
            *targetFailureType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TargetFailureType", str))
    }
    return nil
}

func (targetFailureType TargetFailureType) String() string {
    switch targetFailureType {
        case TARGET_FAILURE_TYPE_IMPORT_FAILED: return "IMPORT_FAILED"
        case TARGET_FAILURE_TYPE_IMPORT_INCOMPLETE: return "IMPORT_INCOMPLETE"
        case TARGET_FAILURE_TYPE_NOT_ONLINE: return "NOT_ONLINE"
        case TARGET_FAILURE_TYPE_WRITE_FAILED: return "WRITE_FAILED"
        case TARGET_FAILURE_TYPE_WRITE_INITIATE_FAILED: return "WRITE_INITIATE_FAILED"
        case TARGET_FAILURE_TYPE_READ_FAILED: return "READ_FAILED"
        case TARGET_FAILURE_TYPE_READ_INITIATE_FAILED: return "READ_INITIATE_FAILED"
        case TARGET_FAILURE_TYPE_VERIFY_FAILED: return "VERIFY_FAILED"
        default:
            log.Printf("Error: invalid TargetFailureType represented by '%d'", targetFailureType)
            return ""
    }
}

func (targetFailureType TargetFailureType) StringPtr() *string {
    if targetFailureType == UNDEFINED {
        return nil
    }
    result := targetFailureType.String()
    return &result
}
type TargetReadPreferenceType Enum

const (
    TARGET_READ_PREFERENCE_TYPE_MINIMUM_LATENCY TargetReadPreferenceType = 1 + iota
    TARGET_READ_PREFERENCE_TYPE_AFTER_ONLINE_POOL TargetReadPreferenceType = 1 + iota
    TARGET_READ_PREFERENCE_TYPE_AFTER_NEARLINE_POOL TargetReadPreferenceType = 1 + iota
    TARGET_READ_PREFERENCE_TYPE_AFTER_NON_EJECTABLE_TAPE TargetReadPreferenceType = 1 + iota
    TARGET_READ_PREFERENCE_TYPE_LAST_RESORT TargetReadPreferenceType = 1 + iota
    TARGET_READ_PREFERENCE_TYPE_NEVER TargetReadPreferenceType = 1 + iota
)

func (targetReadPreferenceType *TargetReadPreferenceType) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *targetReadPreferenceType = UNDEFINED
        case "MINIMUM_LATENCY": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_MINIMUM_LATENCY
        case "AFTER_ONLINE_POOL": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_AFTER_ONLINE_POOL
        case "AFTER_NEARLINE_POOL": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_AFTER_NEARLINE_POOL
        case "AFTER_NON_EJECTABLE_TAPE": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_AFTER_NON_EJECTABLE_TAPE
        case "LAST_RESORT": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_LAST_RESORT
        case "NEVER": *targetReadPreferenceType = TARGET_READ_PREFERENCE_TYPE_NEVER
        default:
            *targetReadPreferenceType = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TargetReadPreferenceType", str))
    }
    return nil
}

func (targetReadPreferenceType TargetReadPreferenceType) String() string {
    switch targetReadPreferenceType {
        case TARGET_READ_PREFERENCE_TYPE_MINIMUM_LATENCY: return "MINIMUM_LATENCY"
        case TARGET_READ_PREFERENCE_TYPE_AFTER_ONLINE_POOL: return "AFTER_ONLINE_POOL"
        case TARGET_READ_PREFERENCE_TYPE_AFTER_NEARLINE_POOL: return "AFTER_NEARLINE_POOL"
        case TARGET_READ_PREFERENCE_TYPE_AFTER_NON_EJECTABLE_TAPE: return "AFTER_NON_EJECTABLE_TAPE"
        case TARGET_READ_PREFERENCE_TYPE_LAST_RESORT: return "LAST_RESORT"
        case TARGET_READ_PREFERENCE_TYPE_NEVER: return "NEVER"
        default:
            log.Printf("Error: invalid TargetReadPreferenceType represented by '%d'", targetReadPreferenceType)
            return ""
    }
}

func (targetReadPreferenceType TargetReadPreferenceType) StringPtr() *string {
    if targetReadPreferenceType == UNDEFINED {
        return nil
    }
    result := targetReadPreferenceType.String()
    return &result
}
type TargetState Enum

const (
    TARGET_STATE_ONLINE TargetState = 1 + iota
    TARGET_STATE_OFFLINE TargetState = 1 + iota
)

func (targetState *TargetState) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *targetState = UNDEFINED
        case "ONLINE": *targetState = TARGET_STATE_ONLINE
        case "OFFLINE": *targetState = TARGET_STATE_OFFLINE
        default:
            *targetState = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into TargetState", str))
    }
    return nil
}

func (targetState TargetState) String() string {
    switch targetState {
        case TARGET_STATE_ONLINE: return "ONLINE"
        case TARGET_STATE_OFFLINE: return "OFFLINE"
        default:
            log.Printf("Error: invalid TargetState represented by '%d'", targetState)
            return ""
    }
}

func (targetState TargetState) StringPtr() *string {
    if targetState == UNDEFINED {
        return nil
    }
    result := targetState.String()
    return &result
}
type TruncateActiveJobSpectraS3Request struct {
    ActiveJobId string
}

func NewTruncateActiveJobSpectraS3Request(activeJobId string) *TruncateActiveJobSpectraS3Request {
    return &TruncateActiveJobSpectraS3Request{
        ActiveJobId: activeJobId,
    }
}

type TruncateActiveJobSpectraS3Response struct {
    
    Headers *http.Header
}



func NewTruncateActiveJobSpectraS3Response(webResponse WebResponse) (*TruncateActiveJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &TruncateActiveJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type TruncateAllActiveJobsSpectraS3Request struct {
    BucketId *string
    RequestType JobRequestType
}

func NewTruncateAllActiveJobsSpectraS3Request() *TruncateAllActiveJobsSpectraS3Request {
    return &TruncateAllActiveJobsSpectraS3Request{
    }
}

func (truncateAllActiveJobsSpectraS3Request *TruncateAllActiveJobsSpectraS3Request) WithBucketId(bucketId string) *TruncateAllActiveJobsSpectraS3Request {
    truncateAllActiveJobsSpectraS3Request.BucketId = &bucketId
    return truncateAllActiveJobsSpectraS3Request
}

func (truncateAllActiveJobsSpectraS3Request *TruncateAllActiveJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *TruncateAllActiveJobsSpectraS3Request {
    truncateAllActiveJobsSpectraS3Request.RequestType = requestType
    return truncateAllActiveJobsSpectraS3Request
}

type TruncateAllActiveJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewTruncateAllActiveJobsSpectraS3Response(webResponse WebResponse) (*TruncateAllActiveJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &TruncateAllActiveJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type TruncateAllJobsSpectraS3Request struct {
    BucketId *string
    RequestType JobRequestType
}

func NewTruncateAllJobsSpectraS3Request() *TruncateAllJobsSpectraS3Request {
    return &TruncateAllJobsSpectraS3Request{
    }
}

func (truncateAllJobsSpectraS3Request *TruncateAllJobsSpectraS3Request) WithBucketId(bucketId string) *TruncateAllJobsSpectraS3Request {
    truncateAllJobsSpectraS3Request.BucketId = &bucketId
    return truncateAllJobsSpectraS3Request
}

func (truncateAllJobsSpectraS3Request *TruncateAllJobsSpectraS3Request) WithRequestType(requestType JobRequestType) *TruncateAllJobsSpectraS3Request {
    truncateAllJobsSpectraS3Request.RequestType = requestType
    return truncateAllJobsSpectraS3Request
}

type TruncateAllJobsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewTruncateAllJobsSpectraS3Response(webResponse WebResponse) (*TruncateAllJobsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &TruncateAllJobsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type TruncateJobSpectraS3Request struct {
    JobId string
}

func NewTruncateJobSpectraS3Request(jobId string) *TruncateJobSpectraS3Request {
    return &TruncateJobSpectraS3Request{
        JobId: jobId,
    }
}

type TruncateJobSpectraS3Response struct {
    
    Headers *http.Header
}



func NewTruncateJobSpectraS3Response(webResponse WebResponse) (*TruncateJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &TruncateJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type UnavailableMediaUsagePolicy Enum

const (
    UNAVAILABLE_MEDIA_USAGE_POLICY_ALLOW UnavailableMediaUsagePolicy = 1 + iota
    UNAVAILABLE_MEDIA_USAGE_POLICY_DISCOURAGED UnavailableMediaUsagePolicy = 1 + iota
    UNAVAILABLE_MEDIA_USAGE_POLICY_DISALLOW UnavailableMediaUsagePolicy = 1 + iota
)

func (unavailableMediaUsagePolicy *UnavailableMediaUsagePolicy) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *unavailableMediaUsagePolicy = UNDEFINED
        case "ALLOW": *unavailableMediaUsagePolicy = UNAVAILABLE_MEDIA_USAGE_POLICY_ALLOW
        case "DISCOURAGED": *unavailableMediaUsagePolicy = UNAVAILABLE_MEDIA_USAGE_POLICY_DISCOURAGED
        case "DISALLOW": *unavailableMediaUsagePolicy = UNAVAILABLE_MEDIA_USAGE_POLICY_DISALLOW
        default:
            *unavailableMediaUsagePolicy = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into UnavailableMediaUsagePolicy", str))
    }
    return nil
}

func (unavailableMediaUsagePolicy UnavailableMediaUsagePolicy) String() string {
    switch unavailableMediaUsagePolicy {
        case UNAVAILABLE_MEDIA_USAGE_POLICY_ALLOW: return "ALLOW"
        case UNAVAILABLE_MEDIA_USAGE_POLICY_DISCOURAGED: return "DISCOURAGED"
        case UNAVAILABLE_MEDIA_USAGE_POLICY_DISALLOW: return "DISALLOW"
        default:
            log.Printf("Error: invalid UnavailableMediaUsagePolicy represented by '%d'", unavailableMediaUsagePolicy)
            return ""
    }
}

func (unavailableMediaUsagePolicy UnavailableMediaUsagePolicy) StringPtr() *string {
    if unavailableMediaUsagePolicy == UNDEFINED {
        return nil
    }
    result := unavailableMediaUsagePolicy.String()
    return &result
}
type User struct {
    DisplayName *string
    Id string
}
func (user *User) parse(xmlNode *XmlNode, aggErr *AggregateError) {

    // Parse Child Nodes
    for _, child := range xmlNode.Children {
        switch child.XMLName.Local {
        case "DisplayName":
            user.DisplayName = parseNullableString(child.Content)
        case "ID":
            user.Id = parseString(child.Content)
        default:
            log.Printf("WARNING: unable to parse unknown xml tag '%s' while parsing User.", child.XMLName.Local)
        }
    }
}
type VerifyAllPoolsSpectraS3Request struct {
    Priority Priority
}

func NewVerifyAllPoolsSpectraS3Request() *VerifyAllPoolsSpectraS3Request {
    return &VerifyAllPoolsSpectraS3Request{
    }
}

func (verifyAllPoolsSpectraS3Request *VerifyAllPoolsSpectraS3Request) WithPriority(priority Priority) *VerifyAllPoolsSpectraS3Request {
    verifyAllPoolsSpectraS3Request.Priority = priority
    return verifyAllPoolsSpectraS3Request
}

type VerifyAllPoolsSpectraS3Response struct {
    
    Headers *http.Header
}



func NewVerifyAllPoolsSpectraS3Response(webResponse WebResponse) (*VerifyAllPoolsSpectraS3Response, error) {
    expectedStatusCodes := []int { 204 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &VerifyAllPoolsSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyAllTapesSpectraS3Request struct {
    TaskPriority Priority
}

func NewVerifyAllTapesSpectraS3Request() *VerifyAllTapesSpectraS3Request {
    return &VerifyAllTapesSpectraS3Request{
    }
}

func (verifyAllTapesSpectraS3Request *VerifyAllTapesSpectraS3Request) WithTaskPriority(taskPriority Priority) *VerifyAllTapesSpectraS3Request {
    verifyAllTapesSpectraS3Request.TaskPriority = taskPriority
    return verifyAllTapesSpectraS3Request
}

type VerifyAllTapesSpectraS3Response struct {
    TapeFailureList *TapeFailureList
    Headers *http.Header
}

func (verifyAllTapesSpectraS3Response *VerifyAllTapesSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, verifyAllTapesSpectraS3Response.TapeFailureList)
}

func NewVerifyAllTapesSpectraS3Response(webResponse WebResponse) (*VerifyAllTapesSpectraS3Response, error) {
    expectedStatusCodes := []int { 204, 207 }

    switch code := webResponse.StatusCode(); code {
    case 204:
        return &VerifyAllTapesSpectraS3Response{Headers: webResponse.Header()}, nil
    case 207:
        var body VerifyAllTapesSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyAzureTargetSpectraS3Request struct {
    AzureTarget string
    FullDetails bool
}

func NewVerifyAzureTargetSpectraS3Request(azureTarget string) *VerifyAzureTargetSpectraS3Request {
    return &VerifyAzureTargetSpectraS3Request{
        AzureTarget: azureTarget,
    }
}

func (verifyAzureTargetSpectraS3Request *VerifyAzureTargetSpectraS3Request) WithFullDetails() *VerifyAzureTargetSpectraS3Request {
    verifyAzureTargetSpectraS3Request.FullDetails = true
    return verifyAzureTargetSpectraS3Request
}

type VerifyAzureTargetSpectraS3Response struct {
    AzureTarget AzureTarget
    Headers *http.Header
}

func (verifyAzureTargetSpectraS3Response *VerifyAzureTargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyAzureTargetSpectraS3Response.AzureTarget)
}

func NewVerifyAzureTargetSpectraS3Response(webResponse WebResponse) (*VerifyAzureTargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyAzureTargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyBulkJobSpectraS3Request struct {
    BucketName string
    Aggregating *bool
    Name *string
    Objects []Ds3GetObject
    Priority Priority
}

func NewVerifyBulkJobSpectraS3Request(bucketName string, objectNames []string) *VerifyBulkJobSpectraS3Request {

    return &VerifyBulkJobSpectraS3Request{
        BucketName: bucketName,
        Objects: buildDs3GetObjectSliceFromNames(objectNames),
    }
}

func NewVerifyBulkJobSpectraS3RequestWithPartialObjects(bucketName string, objects []Ds3GetObject) *VerifyBulkJobSpectraS3Request {

    return &VerifyBulkJobSpectraS3Request{
        BucketName: bucketName,
        Objects: objects,
    }
}

func (verifyBulkJobSpectraS3Request *VerifyBulkJobSpectraS3Request) WithAggregating(aggregating bool) *VerifyBulkJobSpectraS3Request {
    verifyBulkJobSpectraS3Request.Aggregating = &aggregating
    return verifyBulkJobSpectraS3Request
}

func (verifyBulkJobSpectraS3Request *VerifyBulkJobSpectraS3Request) WithName(name string) *VerifyBulkJobSpectraS3Request {
    verifyBulkJobSpectraS3Request.Name = &name
    return verifyBulkJobSpectraS3Request
}

func (verifyBulkJobSpectraS3Request *VerifyBulkJobSpectraS3Request) WithPriority(priority Priority) *VerifyBulkJobSpectraS3Request {
    verifyBulkJobSpectraS3Request.Priority = priority
    return verifyBulkJobSpectraS3Request
}

type VerifyBulkJobSpectraS3Response struct {
    MasterObjectList MasterObjectList
    Headers *http.Header
}

func (verifyBulkJobSpectraS3Response *VerifyBulkJobSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyBulkJobSpectraS3Response.MasterObjectList)
}

func NewVerifyBulkJobSpectraS3Response(webResponse WebResponse) (*VerifyBulkJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyBulkJobSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyDs3TargetSpectraS3Request struct {
    Ds3Target string
    FullDetails bool
}

func NewVerifyDs3TargetSpectraS3Request(ds3Target string) *VerifyDs3TargetSpectraS3Request {
    return &VerifyDs3TargetSpectraS3Request{
        Ds3Target: ds3Target,
    }
}

func (verifyDs3TargetSpectraS3Request *VerifyDs3TargetSpectraS3Request) WithFullDetails() *VerifyDs3TargetSpectraS3Request {
    verifyDs3TargetSpectraS3Request.FullDetails = true
    return verifyDs3TargetSpectraS3Request
}

type VerifyDs3TargetSpectraS3Response struct {
    Ds3Target Ds3Target
    Headers *http.Header
}

func (verifyDs3TargetSpectraS3Response *VerifyDs3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyDs3TargetSpectraS3Response.Ds3Target)
}

func NewVerifyDs3TargetSpectraS3Response(webResponse WebResponse) (*VerifyDs3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyDs3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyPhysicalPlacementForObjectsSpectraS3Request struct {
    BucketName string
    ObjectNames []string
    StorageDomainId *string
}

func NewVerifyPhysicalPlacementForObjectsSpectraS3Request(bucketName string, objectNames []string) *VerifyPhysicalPlacementForObjectsSpectraS3Request {
    return &VerifyPhysicalPlacementForObjectsSpectraS3Request{
        BucketName: bucketName,
        ObjectNames: objectNames,
    }
}

func (verifyPhysicalPlacementForObjectsSpectraS3Request *VerifyPhysicalPlacementForObjectsSpectraS3Request) WithStorageDomainId(storageDomainId string) *VerifyPhysicalPlacementForObjectsSpectraS3Request {
    verifyPhysicalPlacementForObjectsSpectraS3Request.StorageDomainId = &storageDomainId
    return verifyPhysicalPlacementForObjectsSpectraS3Request
}

type VerifyPhysicalPlacementForObjectsSpectraS3Response struct {
    PhysicalPlacement PhysicalPlacement
    Headers *http.Header
}

func (verifyPhysicalPlacementForObjectsSpectraS3Response *VerifyPhysicalPlacementForObjectsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyPhysicalPlacementForObjectsSpectraS3Response.PhysicalPlacement)
}

func NewVerifyPhysicalPlacementForObjectsSpectraS3Response(webResponse WebResponse) (*VerifyPhysicalPlacementForObjectsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyPhysicalPlacementForObjectsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request struct {
    BucketName string
    ObjectNames []string
    StorageDomainId *string
}

func NewVerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request(bucketName string, objectNames []string) *VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request {
    return &VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request{
        BucketName: bucketName,
        ObjectNames: objectNames,
    }
}

func (verifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request *VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request) WithStorageDomainId(storageDomainId string) *VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request {
    verifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request.StorageDomainId = &storageDomainId
    return verifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Request
}

type VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response struct {
    BulkObjectList BulkObjectList
    Headers *http.Header
}

func (verifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response *VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response.BulkObjectList)
}

func NewVerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response(webResponse WebResponse) (*VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyPhysicalPlacementForObjectsWithFullDetailsSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyPoolSpectraS3Request struct {
    Pool string
    Priority Priority
}

func NewVerifyPoolSpectraS3Request(pool string) *VerifyPoolSpectraS3Request {
    return &VerifyPoolSpectraS3Request{
        Pool: pool,
    }
}

func (verifyPoolSpectraS3Request *VerifyPoolSpectraS3Request) WithPriority(priority Priority) *VerifyPoolSpectraS3Request {
    verifyPoolSpectraS3Request.Priority = priority
    return verifyPoolSpectraS3Request
}

type VerifyPoolSpectraS3Response struct {
    Pool Pool
    Headers *http.Header
}

func (verifyPoolSpectraS3Response *VerifyPoolSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyPoolSpectraS3Response.Pool)
}

func NewVerifyPoolSpectraS3Response(webResponse WebResponse) (*VerifyPoolSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyPoolSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyS3TargetSpectraS3Request struct {
    FullDetails bool
    S3Target string
}

func NewVerifyS3TargetSpectraS3Request(s3Target string) *VerifyS3TargetSpectraS3Request {
    return &VerifyS3TargetSpectraS3Request{
        S3Target: s3Target,
    }
}

func (verifyS3TargetSpectraS3Request *VerifyS3TargetSpectraS3Request) WithFullDetails() *VerifyS3TargetSpectraS3Request {
    verifyS3TargetSpectraS3Request.FullDetails = true
    return verifyS3TargetSpectraS3Request
}

type VerifyS3TargetSpectraS3Response struct {
    S3Target S3Target
    Headers *http.Header
}

func (verifyS3TargetSpectraS3Response *VerifyS3TargetSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyS3TargetSpectraS3Response.S3Target)
}

func NewVerifyS3TargetSpectraS3Response(webResponse WebResponse) (*VerifyS3TargetSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyS3TargetSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifySafeToCreatePutJobSpectraS3Request struct {
    BucketName string
}

func NewVerifySafeToCreatePutJobSpectraS3Request(bucketName string) *VerifySafeToCreatePutJobSpectraS3Request {
    return &VerifySafeToCreatePutJobSpectraS3Request{
        BucketName: bucketName,
    }
}

type VerifySafeToCreatePutJobSpectraS3Response struct {
    
    Headers *http.Header
}



func NewVerifySafeToCreatePutJobSpectraS3Response(webResponse WebResponse) (*VerifySafeToCreatePutJobSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        return &VerifySafeToCreatePutJobSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifySystemHealthSpectraS3Request struct {
}

func NewVerifySystemHealthSpectraS3Request() *VerifySystemHealthSpectraS3Request {
    return &VerifySystemHealthSpectraS3Request{
    }
}

type VerifySystemHealthSpectraS3Response struct {
    HealthVerificationResult HealthVerificationResult
    Headers *http.Header
}

func (verifySystemHealthSpectraS3Response *VerifySystemHealthSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifySystemHealthSpectraS3Response.HealthVerificationResult)
}

func NewVerifySystemHealthSpectraS3Response(webResponse WebResponse) (*VerifySystemHealthSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifySystemHealthSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyTapeSpectraS3Request struct {
    TapeId string
    TaskPriority Priority
}

func NewVerifyTapeSpectraS3Request(tapeId string) *VerifyTapeSpectraS3Request {
    return &VerifyTapeSpectraS3Request{
        TapeId: tapeId,
    }
}

func (verifyTapeSpectraS3Request *VerifyTapeSpectraS3Request) WithTaskPriority(taskPriority Priority) *VerifyTapeSpectraS3Request {
    verifyTapeSpectraS3Request.TaskPriority = taskPriority
    return verifyTapeSpectraS3Request
}

type VerifyTapeSpectraS3Response struct {
    Tape Tape
    Headers *http.Header
}

func (verifyTapeSpectraS3Response *VerifyTapeSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, &verifyTapeSpectraS3Response.Tape)
}

func NewVerifyTapeSpectraS3Response(webResponse WebResponse) (*VerifyTapeSpectraS3Response, error) {
    expectedStatusCodes := []int { 200 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyTapeSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VerifyUserIsMemberOfGroupSpectraS3Request struct {
    Group string
    UserId *string
}

func NewVerifyUserIsMemberOfGroupSpectraS3Request(group string) *VerifyUserIsMemberOfGroupSpectraS3Request {
    return &VerifyUserIsMemberOfGroupSpectraS3Request{
        Group: group,
    }
}

func (verifyUserIsMemberOfGroupSpectraS3Request *VerifyUserIsMemberOfGroupSpectraS3Request) WithUserId(userId string) *VerifyUserIsMemberOfGroupSpectraS3Request {
    verifyUserIsMemberOfGroupSpectraS3Request.UserId = &userId
    return verifyUserIsMemberOfGroupSpectraS3Request
}

type VerifyUserIsMemberOfGroupSpectraS3Response struct {
    Group *Group
    Headers *http.Header
}

func (verifyUserIsMemberOfGroupSpectraS3Response *VerifyUserIsMemberOfGroupSpectraS3Response) parse(webResponse WebResponse) error {
        return parseResponsePayload(webResponse, verifyUserIsMemberOfGroupSpectraS3Response.Group)
}

func NewVerifyUserIsMemberOfGroupSpectraS3Response(webResponse WebResponse) (*VerifyUserIsMemberOfGroupSpectraS3Response, error) {
    expectedStatusCodes := []int { 200, 204 }

    switch code := webResponse.StatusCode(); code {
    case 200:
        var body VerifyUserIsMemberOfGroupSpectraS3Response
        if err := body.parse(webResponse); err != nil {
            return nil, err
        }
        body.Headers = webResponse.Header()
        return &body, nil
    case 204:
        return &VerifyUserIsMemberOfGroupSpectraS3Response{Headers: webResponse.Header()}, nil
    default:
        return nil, buildBadStatusCodeError(webResponse, expectedStatusCodes)
    }
}
type VersioningLevel Enum

const (
    VERSIONING_LEVEL_NONE VersioningLevel = 1 + iota
    VERSIONING_LEVEL_KEEP_LATEST VersioningLevel = 1 + iota
)

func (versioningLevel *VersioningLevel) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *versioningLevel = UNDEFINED
        case "NONE": *versioningLevel = VERSIONING_LEVEL_NONE
        case "KEEP_LATEST": *versioningLevel = VERSIONING_LEVEL_KEEP_LATEST
        default:
            *versioningLevel = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into VersioningLevel", str))
    }
    return nil
}

func (versioningLevel VersioningLevel) String() string {
    switch versioningLevel {
        case VERSIONING_LEVEL_NONE: return "NONE"
        case VERSIONING_LEVEL_KEEP_LATEST: return "KEEP_LATEST"
        default:
            log.Printf("Error: invalid VersioningLevel represented by '%d'", versioningLevel)
            return ""
    }
}

func (versioningLevel VersioningLevel) StringPtr() *string {
    if versioningLevel == UNDEFINED {
        return nil
    }
    result := versioningLevel.String()
    return &result
}
type WriteOptimization Enum

const (
    WRITE_OPTIMIZATION_CAPACITY WriteOptimization = 1 + iota
    WRITE_OPTIMIZATION_PERFORMANCE WriteOptimization = 1 + iota
)

func (writeOptimization *WriteOptimization) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *writeOptimization = UNDEFINED
        case "CAPACITY": *writeOptimization = WRITE_OPTIMIZATION_CAPACITY
        case "PERFORMANCE": *writeOptimization = WRITE_OPTIMIZATION_PERFORMANCE
        default:
            *writeOptimization = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into WriteOptimization", str))
    }
    return nil
}

func (writeOptimization WriteOptimization) String() string {
    switch writeOptimization {
        case WRITE_OPTIMIZATION_CAPACITY: return "CAPACITY"
        case WRITE_OPTIMIZATION_PERFORMANCE: return "PERFORMANCE"
        default:
            log.Printf("Error: invalid WriteOptimization represented by '%d'", writeOptimization)
            return ""
    }
}

func (writeOptimization WriteOptimization) StringPtr() *string {
    if writeOptimization == UNDEFINED {
        return nil
    }
    result := writeOptimization.String()
    return &result
}
type WritePreferenceLevel Enum

const (
    WRITE_PREFERENCE_LEVEL_HIGH WritePreferenceLevel = 1 + iota
    WRITE_PREFERENCE_LEVEL_NORMAL WritePreferenceLevel = 1 + iota
    WRITE_PREFERENCE_LEVEL_LOW WritePreferenceLevel = 1 + iota
    WRITE_PREFERENCE_LEVEL_NEVER_SELECT WritePreferenceLevel = 1 + iota
)

func (writePreferenceLevel *WritePreferenceLevel) UnmarshalText(text []byte) error {
    var str string = string(bytes.ToUpper(text))
    switch str {
        case "": *writePreferenceLevel = UNDEFINED
        case "HIGH": *writePreferenceLevel = WRITE_PREFERENCE_LEVEL_HIGH
        case "NORMAL": *writePreferenceLevel = WRITE_PREFERENCE_LEVEL_NORMAL
        case "LOW": *writePreferenceLevel = WRITE_PREFERENCE_LEVEL_LOW
        case "NEVER_SELECT": *writePreferenceLevel = WRITE_PREFERENCE_LEVEL_NEVER_SELECT
        default:
            *writePreferenceLevel = UNDEFINED
            return errors.New(fmt.Sprintf("Cannot marshal '%s' into WritePreferenceLevel", str))
    }
    return nil
}

func (writePreferenceLevel WritePreferenceLevel) String() string {
    switch writePreferenceLevel {
        case WRITE_PREFERENCE_LEVEL_HIGH: return "HIGH"
        case WRITE_PREFERENCE_LEVEL_NORMAL: return "NORMAL"
        case WRITE_PREFERENCE_LEVEL_LOW: return "LOW"
        case WRITE_PREFERENCE_LEVEL_NEVER_SELECT: return "NEVER_SELECT"
        default:
            log.Printf("Error: invalid WritePreferenceLevel represented by '%d'", writePreferenceLevel)
            return ""
    }
}

func (writePreferenceLevel WritePreferenceLevel) StringPtr() *string {
    if writePreferenceLevel == UNDEFINED {
        return nil
    }
    result := writePreferenceLevel.String()
    return &result
}
type XmlNode struct {
    XMLName  xml.Name
    Attrs    []xml.Attr `xml:"-"` // Does not parse attributes in sax parser
    Content  []byte     `xml:",chardata"`
    Children []XmlNode     `xml:",any"`
}

// Uses the Go library to unmarshal XML into a simple node structure
func (xmlNode *XmlNode) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
    xmlNode.Attrs = start.Attr

    type n XmlNode

    return d.DecodeElement((*n)(xmlNode), &start)
}
